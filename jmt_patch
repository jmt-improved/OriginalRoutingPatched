Index: src/main/java/jmt/gui/common/definitions/CommonModel.java
===================================================================
--- src/main/java/jmt/gui/common/definitions/CommonModel.java	(revision 978)
+++ src/main/java/jmt/gui/common/definitions/CommonModel.java	(working copy)
@@ -3542,9 +3542,15 @@
 		/** Reference to owner blocking station or null */
 		public Object blockingRegion;
 
+		// Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+		public boolean pinned;
+
 		public StationData(String name, String type) {
 			this.name = name;
 			this.type = type;
+			// Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+			// by default this station is free to move when autoarrange/snap to grid is utilized
+			this.pinned = false;
 		}
 	}
 
@@ -4053,6 +4059,32 @@
 		}
 	}
 
+	// Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+	@Override
+	public boolean isPinned(Object stationKey) {
+		StationData sd;
+		if (stationDataHM.containsKey(stationKey)) {
+			sd = (StationData) stationDataHM.get(stationKey);
+		} else {
+			return false;
+		}
+
+		return sd.pinned;
+	}
+
+	// Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+	@Override
+	public void setIsPinned(Object stationKey, boolean value) {
+		StationData sd;
+		if (stationDataHM.containsKey(stationKey)) {
+			sd = (StationData) stationDataHM.get(stationKey);
+		} else {
+			return;
+		}
+
+		sd.pinned = value;
+	}
+
 	/**
 	 * Returns given name if a mode with the same name does not exist or makes it unique
 	 * for a transition
Index: src/main/java/jmt/gui/common/definitions/StationDefinition.java
===================================================================
--- src/main/java/jmt/gui/common/definitions/StationDefinition.java	(revision 978)
+++ src/main/java/jmt/gui/common/definitions/StationDefinition.java	(working copy)
@@ -637,4 +637,15 @@
 	 */
 	public void setFiringOutcome(Object stationKey, int modeIndex, Object stationOutKey, Object classKey, Integer value);
 
+	/**
+	 * Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+	 * Returns pin status for <code>stationKey</code>
+	 */
+	boolean isPinned(Object stationKey);
+
+	/**
+	 * Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+	 * Sets new pin status for <code>stationKey</code>
+	 */
+	void setIsPinned(Object statioKey, boolean value);
 }
Index: src/main/java/jmt/gui/common/xml/GuiXMLConstants.java
===================================================================
--- src/main/java/jmt/gui/common/xml/GuiXMLConstants.java	(revision 978)
+++ src/main/java/jmt/gui/common/xml/GuiXMLConstants.java	(working copy)
@@ -41,6 +41,7 @@
 	public static final String XML_A_POSITION_X = "x";
 	public static final String XML_A_POSITION_Y = "y";
 	public static final String XML_A_POSITION_ROTATE = "rotate";
+	public static final String XML_A_PIN = "pin";
 
 	public static final String XML_E_PARAMETRIC = "parametric";
 	public static final String XML_A_PARAMETRIC_CLASSPATH = "classPath";
Index: src/main/java/jmt/gui/common/xml/GuiXMLReader.java
===================================================================
--- src/main/java/jmt/gui/common/xml/GuiXMLReader.java	(revision 978)
+++ src/main/java/jmt/gui/common/xml/GuiXMLReader.java	(working copy)
@@ -135,6 +135,8 @@
 		Element station, position;
 		String name;
 		double x, y;
+		// Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+		boolean pinned = false;
 		boolean rotate = false;
 		// For each stored Station
 		for (int i = 0; i < stations.getLength(); i++) {
@@ -146,11 +148,18 @@
 			if (position.hasAttribute(XML_A_POSITION_ROTATE)) {
 				rotate = Boolean.TRUE.toString().equalsIgnoreCase(position.getAttribute(XML_A_POSITION_ROTATE));
 			}
+			/* Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+			 * Sets pin status based on XML attribute's value, if not present, by default it is set to false.
+			 */
+			if (position.hasAttribute(XML_A_PIN)) {
+				pinned = Boolean.parseBoolean(position.getAttribute(XML_A_PIN));
+			}
 			if (names.containsKey(name)) {
 				model.setStationPosition(names.get(name), new JMTPoint(x, y, rotate));
 			} else {
 				System.out.println("Error - Found position info for station '" + name + "' which is not present into current model.");
 			}
+			model.setIsPinned(names.get(name), pinned);
 		}
 	}
 
Index: src/main/java/jmt/gui/common/xml/GuiXMLWriter.java
===================================================================
--- src/main/java/jmt/gui/common/xml/GuiXMLWriter.java	(revision 978)
+++ src/main/java/jmt/gui/common/xml/GuiXMLWriter.java	(working copy)
@@ -181,6 +181,8 @@
 			position.setAttribute(XML_A_POSITION_X, String.valueOf(model.getStationPosition(stationKey).getX()));
 			position.setAttribute(XML_A_POSITION_Y, String.valueOf(model.getStationPosition(stationKey).getY()));
 			position.setAttribute(XML_A_POSITION_ROTATE, String.valueOf(model.getStationPosition(stationKey).isRotate()));
+			// Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+			position.setAttribute(XML_A_PIN, String.valueOf(model.isPinned(stations.get(i))));
 			station.appendChild(position);
 			guiNode.appendChild(station);
 		}
Index: src/main/java/jmt/gui/jsimgraph/JGraphMod/CellComponent.java
===================================================================
--- src/main/java/jmt/gui/jsimgraph/JGraphMod/CellComponent.java	(revision 978)
+++ src/main/java/jmt/gui/jsimgraph/JGraphMod/CellComponent.java	(working copy)
@@ -54,6 +54,12 @@
 	}
 
 	/**
+	 * Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+	 * Returns pin status based on the value stored in the JModelStationDefinition instance attached to this CellComponent.
+	 */
+	public boolean isPinned() { return sd.isPinned(key); }
+
+	/**
 	 * Returns key referencing this station
 	 * @return this station's key
 	 */
Index: src/main/java/jmt/gui/jsimgraph/JGraphMod/JmtCell.java
===================================================================
--- src/main/java/jmt/gui/jsimgraph/JGraphMod/JmtCell.java	(revision 978)
+++ src/main/java/jmt/gui/jsimgraph/JGraphMod/JmtCell.java	(working copy)
@@ -1,16 +1,16 @@
 /**
  * Copyright (C) 2016, Laboratorio di Valutazione delle Prestazioni - Politecnico di Milano
-
+ * <p>
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
-
+ * <p>
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  * GNU General Public License for more details.
-
+ * <p>
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
@@ -26,8 +26,7 @@
 import java.awt.font.FontRenderContext;
 import java.awt.geom.Point2D;
 import java.awt.geom.Rectangle2D;
-import java.util.Hashtable;
-import java.util.Map;
+import java.util.*;
 
 import javax.swing.Icon;
 import javax.swing.ImageIcon;
@@ -35,251 +34,271 @@
 
 import jmt.gui.common.JMTImageLoader;
 
+import jmt.gui.common.MergedIcon;
 import org.jgraph.JGraph;
-import org.jgraph.graph.DefaultGraphCell;
-import org.jgraph.graph.DefaultPort;
-import org.jgraph.graph.GraphConstants;
-import org.jgraph.graph.Port;
+import org.jgraph.graph.*;
 
 /**
  * vertex cell for jmt
  *
  * @author Federico Granata
- * Date: 11-lug-2003
- * Time: 13.48.34
- *
+ *         Date: 11-lug-2003
+ *         Time: 13.48.34
  * @author Bertoli Marco
  */
 public abstract class JmtCell extends DefaultGraphCell {
 
-	private static final long serialVersionUID = 1L;
-	private Dimension imageDimension;
-	// Used to determine if parent of this cell has changed (to detect enter and exit from
-	// blocking regions)
-	private TreeNode parentRef;
-	/**
-	 * Different kind of nodes.
-	 */
-	public static final int SOURCE = 0;
-	public static final int TERMINAL = 1;
-	public static final int DELAY = 2;
-	public static final int SERVER = 3;
-	public static final int SINK = 4;
-	public static final int FORK = 5;
-	public static final int JOIN = 6;
-	public static final int LDSERVER = 7;
-	public static final int CLASSSWITCH = 8;
-	public static final int SEMAPHORE = 9;
-	public static final int SCALER = 10;
-	public static final int PLACE = 11;
-	public static final int TRANSITION = 12;
+    private static final long serialVersionUID = 1L;
+    private Dimension imageDimension;
+    // Used to determine if parent of this cell has changed (to detect enter and exit from
+    // blocking regions)
+    private TreeNode parentRef;
 
-	private Port[] ports;
+    /**
+     * Different kind of nodes.
+     */
+    public static final int SOURCE = 0;
+    public static final int TERMINAL = 1;
+    public static final int DELAY = 2;
+    public static final int SERVER = 3;
+    public static final int SINK = 4;
+    public static final int FORK = 5;
+    public static final int JOIN = 6;
+    public static final int LDSERVER = 7;
+    public static final int CLASSSWITCH = 8;
+    public static final int SEMAPHORE = 9;
+    public static final int SCALER = 10;
+    public static final int PLACE = 11;
+    public static final int TRANSITION = 12;
 
-	// Giuseppe De Cicco & Fabio Granara
-	public boolean seen = false;
-	public int in = 0;
-	public int out = 0;
-	public boolean okin = false;
-	public boolean okout = false;
-	public int sons = 1;
-	public int type;
-	private boolean leftInputCell = true;
+    private Port[] ports;
 
-	/**
-	 * Tells if this component can be placed on JGraph or has been disabled. This is
-	 * useful to load old models with disabled components (like terminals)
-	 */
-	public static final boolean canBePlaced = true;
+    // Giuseppe De Cicco & Fabio Granara
+    public boolean seen = false;
+    public int in = 1;
+    public int out = 1;
+    public boolean okin = false;
+    public boolean okout = false;
+    public int sons = 1;
+    public int type;
+    private boolean leftInputCell = true;
 
-	/**
-	 * Creates a graph cell and initializes it with the specified user object.
-	 *
-	 * @param userObject an Object provided by the user that constitutes
-	 *                   the cell's data
-	 *
-	 * Conti Andrea  01-09-2003
-	 * Bertoli Marco 04-giu-2005
-	 */
-	public JmtCell(String icon, Object userObject) {
-		super(userObject);
-		ImageIcon ico = JMTImageLoader.loadImage(icon);
-		GraphConstants.setIcon(attributes, ico);
-		imageDimension = new Dimension(ico.getIconWidth(), ico.getIconHeight());
-		GraphConstants.setSizeable(attributes, false);
-		GraphConstants.setSize(attributes, imageDimension);
-	}
+    /**
+     * Tells if this component can be placed on JGraph or has been disabled. This is
+     * useful to load old models with disabled components (like terminals)
+     */
+    public static final boolean canBePlaced = true;
 
-	// Giuseppe De Cicco & Fabio Granara
-	public void AddIn() {
-		in += 1;
-	}
+    /**
+     * Creates a graph cell and initializes it with the specified user object.
+     *
+     * @param userObject an Object provided by the user that constitutes
+     *                   the cell's data
+     *                   <p>
+     *                   Conti Andrea  01-09-2003
+     *                   Bertoli Marco 04-giu-2005
+     */
+    public JmtCell(String icon, Object userObject) {
+        super(userObject);
+        ImageIcon ico = JMTImageLoader.loadImage(icon);
+        // Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+        // Display a lock if this cell is pinned.
+        if (isPinned()) {
+            ImageIcon lockIcon = JMTImageLoader.loadImage("lock", new Dimension(16, 16));
+            GraphConstants.setIcon(attributes, new MergedIcon(JMTImageLoader.loadImage(icon), lockIcon));
+        } else {
+            GraphConstants.setIcon(attributes, ico);
+        }
+        imageDimension = new Dimension(ico.getIconWidth(), ico.getIconHeight());
+        GraphConstants.setSizeable(attributes, false);
+        GraphConstants.setSize(attributes, imageDimension);
+    }
 
-	// Giuseppe De Cicco & Fabio Granara
-	public void SubIn() {
-		in -= 1;
-	}
+    // Giuseppe De Cicco & Fabio Granara
+    public void AddIn() {
+        in += 1;
+    }
 
-	// Giuseppe De Cicco & Fabio Granara
-	public void AddOut() {
-		out += 1;
-	}
+    // Giuseppe De Cicco & Fabio Granara
+    public void SubIn() {
+        in -= 1;
+    }
 
-	// Giuseppe De Cicco & Fabio Granara
-	public void SubOut() {
-		out -= 1;
-	}
+    // Giuseppe De Cicco & Fabio Granara
+    public void AddOut() {
+        out += 1;
+    }
 
-	/**
-	 * Returns Cell's real size (this method considers Icon and name size)
-	 *
-	 * @param graph <code>JGraph</code> object to retrieve font dimension informations
-	 * @return cell's real size
-	 *
-	 * Bertoli Marco  4-giu-2005
-	 */
-	public Dimension getSize(JGraph graph) {
-		Dimension cellDimension = (Dimension) imageDimension.clone();
-		// Gets the graph font
-		Font font = graph.getFont();
-		// Gets the graphical context
-		Graphics2D g2D = (Graphics2D) graph.getGraphics();
-		// Gets the bounds of the cell name
-		FontRenderContext frc = g2D.getFontRenderContext();
-		Rectangle r = font.getStringBounds(getUserObject().toString(), frc).getBounds();
-		// Sets the cell dimension
-		cellDimension.height += r.height + 5;
-		cellDimension.width = Math.max(cellDimension.width, r.width + 10);
-		return cellDimension;
-	}
+    // Giuseppe De Cicco & Fabio Granara
+    public void SubOut() {
+        out -= 1;
+    }
 
-	/**
-	 * Creates the ports for this vertex
-	 *
-	 * @return array of ports
-	 */
-	public abstract Port[] createPorts();
+    public int numInEdges() {
+        return in;
+    }
 
-	/**
-	 * Sets all the attributes like background colour, dimensions, port number
-	 * & position
-	 *
-	 * @param pt
-	 * @return created map
-	 */
-	public Hashtable<Object, Map> setAttributes(Point2D pt, JGraph graph) {
-		//contains attribute of the cell & ports
-		Hashtable<Object, Map> nest = new Hashtable<Object, Map>();
+    public int numOutEdges() {
+        return out;
+    }
 
-		Dimension cellDimension = getSize(graph);
-		//contains attrib of cell
-		Map attr = getAttributes();
-		GraphConstants.setBounds(attr, new Rectangle2D.Double(pt.getX(), pt.getY(), cellDimension.getWidth(), cellDimension.getHeight()));
-		GraphConstants.setEditable(attr, false);
-		GraphConstants.setBackground(attr, graph.getBackground());
-		nest.put(this, attr);
+    // Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+    public boolean isPinned() {
+        return ((CellComponent) getUserObject()).isPinned();
+    }
 
-		//create ports
-		ports = createPorts();
-		Icon icon = GraphConstants.getIcon(attr);
-		updatePortPositions(nest, icon, cellDimension);
-		for (Port port : ports) {
-			add((DefaultPort) port);
-		}
-		return nest;
-	}
+    /**
+     * Returns Cell's real size (this method considers Icon and name size)
+     *
+     * @param graph <code>JGraph</code> object to retrieve font dimension informations
+     * @return cell's real size
+     * <p>
+     * Bertoli Marco  4-giu-2005
+     */
+    public Dimension getSize(JGraph graph) {
+        Dimension cellDimension = (Dimension) imageDimension.clone();
+        // Gets the graph font
+        Font font = graph.getFont();
+        // Gets the graphical context
+        Graphics2D g2D = (Graphics2D) graph.getGraphics();
+        // Gets the bounds of the cell name
+        FontRenderContext frc = g2D.getFontRenderContext();
+        Rectangle r = font.getStringBounds(getUserObject().toString(), frc).getBounds();
+        // Sets the cell dimension
+        cellDimension.height += r.height + 5;
+        cellDimension.width = Math.max(cellDimension.width, r.width + 10);
+        return cellDimension;
+    }
 
-	public void updatePortPositions(Map<Object, Map> nest, Icon icon, Dimension cellDimension) {
-		for (Port port : ports) {
-			Map attr = new Hashtable();
-			if (port instanceof InputPort && isLeftInputCell() || port instanceof OutputPort && !isLeftInputCell()) {
-				GraphConstants.setOffset(attr, getInPortOffset(icon, cellDimension));
-			} else {
-				GraphConstants.setOffset(attr, getOutPortoffset(icon, cellDimension));
-			}
-			nest.put(port, attr);
-		}
-	}
+    /**
+     * Creates the ports for this vertex
+     *
+     * @return array of ports
+     */
+    public abstract Port[] createPorts();
 
-	protected Point getInPortOffset(Icon icon, Dimension cellDimension) {
-		int iconHeight = icon.getIconHeight();
-		int iconWidth = icon.getIconWidth();
-		int xOff = (cellDimension.width - iconWidth) / 2 * 1000 / cellDimension.width;
-		int yOff = iconHeight / 2 * 1000 / cellDimension.height;
-		return new Point(xOff, yOff);
-	}
+    /**
+     * Sets all the attributes like background colour, dimensions, port number
+     * & position
+     *
+     * @param pt
+     * @return created map
+     */
+    public Hashtable<Object, Map> setAttributes(Point2D pt, JGraph graph) {
+        //contains attribute of the cell & ports
+        Hashtable<Object, Map> nest = new Hashtable<Object, Map>();
 
-	protected Point getOutPortoffset(Icon icon, Dimension cellDimension) {
-		int iconHeight = icon.getIconHeight();
-		int iconWidth = icon.getIconWidth();
-		int xOff = (cellDimension.width - iconWidth) / 2 * 1000 / cellDimension.width + iconWidth * 1000 / cellDimension.width;
-		int yOff = iconHeight / 2 * 1000 / cellDimension.height;
-		return new Point(xOff, yOff);
-	}
+        Dimension cellDimension = getSize(graph);
+        //contains attrib of cell
+        Map attr = getAttributes();
+        GraphConstants.setBounds(attr, new Rectangle2D.Double(pt.getX(), pt.getY(), cellDimension.getWidth(), cellDimension.getHeight()));
+        GraphConstants.setEditable(attr, false);
+        GraphConstants.setBackground(attr, graph.getBackground());
+        nest.put(this, attr);
 
-	/**
-	 * Tells if the InputPort of this cell is on the left side
-	 * @return true if the InputPort of this cell is on the left side
-	 */
-	// Giuseppe De Cicco & Fabio Granara
-	public boolean isLeftInputCell() {
-		return leftInputCell;
-	}
+        //create ports
+        ports = createPorts();
+        Icon icon = GraphConstants.getIcon(attr);
+        updatePortPositions(nest, icon, cellDimension);
+        for (Port port : ports) {
+            add((DefaultPort) port);
+        }
 
-	// Giuseppe De Cicco & Fabio Granara
-	public void setLeftInputCell(boolean state) {
-		leftInputCell = state;
-	}
+        return nest;
+    }
 
-	/**
-	 * Resets stored parent information for this cell
-	 */
-	public void resetParent() {
-		parentRef = getParent();
-	}
+    public void updatePortPositions(Map<Object, Map> nest, Icon icon, Dimension cellDimension) {
+        for (Port port : ports) {
+            Map attr = new Hashtable();
+            if (port instanceof InputPort && isLeftInputCell() || port instanceof OutputPort && !isLeftInputCell()) {
+                GraphConstants.setOffset(attr, getInPortOffset(icon, cellDimension));
+            } else {
+                Point offset = getOutPortoffset(icon, cellDimension);
+                GraphConstants.setOffset(attr, offset);
+            }
+            nest.put(port, attr);
+        }
+    }
 
-	/**
-	 * Tells if this cell parent was changed since last call to resetParent() method
-	 *
-	 * @return true if parent changed, false otherwise
-	 * @see #resetParent()
-	 */
-	public boolean parentChanged() {
-		if (parentRef == null && getParent() == null) {
-			return false;
-		} else if (parentRef == null || getParent() == null) {
-			return true;
-		} else {
-			return !parentRef.equals(getParent());
-		}
-	}
+    protected Point getInPortOffset(Icon icon, Dimension cellDimension) {
+        int iconHeight = icon.getIconHeight();
+        int iconWidth = icon.getIconWidth();
+        int xOff = (cellDimension.width - iconWidth) / 2 * 1000 / cellDimension.width;
+        int yOff = iconHeight / 2 * 1000 / cellDimension.height;
+        return new Point(xOff, yOff);
+    }
 
-	/**
-	 * Tells if this station generates or destroys jobs (useful for blocking region
-	 * management)
-	 *
-	 * @return true if this station generates or destroy jobs, false otherwise
-	 */
-	public boolean generateOrDestroyJobs() {
-		return false;
-	}
+    protected Point getOutPortoffset(Icon icon, Dimension cellDimension) {
+        int iconHeight = icon.getIconHeight();
+        int iconWidth = icon.getIconWidth();
+        int xOff = (cellDimension.width - iconWidth) / 2 * 1000 / cellDimension.width + iconWidth * 1000 / cellDimension.width;
+        int yOff = iconHeight / 2 * 1000 / cellDimension.height;
+        return new Point(xOff, yOff);
+    }
 
-	/**
-	 * Returns previous parent of this cell (the one present when resetParent()
-	 * method was called)
-	 *
-	 * @return previous parent of this cell
-	 * @see #resetParent()
-	 */
-	public TreeNode getPrevParent() {
-		return parentRef;
-	}
+    /**
+     * Tells if the InputPort of this cell is on the left side
+     *
+     * @return true if the InputPort of this cell is on the left side
+     */
+    // Giuseppe De Cicco & Fabio Granara
+    public boolean isLeftInputCell() {
+        return leftInputCell;
+    }
 
-	/**
-	 * Returns the name of the icon of this cell
-	 *
-	 * @return the name of the icon of this cell
-	 */
-	public abstract String getIcon();
+    // Giuseppe De Cicco & Fabio Granara
+    public void setLeftInputCell(boolean state) {
+        leftInputCell = state;
+    }
 
+    /**
+     * Resets stored parent information for this cell
+     */
+    public void resetParent() {
+        parentRef = getParent();
+    }
+
+    /**
+     * Tells if this cell parent was changed since last call to resetParent() method
+     *
+     * @return true if parent changed, false otherwise
+     * @see #resetParent()
+     */
+    public boolean parentChanged() {
+        if (parentRef == null && getParent() == null) {
+            return false;
+        } else if (parentRef == null || getParent() == null) {
+            return true;
+        } else {
+            return !parentRef.equals(getParent());
+        }
+    }
+
+    /**
+     * Tells if this station generates or destroys jobs (useful for blocking region
+     * management)
+     *
+     * @return true if this station generates or destroy jobs, false otherwise
+     */
+    public boolean generateOrDestroyJobs() {
+        return false;
+    }
+
+    /**
+     * Returns previous parent of this cell (the one present when resetParent()
+     * method was called)
+     *
+     * @return previous parent of this cell
+     * @see #resetParent()
+     */
+    public TreeNode getPrevParent() {
+        return parentRef;
+    }
+
+    /**
+     * Returns the name of the icon of this cell
+     *
+     * @return the name of the icon of this cell
+     */
+    public abstract String getIcon();
 }
Index: src/main/java/jmt/gui/jsimgraph/JGraphMod/JmtEdge.java
===================================================================
--- src/main/java/jmt/gui/jsimgraph/JGraphMod/JmtEdge.java	(revision 978)
+++ src/main/java/jmt/gui/jsimgraph/JGraphMod/JmtEdge.java	(working copy)
@@ -47,6 +47,19 @@
  * 
  */
 public class JmtEdge extends DefaultEdge {
+
+	/*
+	 * Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+	 * Identifies the type of edge, useful for routing purposes.
+	 */
+	public enum Type {
+		INVALID,
+		LOOP_BACK_UPPER,
+		LEFT_TO_RIGHT,
+		LOOP_BACK_LOWER,
+		RING
+	};
+
 	/**
 	 * 
 	 */
@@ -69,6 +82,14 @@
 	private Mediator mediator;
 	public ArrayList<Point2D> intersectionEdgePoint = new ArrayList<Point2D>();
 
+	/*
+	 * Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+	 * Stores the last routing points computed by the algorithm in class JmtRouting
+	 */
+	private List<Point2D> routedPoints = new ArrayList<>();
+
+	private Type type = Type.INVALID;
+
 	//    public ArrayList intersectionEdgePoint2=new ArrayList();
 
 	public JmtEdge() {
@@ -162,7 +183,8 @@
 			Point2D tmpMin = controlPoints[i];
 			Point2D tmpMax = controlPoints[i + 1];
 			//nel caso di lati che vanno nel verso oposto
-			if ((tmpMin.getX() > tmpMax.getX()) || (tmpMin.getY() > tmpMax.getY())) {
+			// Modified by Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio to take into account multi arrows that can have +-1 difference pixels
+			if ((Math.abs(tmpMax.getX() - tmpMin.getX()) > 2 && (tmpMin.getX()) > tmpMax.getX()) || (Math.abs(tmpMax.getY() - tmpMin.getY()) > 2 && tmpMin.getY() > tmpMax.getY())) {
 				tmpMin = controlPoints[i + 1];
 				tmpMax = controlPoints[i];
 			}
@@ -180,7 +202,7 @@
 						upperSide = true;
 						//    					System.out.println("Valore del controlMin "+(int)tmpMin.getX());
 						//    					System.out.println("Valore del controlMax "+tmpMax.getX());
-						upperPoint = new Point2D.Double((int) tmpMin.getX(), (int) minY);
+						upperPoint = new Point2D.Double((int) tmpMax.getX(), (int) minY);
 						intersectionVertexPoint.add(upperPoint);
 						//    					System.out.println("upper INTERSECTION");
 						//    					System.out.println("Intersezione Sopra: x="+tmpMin.getX()+", y="+minY);
@@ -187,7 +209,7 @@
 					}
 					if (maxY < tmpMax.getY() && maxY > tmpMin.getY()) {
 						lowerSide = true;
-						lowPoint = new Point2D.Double((int) tmpMin.getX(), (int) maxY);
+						lowPoint = new Point2D.Double((int) tmpMax.getX(), (int) maxY);
 						intersectionVertexPoint.add(lowPoint);
 
 						//    					System.out.println("lower INTERSECTION");
@@ -250,9 +272,9 @@
 			intersectionVertexPoint.set(0, lowPoint);
 			intersectionVertexPoint.set(1, leftPoint);
 		} else if (upperSide && lowerSide) {
-			intersectionVertexPoint.set(0, upperPoint);
-			intersectionVertexPoint.set(1, lowPoint);
-
+			//intersectionVertexPoint.set(0, upperPoint);
+			//intersectionVertexPoint.set(1, lowPoint);
+			intersectionVertexPoint.set(0, new Point2D.Double(Math.max(upperPoint.getX(), lowPoint.getX()), Math.max(upperPoint.getY(), lowPoint.getY())));
 		}
 		//    	if (intersectionVertexPoint2.size()>0) {
 		//    		System.out.println("Subito dopo il tutto: primo punto: x= "+((Point2D)(intersectionVertexPoint2.get(0))).getX()+", y="+((Point2D)(intersectionVertexPoint2.get(0))).getY());
@@ -767,4 +789,38 @@
 		return (int) (max - boundsSource.getMaxX());
 	}
 
+	/*
+	 * Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+	 * Sets new routing points for this edge
+	 */
+	public void setRoutedPoints(List<Point2D> points) {
+		routedPoints.clear();
+		routedPoints.addAll(points);
+	}
+
+	/*
+	 * Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+	 * Gets last computed routing points for this edge
+	 */
+	public List<Point2D> getRoutedPoints() {
+		return routedPoints;
+	}
+
+	/*
+	 * Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+	 * Sets new edge type for this JmtEdge
+	 */
+	public void setType(Type newType) {
+		type = newType;
+	}
+
+	/*
+	 * Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+	 * Gets the edge type for this JmtEdge
+	 */
+	public Type getType() {
+		return type;
+	}
+
+
 }
Index: src/main/java/jmt/gui/jsimgraph/JGraphMod/JmtEdgeRenderer.java
===================================================================
--- src/main/java/jmt/gui/jsimgraph/JGraphMod/JmtEdgeRenderer.java	(revision 978)
+++ src/main/java/jmt/gui/jsimgraph/JGraphMod/JmtEdgeRenderer.java	(working copy)
@@ -32,6 +32,9 @@
  * <p>Title: JmtEdgeRenderer </p>
  * @author Giuseppe De Cicco & Fabio Granara
  * 		Date: 15-ott-2006
+ * 	Modified by  Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio to take into account +-1 pixel offset
+ * 		         on y coordinates due rounding imprecisions when arranging multiple arrows within the same component
+ * 		Date: 09-feb-2017
  * 
  */
 public class JmtEdgeRenderer extends EdgeRenderer {
@@ -138,7 +141,7 @@
 								 * */
 								if (cell.isRing && i == 4) {
 									//	  	        			   System.out.println("____________ENTRATO NEL RING____________");
-									if ((int) p[i].getY() == (int) ((cell.intersectionEdgePoint.get(j))).getY()
+									if (Math.abs((int) p[i].getY() - (int) ((cell.intersectionEdgePoint.get(j))).getY()) <= 1
 											&& (((int) p[i].getX() < (int) ((cell.intersectionEdgePoint.get(j))).getX()))) {
 										int intersectionPoint = (int) ((cell.intersectionEdgePoint.get(j))).getX();
 
@@ -147,7 +150,7 @@
 													.getX()) / 2), (float) ((p[4])).getY() - 10, (float) ((p[5]).getX()), (float) ((p[5]).getY()));
 											view.sharedPath.moveTo((float) (p[5].getX()), (float) (p[5]).getY());
 										}
-									} else if ((int) p[i].getY() == (int) ((cell.intersectionEdgePoint.get(j))).getY()
+									} else if (Math.abs((int) p[i].getY() - (int) ((cell.intersectionEdgePoint.get(j))).getY()) <= 1
 											&& (((int) p[i].getX() > (int) ((cell.intersectionEdgePoint.get(j))).getX()))) {
 										int intersectionPoint = (int) ((cell.intersectionEdgePoint.get(j))).getX();
 										if ((p[5].getX() < p[4].getX()) && (intersectionPoint > ((int) p[5].getX()))) {
@@ -158,8 +161,8 @@
 
 									}
 								} else {
-									if ((int) p[i + 1].getY() == (int) ((cell.intersectionEdgePoint.get(j))).getY()
-											&& (int) p[i].getY() == (int) ((cell.intersectionEdgePoint.get(j))).getY()
+									if (Math.abs((int) p[i + 1].getY() - (int) ((cell.intersectionEdgePoint.get(j))).getY()) <= 1
+											&& Math.abs((int) p[i].getY() - (int) ((cell.intersectionEdgePoint.get(j))).getY()) <= 1
 											&& (((int) p[i].getX() < (int) ((cell.intersectionEdgePoint.get(j))).getX()))
 											&& (((int) p[i + 1].getX() > (int) ((cell.intersectionEdgePoint.get(j))).getX()))) {
 
@@ -167,7 +170,7 @@
 										if (((j + 1) < cell.intersectionEdgePoint.size())
 												&& (((cell.intersectionEdgePoint.get(j + 1))).getX() > ((cell.intersectionEdgePoint.get(j))).getX())
 												&& (((cell.intersectionEdgePoint.get(j + 1))).getX() - ((cell.intersectionEdgePoint.get(j))).getX() < 10)
-												&& ((cell.intersectionEdgePoint.get(j))).getY() == ((cell.intersectionEdgePoint.get(j + 1))).getY()) {
+												&& Math.abs(((cell.intersectionEdgePoint.get(j))).getY() - ((cell.intersectionEdgePoint.get(j + 1))).getY()) <= 1) {
 											double middleX = (((cell.intersectionEdgePoint.get(j + 1))).getX() + ((cell.intersectionEdgePoint.get(j)))
 													.getX()) / 2;
 
@@ -203,9 +206,9 @@
 									//per cui la costruzione deve avvenire in modo inverso
 									else if (((passato == false) || ((passato == true) && (tmp1.size() > 0) && (!tmp1
 											.contains(cell.intersectionEdgePoint.get(j)))))
-											&& (int) p[i].getY() == (int) ((cell.intersectionEdgePoint.get(j))).getY()
+											&& Math.abs((int) p[i].getY() - (int) ((cell.intersectionEdgePoint.get(j))).getY()) <= 1
 											&& (((int) p[i].getX() > (int) p[i + 1].getX()))
-											&& (int) p[i].getY() == (int) ((cell.intersectionEdgePoint.get(j))).getY()
+											&& Math.abs((int) p[i].getY() - (int) ((cell.intersectionEdgePoint.get(j))).getY()) <= 1
 											&& (int) p[i + 1].getX() < (int) ((cell.intersectionEdgePoint.get(j))).getX()) {
 										//	  	        			   System.out.println("Entratooooooooooooooooooooooooo in elseif");
 										//questo if serve per fare un grande arco quando ci sono due punti di int. vicini
@@ -214,7 +217,7 @@
 
 										int contatore = 0;
 										for (int q = 0; q < cell.intersectionEdgePoint.size(); q++) {
-											if ((cell.intersectionEdgePoint.get(q)).getY() == (cell.intersectionEdgePoint.get(j)).getY()) {
+											if (Math.abs((cell.intersectionEdgePoint.get(q)).getY() - (cell.intersectionEdgePoint.get(j)).getY()) <= 1) {
 												tmp1.add((cell.intersectionEdgePoint.get(q)).clone());
 												//	  	        	 			cell.intersectionEdgePoint.remove(((Point2D)cell.intersectionEdgePoint.get(q)));
 												contatore++;
@@ -258,7 +261,7 @@
 
 											} else {
 
-												if ((int) p[i].getY() == (int) ((Point2D) (tmp1.get(x))).getY()) {
+												if (Math.abs((int) p[i].getY() - (int) ((Point2D) (tmp1.get(x))).getY()) <= 1) {
 													view.sharedPath.lineTo((float) ((Point2D) (tmp1.get(x))).getX() + 5, (float) ((Point2D) (tmp1
 															.get(x))).getY());
 													view.sharedPath.moveTo((float) ((Point2D) (tmp1.get(x))).getX() + 5, (float) ((Point2D) (tmp1
@@ -293,9 +296,9 @@
 							//	  	        			   System.out.println("Punti sull'asse"+pointOnFirstPoints.size());
 							for (int j = 0; j < pointOnFirstPoints.size(); j++) {
 								if ((p[1].getX() - p[0].getX()) > 0) {
-									if ((int) p[0].getY() == (int) ((Point2D) (pointOnFirstPoints.get(j))).getY()) {
+									if (Math.abs((int) p[0].getY() - (int) ((Point2D) (pointOnFirstPoints.get(j))).getY()) <= 1) {
 										//	  		            			 System.out.println("entro per sistemare il punto zero in jmtedgerenderer");
-										if ((p[0].getY() == ((Point2D) pointOnFirstPoints.get(j)).getY())
+										if (Math.abs((p[0].getY() - ((Point2D) pointOnFirstPoints.get(j)).getY())) <= 1
 												&& ((int) p[0].getX() < (int) ((Point2D) (pointOnFirstPoints.get(j))).getX())
 												&& (int) ((Point2D) (pointOnFirstPoints.get(j))).getX() < (int) p[1].getX()) {
 											//	  		            					c'era 20 e non 10  
@@ -306,8 +309,8 @@
 															.getX())
 													&& (((Point2D) (pointOnFirstPoints.get(j + 1))).getX()
 															- ((Point2D) (pointOnFirstPoints.get(j))).getX() < 10)
-													&& ((Point2D) (pointOnFirstPoints.get(j))).getY() == ((Point2D) (pointOnFirstPoints.get(j + 1)))
-															.getY()) {
+													&& Math.abs(((Point2D) (pointOnFirstPoints.get(j))).getY() - ((Point2D) (pointOnFirstPoints.get(j + 1)))
+															.getY()) <= 1) {
 												double middleX = (((Point2D) (pointOnFirstPoints.get(j + 1))).getX() + ((Point2D) (pointOnFirstPoints
 														.get(j))).getX()) / 2;
 
@@ -361,7 +364,7 @@
 
 									boolean arcogrande = false;
 									//	  		            			System.out.println("Sono uguali di y: "+(((Point2D)cell.intersectionEdgePoint.get(cell.intersectionEdgePoint.size()-j-1)).getY()==(int)p[0].getY())+"Coordinata x del punto 0: "+p[0].getX()+"Punto di int: "+((Point2D)cell.intersectionEdgePoint.get(cell.intersectionEdgePoint.size()-j-1)).getX());
-									if (((int) p[0].getY() == (int) ((Point2D) pointOnFirstPoints.get(j)).getY())
+									if (Math.abs((int) p[0].getY() -(int) ((Point2D) pointOnFirstPoints.get(j)).getY()) <= 1
 											&& (((int) p[0].getX() > (int) ((Point2D) (pointOnFirstPoints.get(j))).getX()) && (int) ((Point2D) (pointOnFirstPoints
 													.get(j))).getX() > (int) p[1].getX())) {
 										if (((j + 1) < pointOnFirstPoints.size())
Index: src/main/java/jmt/gui/jsimgraph/JGraphMod/JmtJGraph.java
===================================================================
--- src/main/java/jmt/gui/jsimgraph/JGraphMod/JmtJGraph.java	(revision 978)
+++ src/main/java/jmt/gui/jsimgraph/JGraphMod/JmtJGraph.java	(working copy)
@@ -18,23 +18,21 @@
 
 package jmt.gui.jsimgraph.JGraphMod;
 
-import java.awt.Graphics;
+import java.awt.*;
+import java.awt.geom.Point2D;
 
 import jmt.common.GlobalSettings;
 import jmt.gui.common.Defaults;
+import jmt.gui.common.JMTImageLoader;
 import jmt.gui.jsimgraph.controller.Mediator;
 
 import org.freehep.graphics2d.VectorGraphics;
 import org.freehep.graphicsbase.util.export.ExportDialog;
 import org.jgraph.JGraph;
-import org.jgraph.graph.BasicMarqueeHandler;
-import org.jgraph.graph.CellView;
-import org.jgraph.graph.DefaultCellViewFactory;
-import org.jgraph.graph.DefaultGraphModel;
-import org.jgraph.graph.DefaultGraphSelectionModel;
-import org.jgraph.graph.GraphLayoutCache;
-import org.jgraph.graph.GraphModel;
+import org.jgraph.graph.*;
 
+import javax.swing.*;
+
 /** Jmt version of JGraph.
 
  * @author Federico Granata
@@ -167,6 +165,36 @@
 		return null;
 	}
 
+	// Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+	/** Gets a free inport port for the cell under Point(x,y), if this doesn't exists, a new one it is created
+	 * @param x  horizontal coordinate
+	 * @param y  vertical coordinate
+	 * @return the inport port if available else null
+	 */
+	public InputPort getFreeInPortAt(int x, int y) {
+		JmtCell cell = getVertexAt(x, y);
+		for (int i = 0; i < getModel().getChildCount(cell); i++) {
+			Object child = getModel().getChild(cell, i);
+			if (child instanceof InputPort && ((InputPort) child).getEdges().size() == 0) {
+				return (InputPort) child;
+			}
+		}
+		if (cell != null) {
+			InputPort newPort = new InputPort(cell);
+			Icon i = JMTImageLoader.loadImage(cell.getIcon());
+			Dimension d = (Dimension) cell.getAttributes().get("size");
+			Point offset = cell.getInPortOffset(i, d);
+			newPort.getAttributes().put("offset", new Point2D.Double(offset.getX(), offset.getY() - 159));
+			cell.insert(newPort, cell.getChildCount() - 1);
+			cell.AddIn();
+			PortView newPortView = new PortView(newPort);
+			getGraphLayoutCache().putMapping(newPort, newPortView);
+			newPortView.refresh(graphModel, graphLayoutCache, false);
+			return newPort;
+		}
+		return null;
+	}
+
 	/** Gets the outport port for the cell under Point(x,y)
 	 *
 	 * @param x  horizontal coordinate
@@ -242,6 +270,37 @@
 		Defaults.save();
 	}
 
+	// Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+	/** Gets a free output port for the cell under Point(x,y), if this doesn't exists, a new one it is created
+	 *
+	 * @param x  horizontal coordinate
+	 * @param y  vertical coordinate
+	 * @return the outport port if available else null
+	 */
+	public OutputPort getFreeOutPortAt(int x, int y) {
+		JmtCell cell = getVertexAt(x, y);
+		for (int i = 0; i < getModel().getChildCount(cell); i++) {
+			Object child = getModel().getChild(cell, i);
+			if (child instanceof OutputPort && ((OutputPort) child).getEdges().size() == 0) {
+				return (OutputPort) child;
+			}
+		}
+		if (cell != null) {
+			OutputPort newPort = new OutputPort(cell);
+			Icon i = JMTImageLoader.loadImage(cell.getIcon());
+			Dimension d = (Dimension) cell.getAttributes().get("size");
+			Point offset = cell.getOutPortoffset(i, d);
+			newPort.getAttributes().put("offset", new Point2D.Double(offset.getX(), offset.getY() - 159));
+			cell.insert(newPort, cell.getChildCount() - 1);
+			cell.AddOut();
+			PortView newPortView = new PortView(newPort);
+			getGraphLayoutCache().putMapping(newPort, newPortView);
+			newPortView.refresh(graphModel, graphLayoutCache, false);
+			return newPort;
+		}
+		return null;
+	}
+
 	// ------------------------------------------------------------------------------------------
 
 }
Index: src/main/java/jmt/gui/jsimgraph/JGraphMod/JmtRouting.java
===================================================================
--- src/main/java/jmt/gui/jsimgraph/JGraphMod/JmtRouting.java	(revision 978)
+++ src/main/java/jmt/gui/jsimgraph/JGraphMod/JmtRouting.java	(working copy)
@@ -18,18 +18,20 @@
 
 package jmt.gui.jsimgraph.JGraphMod;
 
+import java.awt.*;
 import java.awt.geom.Point2D;
 import java.awt.geom.Rectangle2D;
-import java.util.ArrayList;
+import java.lang.reflect.InvocationTargetException;
+import java.util.*;
 import java.util.List;
 
-import org.jgraph.graph.CellView;
-import org.jgraph.graph.DefaultPort;
-import org.jgraph.graph.Edge;
-import org.jgraph.graph.EdgeView;
-import org.jgraph.graph.GraphConstants;
-import org.jgraph.graph.PortView;
+import jmt.gui.common.JMTImageLoader;
+import jmt.gui.jsimgraph.controller.Mediator;
+import org.jgraph.graph.*;
 
+import javax.swing.*;
+
+
 /**
 
  * @author Federico Granata
@@ -38,9 +40,58 @@
 
  * Heavily modified by Bertoli Marco to support JGraph 5.8 - 21/mar/2006
  * Heavily modified by De Cicco Giuseppe & Fabio Granara to new JmtRouting - 23/sett/2006
+ * Heavily modified by Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio for supporting multiple incoming/outgoing edges for the same component - 30/Jan/2017
  */
 public class JmtRouting implements Edge.Routing {
 
+	// Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+	Mediator mediator;
+
+	// Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+	/*
+	 * Class that represents an interval between two numbers.
+	 */
+	class Interval {
+		private double lower;
+		private double upper;
+
+		public Interval(double b1, double b2) {
+			lower = b1 <= b2 ? b1 : b2;
+			upper = b1 <= b2 ? b2 : b1;
+		}
+
+		/**
+		 * Checks if a value is contained in this interval
+		 * @param p The value to test
+		 * @return True if the value is contained
+		 */
+		public boolean contains(double p) {
+			return p >= lower && p <= upper;
+		}
+	}
+
+	// Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+	// User-defined predicate to apply on a generic element
+	interface Predicate<T> {
+		boolean evaluate(T v);
+	}
+
+	// Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+	// Partitions a list into two sublists, one containing the elements that satisfy a given predicate and another list with the rest of the elements.
+	static <T> Map<Boolean, List<T>> partition(Predicate<T> predicate, List<T> collection) {
+		Map<Boolean, List<T>> result = new HashMap<>();
+		try {
+			result.put(true, collection.getClass().getConstructor().newInstance());
+			result.put(false, collection.getClass().getConstructor().newInstance());
+			for (T v: collection) {
+				result.get(predicate.evaluate(v)).add(v);
+			}
+		} catch (InstantiationException | IllegalAccessException | InvocationTargetException | NoSuchMethodException e) {
+			e.printStackTrace();
+		}
+		return result;
+	}
+
 	private static final long serialVersionUID = 1L;
 	private int offset = 15; //offset per il source
 	private int offsetTo2 = -15; //offset per il target
@@ -58,27 +109,27 @@
 			to = ((PortView) trg).getLocation();
 		}
 
+		JmtEdge edge = (JmtEdge) edgeView.getCell();//qua era defaultEdge l ho cambiato
+		JmtCell source = (JmtCell) ((DefaultPort) edge.getSource()).getParent();
+		JmtCell target = (JmtCell) ((DefaultPort) edge.getTarget()).getParent();
+
 		if (from != null && to != null) {
-			JmtEdge edge = (JmtEdge) edgeView.getCell();//qua era defaultEdge l ho cambiato
-			JmtCell source = (JmtCell) ((DefaultPort) edge.getSource()).getParent();
-			JmtCell target = (JmtCell) ((DefaultPort) edge.getTarget()).getParent();
-
 			Point2D[] routed;
 			int offset = this.offset;
-			int changeoff = edge.getOffset();
+//			int changeoff = edge.getOffset();
 
 			int offsetTo2 = this.offsetTo2;
 			//int ringOffset=8;
-			Rectangle2D sourceBounds = (Rectangle2D) source.getAttributes().get("bounds");
-			Rectangle2D targetBounds = (Rectangle2D) target.getAttributes().get("bounds");
+			final Rectangle2D sourceBounds = (Rectangle2D) source.getAttributes().get("bounds");
+			final Rectangle2D targetBounds = (Rectangle2D) target.getAttributes().get("bounds");
 
 			//System.out.println("Punto del from: "+ from.getX()+", punto del bound: "+sourceBounds.getMaxX());
 			int boundFrom = (int) (sourceBounds.getCenterX() + (sourceBounds.getWidth() / 2));
 			int boundTo = (int) (targetBounds.getCenterX() - (targetBounds.getWidth() / 2));
-			if (changeoff > 0 && source.isLeftInputCell()) {
+/*			if (changeoff > 0 && source.isLeftInputCell()) {
 				//System.out.println(changeoff);
 				offset = changeoff + 15;
-			}
+			}*/
 			if (!source.isLeftInputCell()) {
 				offset = -offset;
 				//ringOffset=-ringOffset;
@@ -99,9 +150,11 @@
 				routed[1] = new Point2D.Double(routed[0].getX(), targetBounds.getMaxY() + 12);
 				routed[2] = new Point2D.Double(boundTo - (offset), routed[1].getY());
 				routed[3] = new Point2D.Double(routed[2].getX(), routed[0].getY());
+				edge.setType(JmtEdge.Type.RING);
 
 			} else {
 				//the source is on the left of the target
+				edge.setType(JmtEdge.Type.LEFT_TO_RIGHT);
 				if ((int) from.getY() == (int) to.getY()
 						&& ((boundFrom < boundTo && offset > 0 && offsetTo2 < 0) || (boundFrom > boundTo && offset < 0 && offsetTo2 > 0))) {
 					list.add(from);
@@ -110,10 +163,10 @@
 				}
 				if ((((boundTo - boundFrom) > offset * (1.1)) && (offset > 0 && offsetTo2 < 0))
 						|| (((boundFrom - boundTo) > (-offset * (1.1))) && (offset < 0 && offsetTo2 > 0))) {
+
 					routed = new Point2D[2];
 					routed[0] = new Point2D.Double(boundFrom + offset, from.getY());
 					routed[1] = new Point2D.Double(routed[0].getX(), to.getY());
-
 				}
 				//____________inizio
 				else if ((offset < 0 && offsetTo2 < 0)) {
@@ -187,15 +240,80 @@
 					}
 				} else {
 
-					if ((from.getY() + sourceBounds.getHeight() - 4) < (to.getY() - (targetBounds.getHeight() / 2))) {
+					//if ((from.getY() + sourceBounds.getHeight() - 4)) < (to.getY() - targetBounds.getHeight() / 2))) {
+					if (sourceBounds.getMaxY() < targetBounds.getMinY()) {
+						// Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+						// this code is similar to the else case that was already present, with suitable changes.
+						// edge going from right to left circumventing the model on the upper side
+						edge.setType(JmtEdge.Type.LOOP_BACK_UPPER);
 						routed = new Point2D[4];
 						routed[0] = new Point2D.Double(boundFrom + offset, from.getY());
 						routed[3] = new Point2D.Double(boundTo + (offsetTo2), to.getY());
-						double maxY = sourceBounds.getMaxY() + 20;
-						routed[1] = new Point2D.Double(routed[0].getX(), maxY);
-						routed[2] = new Point2D.Double(routed[3].getX(), maxY);
+						//double maxY = sourceBounds.getMaxY() + 20;
+
+						// Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+						// Compute the y coordinate of the loop back edge taking into account other edges of the same type,
+						// in order to avoid overlapping lines.
+						List<OutputPort> outPorts = new ArrayList<>();
+						Enumeration ports = source.children();
+
+						while (ports.hasMoreElements()) {
+							Object port = ports.nextElement();
+							if (port instanceof OutputPort) {
+								outPorts.add((OutputPort) port);
+							}
+						}
+
+						double minY;
+						if (outPorts.size() > 1) {
+							Map<Boolean, List<OutputPort>> parts = partition(new Predicate<OutputPort>() {
+								@Override
+								public boolean evaluate(OutputPort v) {
+									JmtEdge e = (JmtEdge) (v.getEdges().iterator().next());
+									JmtCell thisTarget = (JmtCell) ((InputPort) e.getTarget()).getParent();
+									Rectangle2D thisTargetBounds = (Rectangle2D) thisTarget.getAttributes().get("bounds");
+									return thisTargetBounds.getX() > targetBounds.getX() && thisTargetBounds.getX() < sourceBounds.getX();
+								}
+							}, outPorts);
+							minY = Math.min(sourceBounds.getMinY() - 30 * (parts.get(true).size() + 1), targetBounds.getMinY() - 30);
+						} else {
+							minY = Math.min(sourceBounds.getMinY() - 30, targetBounds.getMinY() - 36);
+						}
+
+						routed[1] = new Point2D.Double(routed[0].getX(), minY);
+						routed[2] = new Point2D.Double(routed[3].getX(), minY);
+						if (offset > 0) {
+							double x;
+							double left = sourceBounds.getX() - offset - 4;
+							x = Math.min(routed[2].getX(), left);
+							routed[2].setLocation(x, routed[2].getY());
+							routed[3].setLocation(x, routed[3].getY());
+
+							if (from.getY() < to.getY()) {
+								double x2;
+								double right = targetBounds.getX() + targetBounds.getWidth() + offset;
+								x2 = Math.max(routed[0].getX(), right);
+								routed[0].setLocation(x2, routed[0].getY());
+								routed[1].setLocation(x2, routed[1].getY());
+							}
+						} else {
+							double x;
+							double left = sourceBounds.getX() + sourceBounds.getWidth() + offset + 4;
+							x = Math.max(routed[2].getX(), left);
+							routed[2].setLocation(x, routed[2].getY());
+							routed[3].setLocation(x, routed[3].getY());
+
+							if (from.getY() < to.getY()) {
+								double x2;
+								double left2 = targetBounds.getX() - offset;
+								x2 = Math.min(routed[0].getX(), left2);
+								routed[0].setLocation(x2, routed[0].getY());
+								routed[1].setLocation(x2, routed[1].getY());
+							}
+						}
 					} else {
-
+						// edge going from right to left circumventing the model on the lower side
+						edge.setType(JmtEdge.Type.LOOP_BACK_LOWER);
 						routed = new Point2D[4];
 						routed[0] = new Point2D.Double(boundFrom + offset, from.getY());
 						//System.out.println("Differenza "+ (sourceBounds.getMaxY()-(routed[0].getY() + sourceBounds.getBounds().getHeight()+2)));
@@ -202,7 +320,36 @@
 						routed[3] = new Point2D.Double(boundTo + offsetTo2, to.getY());
 						//double maxY = Math.max(routed[0].getY() + sourceBounds.getBounds().getHeight()+2,
 						//		routed[3].getY() + targetBounds.getBounds().getHeight()+8);
-						double maxY = Math.max(sourceBounds.getMaxY() + 20, targetBounds.getMaxY() + 26);
+
+						// Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+						// Compute the y coordinate of the loop back edge taking into account other edges of the same type,
+						// in order to avoid overlapping lines.
+						List<OutputPort> outPorts = new ArrayList<>();
+						Enumeration ports = source.children();
+
+						while (ports.hasMoreElements()) {
+							Object port = ports.nextElement();
+							if (port instanceof OutputPort) {
+								outPorts.add((OutputPort) port);
+							}
+						}
+
+						double maxY;
+						if (outPorts.size() > 1) {
+							Map<Boolean, List<OutputPort>> parts = partition(new Predicate<OutputPort>() {
+								@Override
+								public boolean evaluate(OutputPort v) {
+									JmtEdge e = (JmtEdge) (v.getEdges().iterator().next());
+									JmtCell thisTarget = (JmtCell) ((InputPort) e.getTarget()).getParent();
+									Rectangle2D thisTargetBounds = (Rectangle2D) thisTarget.getAttributes().get("bounds");
+									return thisTargetBounds.getX() > targetBounds.getX() && thisTargetBounds.getX() < sourceBounds.getX();
+								}
+							}, outPorts);
+							maxY = Math.max(sourceBounds.getMaxY() + 20 * (parts.get(true).size() + 1), targetBounds.getMaxY() + 26);
+						} else {
+							maxY = Math.max(sourceBounds.getMaxY() + 20, targetBounds.getMaxY() + 26);
+						}
+
 						routed[1] = new Point2D.Double(routed[0].getX(), maxY);
 						routed[2] = new Point2D.Double(routed[3].getX(), maxY);
 
@@ -238,18 +385,467 @@
 					}
 				}
 			}
+
+			// Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+			// Adjust outport ports and this edge offsets w.r.t. component's border based on specific criteria
+			double startY = from.getY();
+			{
+				Icon i = JMTImageLoader.loadImage(source.getIcon());
+				Dimension d = source.getSize(mediator.getGraph());
+				// Handle multiple outgoing edges from the same JmtCell
+				Dimension sourceSize = (Dimension) source.getAttributes().get("size");
+
+				List<OutputPort> outPorts = new ArrayList<>();
+				Enumeration ports = source.children();
+
+				while (ports.hasMoreElements()) {
+					Object port = ports.nextElement();
+					if (port instanceof OutputPort) {
+						outPorts.add((OutputPort) port);
+					}
+				}
+
+				// Calculate space between ports/edges based on #number of outgoing edges + 1
+				double division = Math.floor(sourceSize.getHeight() / (source.numOutEdges() + 1.0));
+				double divisionOffset = Math.floor(source.getOutPortoffset(i, d).getY() * 2 / (source.numOutEdges() + 1.0));
+
+				// The whole list is partitioned in three sub lists one for each type of edge
+				// For each sublist a different order criteria is applied.
+				Map<Boolean, List<OutputPort>> parts = partition(new Predicate<OutputPort>() {
+					@Override
+					public boolean evaluate(OutputPort v) {
+						if (v.getEdges().size() > 0) {
+							JmtEdge e = (JmtEdge) (v.getEdges().iterator().next());
+							return e.getType() == JmtEdge.Type.LOOP_BACK_UPPER;
+						}
+						return false;
+					}
+				}, outPorts);
+
+				List<OutputPort> portsLoopBackUpper = parts.get(true);
+
+				// The more the port has lower y offset the more the destination component is near the source one.
+				Collections.sort(portsLoopBackUpper, new Comparator<OutputPort>() {
+					@Override
+					public int compare(OutputPort o1, OutputPort o2) {
+						JmtEdge e1 = (JmtEdge) (o1.getEdges().iterator().next());
+						JmtEdge e2 = (JmtEdge) (o2.getEdges().iterator().next());
+
+						JmtCell c1 = (JmtCell) ((InputPort) e1.getTarget()).getParent();
+						JmtCell c2 = (JmtCell) ((InputPort) e2.getTarget()).getParent();
+
+						return (int) Math.ceil(((Rectangle2D) c2.getAttributes().get("bounds")).getMaxX() - ((Rectangle2D) c1.getAttributes().get("bounds")).getMaxX());
+					}
+				});
+
+				parts = partition(new Predicate<OutputPort>() {
+					@Override
+					public boolean evaluate(OutputPort v) {
+						if (v.getEdges().size() > 0) {
+							JmtEdge e = (JmtEdge) (v.getEdges().iterator().next());
+							return e.getType() == JmtEdge.Type.LEFT_TO_RIGHT;
+						}
+						return false;
+					}
+				}, parts.get(false));
+
+				List<OutputPort> portsLeftToRight = parts.get(true);
+
+				// The more the port has lower y offset, the more the destination component has lower y coordinate.
+				Collections.sort(portsLeftToRight, new Comparator<OutputPort>() {
+					@Override
+					public int compare(OutputPort o1, OutputPort o2) {
+						JmtEdge e1 = (JmtEdge) (o1.getEdges().iterator().next());
+						JmtEdge e2 = (JmtEdge) (o2.getEdges().iterator().next());
+
+						JmtCell c1 = (JmtCell) ((InputPort) e1.getTarget()).getParent();
+						JmtCell c2 = (JmtCell) ((InputPort) e2.getTarget()).getParent();
+
+						return (int) Math.ceil(((Rectangle2D) c1.getAttributes().get("bounds")).getMaxY() - ((Rectangle2D) c2.getAttributes().get("bounds")).getMaxY());
+					}
+				});
+
+				parts = partition(new Predicate<OutputPort>() {
+					@Override
+					public boolean evaluate(OutputPort v) {
+						if (v.getEdges().size() > 0) {
+							JmtEdge e = (JmtEdge) (v.getEdges().iterator().next());
+							return e.getType() == JmtEdge.Type.LOOP_BACK_LOWER;
+						}
+						return false;
+					}
+				}, parts.get(false));
+
+
+				List<OutputPort> portsLoopBackLower = parts.get(true);
+
+				// The more the porr has greater y offset the more the destination component is near the source one.
+				Collections.sort(portsLoopBackLower, new Comparator<OutputPort>() {
+					@Override
+					public int compare(OutputPort o1, OutputPort o2) {
+						JmtEdge e1 = (JmtEdge) (o1.getEdges().iterator().next());
+						JmtEdge e2 = (JmtEdge) (o2.getEdges().iterator().next());
+
+						JmtCell c1 = (JmtCell) ((InputPort) e1.getTarget()).getParent();
+						JmtCell c2 = (JmtCell) ((InputPort) e2.getTarget()).getParent();
+
+						return (int) Math.ceil(((Rectangle2D) c1.getAttributes().get("bounds")).getMaxX() - ((Rectangle2D) c2.getAttributes().get("bounds")).getMaxX());
+					}
+				});
+
+				parts = partition(new Predicate<OutputPort>() {
+					@Override
+					public boolean evaluate(OutputPort v) {
+						if (v.getEdges().size() > 0) {
+							JmtEdge e = (JmtEdge) (v.getEdges().iterator().next());
+							return e.getType() == JmtEdge.Type.RING;
+						}
+						return false;
+					}
+				}, parts.get(false));
+				List<OutputPort> portsRing = parts.get(true);
+
+				// Rebuild the outport list in this exact order, so to minimize intersections between outgoing edges.
+				outPorts.clear();
+				outPorts.addAll(portsLoopBackUpper);
+				outPorts.addAll(portsLeftToRight);
+				outPorts.addAll(portsLoopBackLower);
+				outPorts.addAll(portsRing);
+
+				for (int index = 0; index < outPorts.size(); index++) {
+					OutputPort outPort = outPorts.get(index);
+					JmtEdge outEdge = (JmtEdge) (outPort.getEdges().iterator().next());
+					JmtCell targetO = (JmtCell) ((InputPort) outEdge.getTarget()).getParent();
+					if (targetO == target) {
+						// We have found the index in the outport array for this edge, adjusts its offset.
+						startY = sourceBounds.getMinY() + (division * (index + 1));
+						routed[0].setLocation(routed[0].getX(), startY);
+					}
+
+					// If the component is rotated, the x offset must be changed accordingly.
+					Point2D portOffset = source.isLeftInputCell() ? source.getOutPortoffset(i, d) : source.getInPortOffset(i, d);
+					// Adjust offset of each port, if the attribute doesn't exist, create a new one.
+					if (outPort.getAttributes().get("offset") != null) {
+						((Point2D.Double) outPort.getAttributes().get("offset")).setLocation(portOffset.getX(), divisionOffset * (index + 1));
+					} else {
+						outPort.getAttributes().put("offset", new Point2D.Double(portOffset.getX(), divisionOffset * (index + 1)));
+					}
+				}
+
+				if (outPorts.size() > 1) {
+					// check if other edges that start from the same source component overlap this edge along their way
+					boolean needRecompute = true;
+					while (needRecompute) {
+						needRecompute = false;
+						for (int index = 0; index < outPorts.size(); index++) {
+							OutputPort outPort = outPorts.get(index);
+							// handle corner cases
+							if (outPort.getEdges().size() == 0) {
+								continue;
+							}
+
+							// we have found the same edge that we are routing
+							JmtEdge otherEdge = (JmtEdge) outPort.getEdges().iterator().next();
+							if (((DefaultPort) otherEdge.getSource()).getParent() == source && ((DefaultPort)otherEdge.getTarget()).getParent() == target) {
+								continue;
+							}
+
+							// Check this other edge with the one that we are routing by iterating over their (routed) points
+							List<Point2D> otherPoints = otherEdge.getRoutedPoints();
+							for (int ir = 0; ir < (routed.length - 1); ir++) {
+								int dir;
+								if (routed[ir].getY() == routed[ir + 1].getY()) {
+									dir = 1; // Horizontal direction
+								} else {
+									dir = 2; // Vertical direction
+								}
+								for (int io = 0; io < (otherPoints.size() - 1); io++) {
+									if (dir == 1 && (otherPoints.get(io).getY() == otherPoints.get(io + 1).getY() && (otherPoints.get(io).getY() == routed[ir].getY()))) {
+										// This segments have same directions, let's check if one (or both) point is contained over the routed segment
+										Interval interval = new Interval(routed[ir].getX(), routed[ir + 1].getX());
+										if (interval.contains(otherPoints.get(io).getX()) || interval.contains(otherPoints.get(io + 1).getX())) {
+											// There's overlap, change x coordinate by some amount, we have to discriminate between loop back edges and left-to-right edges.
+											int sign;
+											if (ir > 1 && target.isLeftInputCell()) {
+												sign = -1;
+											} else if (ir > 1 && !target.isLeftInputCell()) {
+												sign = 1;
+											} else if (target.isLeftInputCell()) {
+												sign = 1;
+											} else {
+												sign = -1;
+											}
+
+											routed[ir].setLocation(routed[ir].getX(), routed[ir].getY() + sign * offset);
+											routed[ir + 1].setLocation(routed[ir + 1].getX(), routed[ir + 1].getY() + sign * offset);
+											// We have modified some coordinates, we have to recheck that all the edges don't overlap again
+											needRecompute = true;
+										}
+									} else if (dir == 2 && (otherPoints.get(io).getX() == otherPoints.get(io + 1).getX() && (otherPoints.get(io).getX() == routed[ir].getX()))) {
+										Interval interval = new Interval(routed[ir].getY(), routed[ir + 1].getY());
+										if (interval.contains(otherPoints.get(io).getY()) || interval.contains(otherPoints.get(io + 1).getY())) {
+											int sign;
+											if (ir > 1 && target.isLeftInputCell()) {
+												sign = -1;
+											} else if (ir > 1 && !target.isLeftInputCell()) {
+												sign = 1;
+											} else if (target.isLeftInputCell()) {
+												sign = 1;
+											} else {
+												sign = -1;
+											}
+
+											routed[ir].setLocation(routed[ir].getX() + sign * offset, routed[ir].getY());
+											routed[ir + 1].setLocation(routed[ir + 1].getX() + sign * offset, routed[ir + 1].getY());
+											needRecompute = true;
+										}
+									}
+								}
+							}
+						}
+					}
+				}
+ 			}
+
+			// Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+			// Adjust input ports and this edge offsets w.r.t. component's border based on specific criteria
+			// This is the dual case of the previous one, except for the fact that here we are handling incoming edges and input ports.
+			double finalY = to.getY();
+			{
+				Icon i = JMTImageLoader.loadImage(target.getIcon());
+				Dimension d = target.getSize(mediator.getGraph());
+				// Handle multiple incoming edges to the same JmtCell
+				Dimension targetSize = (Dimension) target.getAttributes().get("size");
+
+				List<InputPort> inPorts = new ArrayList<>();
+				Enumeration ports = target.children();
+
+				while (ports.hasMoreElements()) {
+					Object port = ports.nextElement();
+					if (port instanceof InputPort) {
+						inPorts.add((InputPort) port);
+					}
+				}
+
+				double division = Math.floor(targetSize.getHeight() / (target.numInEdges() + 1.0));
+				double divisionOffset = Math.floor(target.getInPortOffset(i, d).getY() * 2 / (target.numInEdges() + 1.0));
+
+				Map<Boolean, List<InputPort>> parts = partition(new Predicate<InputPort>() {
+					@Override
+					public boolean evaluate(InputPort v) {
+						if (v.getEdges().size() > 0) {
+							JmtEdge e = (JmtEdge) (v.getEdges().iterator().next());
+							return e.getType() == JmtEdge.Type.LOOP_BACK_UPPER;
+						}
+						return false;
+					}
+				}, inPorts);
+
+				List<InputPort> portsLoopBackUpper = parts.get(true);
+
+				Collections.sort(portsLoopBackUpper, new Comparator<InputPort>() {
+					@Override
+					public int compare(InputPort o1, InputPort o2) {
+						JmtEdge e1 = (JmtEdge) (o1.getEdges().iterator().next());
+						JmtEdge e2 = (JmtEdge) (o2.getEdges().iterator().next());
+
+						JmtCell c1 = (JmtCell) ((OutputPort) e1.getSource()).getParent();
+						JmtCell c2 = (JmtCell) ((OutputPort) e2.getSource()).getParent();
+
+						return (int) Math.ceil(((Rectangle2D) c2.getAttributes().get("bounds")).getMaxY() - ((Rectangle2D) c1.getAttributes().get("bounds")).getMaxY());
+					}
+				});
+
+
+				parts = partition(new Predicate<InputPort>() {
+					@Override
+					public boolean evaluate(InputPort v) {
+						if (v.getEdges().size() > 0) {
+							JmtEdge e = (JmtEdge) (v.getEdges().iterator().next());
+							return e.getType() == JmtEdge.Type.LEFT_TO_RIGHT;
+						}
+						return false;
+					}
+				}, parts.get(false));
+
+				List<InputPort> portsLeftToRight = parts.get(true);
+
+				Collections.sort(portsLeftToRight, new Comparator<InputPort>() {
+					@Override
+					public int compare(InputPort o1, InputPort o2) {
+						JmtEdge e1 = (JmtEdge) (o1.getEdges().iterator().next());
+						JmtEdge e2 = (JmtEdge) (o2.getEdges().iterator().next());
+
+						JmtCell c1 = (JmtCell) ((OutputPort) e1.getSource()).getParent();
+						JmtCell c2 = (JmtCell) ((OutputPort) e2.getSource()).getParent();
+
+						return (int) Math.ceil(((Rectangle2D) c1.getAttributes().get("bounds")).getMaxY() - ((Rectangle2D) c2.getAttributes().get("bounds")).getMaxY());
+					}
+				});
+
+				parts = partition(new Predicate<InputPort>() {
+					@Override
+					public boolean evaluate(InputPort v) {
+						if (v.getEdges().size() > 0) {
+							JmtEdge e = (JmtEdge) (v.getEdges().iterator().next());
+							return e.getType() == JmtEdge.Type.LOOP_BACK_LOWER;
+						}
+						return false;
+					}
+				}, parts.get(false));
+
+				List<InputPort> portsLoopBackLower = parts.get(true);
+
+				Collections.sort(portsLoopBackLower, new Comparator<InputPort>() {
+					@Override
+					public int compare(InputPort o1, InputPort o2) {
+						JmtEdge e1 = (JmtEdge) (o1.getEdges().iterator().next());
+						JmtEdge e2 = (JmtEdge) (o2.getEdges().iterator().next());
+
+						JmtCell c1 = (JmtCell) ((OutputPort) e1.getSource()).getParent();
+						JmtCell c2 = (JmtCell) ((OutputPort) e2.getSource()).getParent();
+
+						return (int) Math.ceil(((Rectangle2D) c2.getAttributes().get("bounds")).getMaxY() - ((Rectangle2D) c1.getAttributes().get("bounds")).getMaxY());
+					}
+				});
+
+				parts = partition(new Predicate<InputPort>() {
+					@Override
+					public boolean evaluate(InputPort v) {
+						if (v.getEdges().size() > 0) {
+							JmtEdge e = (JmtEdge) (v.getEdges().iterator().next());
+							return e.getType() == JmtEdge.Type.RING;
+						}
+						return false;
+					}
+				}, parts.get(false));
+
+				List<InputPort> portsRing = parts.get(true);
+
+				inPorts.clear();
+				inPorts.addAll(portsLoopBackUpper);
+				inPorts.addAll(portsLeftToRight);
+				inPorts.addAll(portsLoopBackLower);
+				inPorts.addAll(portsRing);
+
+				for (int index = 0; index < inPorts.size(); index++) {
+					InputPort inPort = inPorts.get(index);
+					JmtEdge inEdge = (JmtEdge) (inPort.getEdges().iterator().next());
+					JmtCell sourceI = (JmtCell) ((OutputPort) inEdge.getSource()).getParent();
+					if (sourceI == source) {
+						finalY = targetBounds.getMinY() + (division * (index + 1));
+						routed[routed.length - 1] = new Point2D.Double(routed[routed.length - 1].getX(), finalY);
+					}
+
+					Point2D portOffset = target.isLeftInputCell() ? target.getInPortOffset(i, d) : target.getOutPortoffset(i, d);
+					if (inPort.getAttributes().get("offset") != null) {
+						((Point2D.Double) inPort.getAttributes().get("offset")).setLocation(portOffset.getX(), divisionOffset * (index + 1));
+					} else {
+						inPort.getAttributes().put("offset", new Point2D.Double(portOffset.getX(), divisionOffset * (index + 1)));
+					}
+				}
+
+				if (inPorts.size() > 1) {
+					boolean needRecompute = true;
+					while (needRecompute) {
+						needRecompute = false;
+						for (int index = 0; index < inPorts.size(); index++) {
+							InputPort inPort = inPorts.get(index);
+							if (inPort.getEdges().size() == 0) {
+								continue;
+							}
+							JmtEdge otherEdge = (JmtEdge) inPort.getEdges().iterator().next();
+							if (((DefaultPort) otherEdge.getSource()).getParent() == source && ((DefaultPort)otherEdge.getTarget()).getParent() == target) {
+								continue;
+							}
+
+							List<Point2D> otherPoints = otherEdge.getRoutedPoints();
+							for (int ir = 0; ir < (routed.length - 1); ir++) {
+								int dir;
+								if (routed[ir].getY() == routed[ir + 1].getY()) {
+									dir = 1;
+								} else {
+									dir = 2;
+								}
+								for (int io = 0; io < (otherPoints.size() - 1); io++) {
+									if (dir == 1 && (otherPoints.get(io).getY() == otherPoints.get(io + 1).getY() && (otherPoints.get(io).getY() == routed[ir].getY()))) {
+										Interval interval = new Interval(routed[ir].getX(), routed[ir + 1].getX());
+										if (interval.contains(otherPoints.get(io).getX()) || interval.contains(otherPoints.get(io + 1).getX())) {
+											int sign;
+											if (ir > 1 && target.isLeftInputCell()) {
+												sign = -1;
+											} else if (ir > 1 && !target.isLeftInputCell()) {
+												sign = 1;
+											} else if (target.isLeftInputCell()) {
+												sign = 1;
+											} else {
+												sign = -1;
+											}
+											routed[ir].setLocation(routed[ir].getX(), routed[ir].getY() + sign * offset);
+											routed[ir + 1].setLocation(routed[ir + 1].getX(), routed[ir + 1].getY() + sign *offset);
+											needRecompute = true;
+										}
+									} else if (dir == 2 && (otherPoints.get(io).getX() == otherPoints.get(io + 1).getX() && (otherPoints.get(io).getX() == routed[ir].getX()))) {
+										Interval interval = new Interval(routed[ir].getY(), routed[ir + 1].getY());
+										if (interval.contains(otherPoints.get(io).getY()) || interval.contains(otherPoints.get(io + 1).getY())) {
+											int sign;
+											if (ir > 1 && target.isLeftInputCell()) {
+												sign = -1;
+											} else if (ir > 1 && !target.isLeftInputCell()) {
+												sign = 1;
+											} else if (target.isLeftInputCell()) {
+												sign = 1;
+											} else {
+												sign = -1;
+											}
+											routed[ir].setLocation(routed[ir].getX() + sign * offset, routed[ir].getY());
+											routed[ir + 1].setLocation(routed[ir + 1].getX() + sign * offset, routed[ir + 1].getY());
+											needRecompute = true;
+										}
+									}
+								}
+							}
+						}
+					}
+				}
+			}
+
+			// Handles compenetration of edges
+			if (target.isLeftInputCell() && (routed[routed.length - 1].getX() > (targetBounds.getMinX() - offset)) && (Math.abs(from.getY() - to.getY()) >= targetBounds.getHeight() / 2) && routed.length > 1 && routed[routed.length - 1] != null && routed[routed.length - 2] != null) {
+				routed[routed.length - 1].setLocation(routed[routed.length - 1].getX() - 2 * Math.max(offset, routed[routed.length - 1].getX() - targetBounds.getMinX()), routed[routed.length - 1].getY());
+
+				Point2D newRouted[] = new Point2D[routed.length + 2];
+				System.arraycopy(routed, 0, newRouted, 0, routed.length - 1);
+				double diffY = Math.abs(routed[routed.length - 2].getY() - routed[routed.length - 1].getY()) * 0.5;
+				if (routed[routed.length - 1].getY() > routed[routed.length - 2].getY()) {
+					// edge is going down
+					newRouted[routed.length - 1] = new Point2D.Double(routed[routed.length - 2].getX(), routed[routed.length - 2].getY() + diffY);
+					newRouted[routed.length] = new Point2D.Double(routed[routed.length - 1].getX(), routed[routed.length - 2].getY() + diffY);
+				} else {
+					newRouted[routed.length - 1] = new Point2D.Double(routed[routed.length - 2].getX(), routed[routed.length - 2].getY() - diffY);
+					newRouted[routed.length] = new Point2D.Double(routed[routed.length - 1].getX(), routed[routed.length - 2].getY() - diffY);
+				}
+
+				newRouted[routed.length + 1] = routed[routed.length - 1];
+
+				routed = newRouted;
+
+			}
+
 			//Sets add points
-			list.add(from);
-			for (Point2D element : routed) {
-				list.add(element);
-			}
-			list.add(to);
+			list.add(new Point2D.Double(from.getX(), startY));
+			Collections.addAll(list, routed);
+			list.add(new Point2D.Double(to.getX(), finalY));
+			edge.setRoutedPoints(list);
 		}
 		return list;
 	}
 
+	public void setMediator(Mediator m) {
+		mediator = m;
+	}
+
 	public int getPreferredLineStyle(EdgeView edgeView) {
-
 		return GraphConstants.STYLE_ORTHOGONAL;
 	}
 
Index: src/main/java/jmt/gui/jsimgraph/JGraphMod/SemaphoreCell.java
===================================================================
--- src/main/java/jmt/gui/jsimgraph/JGraphMod/SemaphoreCell.java	(revision 978)
+++ src/main/java/jmt/gui/jsimgraph/JGraphMod/SemaphoreCell.java	(working copy)
@@ -62,6 +62,7 @@
 		ports[0] = new InputPort(this);
 		ports[1] = new OutputPort(this);
 		return ports;
+
 	}
 
 	/**
Index: src/main/java/jmt/gui/jsimgraph/controller/ConnectState.java
===================================================================
--- src/main/java/jmt/gui/jsimgraph/controller/ConnectState.java	(revision 978)
+++ src/main/java/jmt/gui/jsimgraph/controller/ConnectState.java	(working copy)
@@ -27,6 +27,7 @@
 
 import jmt.gui.jsimgraph.JGraphMod.JmtCell;
 
+import jmt.gui.jsimgraph.JGraphMod.OutputPort;
 import org.jgraph.graph.PortView;
 import org.jgraph.graph.VertexView;
 
@@ -64,7 +65,9 @@
 	public void handlePress(MouseEvent e) {
 		if (!e.isConsumed()) {
 			start = mediator.snap(e.getPoint());
-			firstPort = port = getOutPortViewAt(e.getX(), e.getY());
+			// Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+			// Request a (possibly new) free output port
+			firstPort = port = getFreeOutPortViewAt(e.getX(), e.getY());
 			if (firstPort != null) {
 				start = mediator.toScreen(firstPort.getLocation(null));
 			}
@@ -112,8 +115,10 @@
 	// Heavily modified by Giuseppe De Cicco & Fabio Granara
 	@Override
 	public void handleRelease(MouseEvent e) {
-		if (e != null && !e.isConsumed()) {
-			PortView end = getInPortViewAt(e.getX(), e.getY());
+		if (e != null && !e.isConsumed() && firstPort != null) {
+			// Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+			// Request a (possibly new) free input port
+			PortView end = getFreeInPortViewAt(e.getX(), e.getY());
 			if (end != null) {
 				mediator.connect(start, current, end, firstPort);
 				if ((firstPort != null) && ((VertexView) (firstPort.getParentView()) != null)) {
@@ -123,6 +128,11 @@
 					}
 				}
 				mediator.getGraph().getGraphLayoutCache().reload();
+			} else {
+				OutputPort outputPort = (OutputPort) firstPort.getCell();
+				JmtCell source = (JmtCell) outputPort.getParent();
+				source.SubOut();
+				source.remove(outputPort);
 			}
 			e.consume();
 			mediator.graphRepaint();
@@ -133,6 +143,17 @@
 		current = null;
 	}
 
+	// Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+	/** gets the first free portView of the input port of the cell at position
+	 *
+	 * @param x
+	 * @param y
+	 * @return portView of the input port
+	 */
+	private PortView getFreeInPortViewAt(int x, int y) {
+		return mediator.getFreeInPortViewAt(x, y);
+	}
+
 	/** gets the first portView of the input port of the cell at position
 	 *
 	 * @param x
@@ -153,6 +174,17 @@
 		return mediator.getOutPortViewAt(x, y);
 	}
 
+	// Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+	/** gets the first free portView of the output port of the cell at position
+	 *
+	 * @param x
+	 * @param y
+	 * @return portView of the output port
+	 */
+	protected PortView getFreeOutPortViewAt(int x, int y) {
+		return mediator.getFreeOutPortViewAt(x, y);
+	}
+
 	public void overlay(Graphics2D g) {
 		if (start != null && current != null) {
 			g.draw(new Line2D.Double(start.getX(), start.getY(), current.getX(), current.getY()));
Index: src/main/java/jmt/gui/jsimgraph/controller/JmtGraphUI.java
===================================================================
--- src/main/java/jmt/gui/jsimgraph/controller/JmtGraphUI.java	(revision 978)
+++ src/main/java/jmt/gui/jsimgraph/controller/JmtGraphUI.java	(working copy)
@@ -142,6 +142,7 @@
 				mediator.enableAddBlockingRegion(!cannotAddBlockingRegion);
 				mediator.enableRotateAction(true);
 				mediator.enableSetRight(true);
+				mediator.enableSnapToGrid(true);
 			} else if (foundBlockingRegion) {
 				mediator.enableCopyAction(true);
 				mediator.enableCutAction(true);
Index: src/main/java/jmt/gui/jsimgraph/controller/Mediator.java
===================================================================
--- src/main/java/jmt/gui/jsimgraph/controller/Mediator.java	(revision 978)
+++ src/main/java/jmt/gui/jsimgraph/controller/Mediator.java	(working copy)
@@ -32,20 +32,9 @@
 import java.awt.geom.Point2D;
 import java.awt.geom.Rectangle2D;
 import java.io.File;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.Hashtable;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-import java.util.Vector;
+import java.util.*;
 
-import javax.swing.ImageIcon;
-import javax.swing.JFrame;
-import javax.swing.JOptionPane;
+import javax.swing.*;
 
 import jmt.framework.gui.components.JMTMenuBar;
 import jmt.framework.gui.components.JMTToolBar;
@@ -54,6 +43,7 @@
 import jmt.gui.common.CommonConstants;
 import jmt.gui.common.Defaults;
 import jmt.gui.common.JMTImageLoader;
+import jmt.gui.common.MergedIcon;
 import jmt.gui.common.controller.DispatcherThread;
 import jmt.gui.common.controller.ModelChecker;
 import jmt.gui.common.controller.PADispatcherThread;
@@ -78,56 +68,8 @@
 import jmt.gui.common.xml.ModelLoader;
 import jmt.gui.common.xml.XMLWriter;
 import jmt.gui.jsimgraph.DialogFactory;
-import jmt.gui.jsimgraph.JGraphMod.BlockingRegion;
-import jmt.gui.jsimgraph.JGraphMod.CellComponent;
-import jmt.gui.jsimgraph.JGraphMod.CellFactory;
-import jmt.gui.jsimgraph.JGraphMod.InputPort;
-import jmt.gui.jsimgraph.JGraphMod.JmtCell;
-import jmt.gui.jsimgraph.JGraphMod.JmtDefaultCellViewFactory;
-import jmt.gui.jsimgraph.JGraphMod.JmtEdge;
-import jmt.gui.jsimgraph.JGraphMod.JmtEdgeView;
-import jmt.gui.jsimgraph.JGraphMod.JmtGraphConstants;
-import jmt.gui.jsimgraph.JGraphMod.JmtJGraph;
-import jmt.gui.jsimgraph.JGraphMod.JmtOverlapping;
-import jmt.gui.jsimgraph.JGraphMod.OutputPort;
-import jmt.gui.jsimgraph.JGraphMod.SinkCell;
-import jmt.gui.jsimgraph.JGraphMod.SourceCell;
-import jmt.gui.jsimgraph.controller.actions.About;
-import jmt.gui.jsimgraph.controller.actions.AbstractJmodelAction;
-import jmt.gui.jsimgraph.controller.actions.ActionCopy;
-import jmt.gui.jsimgraph.controller.actions.ActionCut;
-import jmt.gui.jsimgraph.controller.actions.ActionDelete;
-import jmt.gui.jsimgraph.controller.actions.ActionPaste;
-import jmt.gui.jsimgraph.controller.actions.ActionRedo;
-import jmt.gui.jsimgraph.controller.actions.ActionRotate;
-import jmt.gui.jsimgraph.controller.actions.ActionSetRight;
-import jmt.gui.jsimgraph.controller.actions.ActionUndo;
-import jmt.gui.jsimgraph.controller.actions.AddBlockingRegion;
-import jmt.gui.jsimgraph.controller.actions.CloseModel;
-import jmt.gui.jsimgraph.controller.actions.DownloadDefaultTemplates;
-import jmt.gui.jsimgraph.controller.actions.EditDefaults;
-import jmt.gui.jsimgraph.controller.actions.EditMeasures;
-import jmt.gui.jsimgraph.controller.actions.EditPAParams;
-import jmt.gui.jsimgraph.controller.actions.EditSimParams;
-import jmt.gui.jsimgraph.controller.actions.EditUserClasses;
-import jmt.gui.jsimgraph.controller.actions.Exit;
-import jmt.gui.jsimgraph.controller.actions.NewModel;
-import jmt.gui.jsimgraph.controller.actions.OpenHelp;
-import jmt.gui.jsimgraph.controller.actions.OpenModel;
-import jmt.gui.jsimgraph.controller.actions.PauseSimulation;
-import jmt.gui.jsimgraph.controller.actions.SaveModel;
-import jmt.gui.jsimgraph.controller.actions.SaveModelAs;
-import jmt.gui.jsimgraph.controller.actions.SetConnectState;
-import jmt.gui.jsimgraph.controller.actions.SetOptions;
-import jmt.gui.jsimgraph.controller.actions.SetSelectState;
-import jmt.gui.jsimgraph.controller.actions.ShowResults;
-import jmt.gui.jsimgraph.controller.actions.Simulate;
-import jmt.gui.jsimgraph.controller.actions.SolveAnalytic;
-import jmt.gui.jsimgraph.controller.actions.SolveApprox;
-import jmt.gui.jsimgraph.controller.actions.StopSimulation;
-import jmt.gui.jsimgraph.controller.actions.SwitchToExactSolver;
-import jmt.gui.jsimgraph.controller.actions.TakeScreenShot;
-import jmt.gui.jsimgraph.controller.actions.UseTemplate;
+import jmt.gui.jsimgraph.JGraphMod.*;
+import jmt.gui.jsimgraph.controller.actions.*;
 import jmt.gui.jsimgraph.definitions.JMTPoint;
 import jmt.gui.jsimgraph.definitions.JSimGraphModel;
 import jmt.gui.jsimgraph.definitions.JmodelClassDefinition;
@@ -147,7 +89,6 @@
 import org.jgraph.graph.CellView;
 import org.jgraph.graph.ConnectionSet;
 import org.jgraph.graph.DefaultGraphModel;
-import org.jgraph.graph.DefaultGraphModel.GraphModelEdit;
 import org.jgraph.graph.DefaultPort;
 import org.jgraph.graph.Edge;
 import org.jgraph.graph.EdgeView;
@@ -233,6 +174,8 @@
 	private AbstractJmodelAction takeScreenShot;
 	private AbstractJmodelAction actionRotate;
 	private AbstractJmodelAction actionSetRight;
+	// Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+	private AbstractJmodelAction actionSnapToGrid;
 	private AbstractJmodelAction editUndo;
 	private AbstractJmodelAction editRedo;
 
@@ -320,6 +263,7 @@
 		addBlockingRegion = new AddBlockingRegion(this);
 
 		actionSetRight = new ActionSetRight(this);
+		actionSnapToGrid = new SnapToGrid(this);
 		takeScreenShot = new TakeScreenShot(this);
 
 		actionRotate = new ActionRotate(this);
@@ -330,6 +274,9 @@
 		switchToExactSolver = new SwitchToExactSolver(this);
 		// Initialize new Component bar
 		componentBar = new ComponentBar(this);
+
+		// Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+		((JmtRouting)JmtGraphConstants.ROUTING_JMT).setMediator(this);
 	}
 
 	/**
@@ -415,6 +362,11 @@
 		addBlockingRegion.setEnabled(state);
 	}
 
+	// Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+	public void enableSnapToGrid(boolean state) {
+		actionSnapToGrid.setEnabled(state);
+	}
+
 	public void enableSetRight(boolean state) {
 		actionSetRight.setEnabled(state);
 	}
@@ -423,6 +375,11 @@
 		return actionSetRight;
 	}
 
+	// Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+	public AbstractJmodelAction getSnapToGrid() {
+		return actionSnapToGrid;
+	}
+
 	public AbstractJmodelAction getEditDefaults() {
 		return editDefaults;
 	}
@@ -689,6 +646,8 @@
 		setSelect.setEnabled(false);
 		actionRotate.setEnabled(false);
 		actionSetRight.setEnabled(false);
+		// Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+		actionSnapToGrid.setEnabled(false);
 
 		// Enable the action to perform editing user classes
 		editUserClasses.setEnabled(true);
@@ -781,6 +740,8 @@
 		actionDelete.setEnabled(false);
 		actionRotate.setEnabled(false);
 		actionSetRight.setEnabled(false);
+		// Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+		actionSnapToGrid.setEnabled(false);
 
 		setSelect.setEnabled(false);
 		simulate.setEnabled(false);
@@ -1017,7 +978,64 @@
 			// Visualizes connection only if it can be created into data structure
 			if (model.setConnected(sourceKey, targetKey, true)) {
 				graph.getModel().insert(insert, viewMap, cs, null, null);
+			} else {
+				// Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+				// duplicate connection
+				// remove the new ports created just before
+				InputPort inputPort = (InputPort) inPort.getCell();
+				JmtCell target = (JmtCell) inputPort.getParent();
+				if (target != null && target.numInEdges() > 1) {
+					target.SubIn();
+					target.remove(inputPort);
+				}
+
+				OutputPort outputPort = (OutputPort) outPort.getCell();
+				JmtCell source = (JmtCell) outputPort.getParent();
+				if (source != null && source.numOutEdges() > 1) {
+					source.SubOut();
+					source.remove(outputPort);
+				}
 			}
+
+			JmtCell target = (JmtCell) ((InputPort) inPort.getCell()).getParent();
+			if (target != null && target.getChildren().size() > 2) {
+				for(Object child : target.getChildren()) {
+					if (child instanceof InputPort && target.numInEdges() > 1) {
+						InputPort childInput = (InputPort) child;
+						if (childInput.getEdges().size() == 0) {
+							target.SubIn();
+							target.remove(childInput);
+						}
+					} else if (child instanceof OutputPort && target.numOutEdges() > 1) {
+						OutputPort childOutput = (OutputPort) child;
+						if (childOutput.getEdges().size() == 0) {
+							target.SubOut();
+							target.remove(childOutput);
+						}
+					}
+				}
+			}
+
+			JmtCell source = (JmtCell) ((OutputPort) outPort.getCell()).getParent();
+			if (source != null && source.getChildren().size() > 2) {
+				for(Object child : source.getChildren()) {
+					if (child instanceof InputPort) {
+						InputPort childInput = (InputPort) child;
+						if (childInput.getEdges().size() == 0 && source.numInEdges() > 1) {
+							source.SubIn();
+							System.out.println("Removing inport");
+							source.remove(childInput);
+						}
+					} else if (child instanceof OutputPort && source.numOutEdges() > 1) {
+						OutputPort childOutput = (OutputPort) child;
+						if (childOutput.getEdges().size() == 0) {
+							source.SubOut();
+							System.out.println("Removing outport");
+							source.remove(childOutput);
+						}
+					}
+				}
+			}
 		}
 	}
 
@@ -1062,7 +1080,8 @@
 		viewMap.put(connection, map);
 		Object[] insert = new Object[] { connection };
 		ConnectionSet cs = new ConnectionSet();
-		// Finds sourcePort
+		// Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+		// Finds free sourcePort
 		Iterator it;
 		it = source.getChildren().iterator();
 		DefaultPort tmpPort, sourcePort, targetPort;
@@ -1069,27 +1088,58 @@
 		sourcePort = null;
 		while (it.hasNext()) {
 			tmpPort = (DefaultPort) it.next();
-			if (tmpPort instanceof OutputPort) {
+			if (tmpPort instanceof OutputPort && tmpPort.getEdges().size() == 0) {
 				sourcePort = tmpPort;
 			}
 		}
-		// Finds targetPort
+
+		// Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+		// Otherwise create a new one
+		if (sourcePort == null) {
+			sourcePort = new OutputPort(source);
+			source.insert(sourcePort, source.getChildCount() - 1);
+			source.AddOut();
+			graph.getGraphLayoutCache().putMapping(sourcePort, new PortView(sourcePort));
+		}
+
+		// Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+		// Finds free targetPort
 		it = target.getChildren().iterator();
 		targetPort = null;
 		while (it.hasNext()) {
 			tmpPort = (DefaultPort) it.next();
-			if (tmpPort instanceof InputPort) {
+			if (tmpPort instanceof InputPort && tmpPort.getEdges().size() == 0) {
 				targetPort = tmpPort;
 			}
 		}
-		if (sourcePort != null && targetPort != null) {
-			cs.connect(connection, sourcePort, true);
-			cs.connect(connection, targetPort, false);
-			// Adds connection to the graph only if it can be created into data structure
-			if (model.setConnected(sourceKey, targetKey, true) || forced) {
-				graph.getModel().insert(insert, viewMap, cs, null, null);
-				return connection;
+
+		// Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+		// Otherwise create a new one
+		if (targetPort == null) {
+			targetPort = new InputPort(target);
+			target.insert(targetPort, target.getChildCount() - 1);
+			target.AddIn();
+			graph.getGraphLayoutCache().putMapping(targetPort, new PortView(targetPort));
+		}
+
+		cs.connect(connection, sourcePort, true);
+		cs.connect(connection, targetPort, false);
+		// Adds connection to the graph only if it can be created into data structure
+		if (model.setConnected(sourceKey, targetKey, true) || forced) {
+			graph.getModel().insert(insert, viewMap, cs, null, null);
+			return connection;
+		} else {
+			// Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+			// Add failed, remove ports if necessary
+			if (source.numOutEdges() > 1) {
+				source.SubOut();
+				source.remove(sourcePort);
 			}
+
+			if (target.numInEdges() > 1) {
+				target.SubIn();
+				target.remove(targetPort);
+			}
 		}
 		return null;
 	}
@@ -1122,8 +1172,22 @@
 	 */
 	public PortView getInPortViewAt(int x, int y) {
 		return (PortView) graph.getGraphLayoutCache().getMapping(graph.getInPortAt(x, y), false);
+
 	}
 
+	// Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+	/** gets the first free portView of the input port of the cell at position
+	 *
+	 * @param x
+	 * @param y
+	 * @return the portView of the input port
+	 */
+	public PortView getFreeInPortViewAt(int x, int y) {
+		InputPort p = graph.getFreeInPortAt(x, y);
+		return (PortView) graph.getGraphLayoutCache().getMapping(p, false);
+
+	}
+
 	/** gets the first portView of the output port of the cell at position
 	 *
 	 * @param x
@@ -1166,6 +1230,7 @@
 					((CellComponent) jcell.getUserObject()).getKey());
 			// Adds on the top a panel to change station name
 			stationPanel.add(new StationNamePanel(model, ((CellComponent) jcell.getUserObject()).getKey()), BorderLayout.NORTH);
+			boolean oldPinState = jcell.isPinned();
 			dialogFactory.getDialog(stationPanel, "Editing " + jcell.getUserObject().toString() + " Properties...");
 
 			// Updates cell dimensions if name was changed too much...
@@ -1179,7 +1244,25 @@
 				jcell.updatePortPositions(nest, GraphConstants.getIcon(attr), cellDimension);
 				graph.getGraphLayoutCache().edit(nest);
 			}
-		}
+
+			// Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+			// Change icon so to display a small lock indicating that this component is pinned
+			if (oldPinState != jcell.isPinned()) {
+				ImageIcon lockIcon = JMTImageLoader.loadImage("lock", new Dimension(16, 16));
+				Icon newIcon;
+				if (jcell.isPinned()) {
+					newIcon = new MergedIcon(JMTImageLoader.loadImage(jcell.getIcon()), lockIcon);
+				} else {
+					newIcon = JMTImageLoader.loadImage(jcell.getIcon());
+				}
+				GraphConstants.setIcon(jcell.getAttributes(), newIcon);
+				graph.getGraphLayoutCache().reload();
+				graphRepaint();
+				// Solves the "ghost lock" that could appears when dragging a component that was just unpinned.
+				graph.getSelectionModel().removeSelectionCell(jcell);
+				graph.getSelectionModel().setSelectionCell(jcell);
+			}
+ 		}
 		// Blocking region editing
 		else if ((cell != null) && (cell instanceof BlockingRegion)) {
 			Object regionKey = ((BlockingRegion) cell).getKey();
@@ -1290,11 +1373,33 @@
 
 		if (!edges.isEmpty()) {
 			// Removes edges from graph
+			List<Object> cellsList = java.util.Arrays.asList(cells);
+			for (Object e: edges) {
+				if (cellsList.indexOf(e) < 0) {
+					// Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+					// delete only unselected edges
+					JmtEdge link = (JmtEdge) e;
+					InputPort targetPort = (InputPort) link.getTarget();
+					JmtCell target = (JmtCell) targetPort.getParent();
+					if (target.numInEdges() > 1) {
+						// Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+						// avoid situation in which there are no InputPorts for target
+						target.SubIn();
+						target.remove(targetPort);
+					}
+
+					OutputPort sourcePort = (OutputPort) link.getSource();
+					JmtCell source = (JmtCell) sourcePort.getParent();
+					if (source.numOutEdges() > 1) {
+						// Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+						// avoid situation in which there are no OutputPorts for source
+						source.SubOut();
+						source.remove(sourcePort);
+					}
+				}
+			}
 			graphmodel.remove(edges.toArray());
 		}
-		// Removes cells from graph
-		graphmodel.remove(cells);
-
 		// Checks if all children of a blocking region have been removed
 		Iterator<Object> it = regions.iterator();
 		while (it.hasNext()) {
@@ -1333,10 +1438,34 @@
 				model.deleteStation(((CellComponent) ((JmtCell) cell).getUserObject()).getKey());
 			} else if (cell instanceof JmtEdge) {
 				JmtEdge link = (JmtEdge) cell;
+				InputPort targetPort = (InputPort) link.getTarget();
+				// Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+				if (targetPort != null) {
+					JmtCell target = (JmtCell) targetPort.getParent();
+					if (target.numInEdges() > 1) {
+						// avoid situation in which there are no InputPorts for target
+						target.SubIn();
+						target.remove(targetPort);
+					}
+				}
+
+				// Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+				OutputPort sourcePort = (OutputPort) link.getSource();
+				if (sourcePort != null) {
+					JmtCell source = (JmtCell) sourcePort.getParent();
+					if (source.numOutEdges() > 1) {
+						// avoid situation in which there are no OutputPorts for source
+						source.SubOut();
+						source.remove(sourcePort);
+					}
+				}
 				model.setConnected(link.getSourceKey(), link.getTargetKey(), false);
 			}
 		}
 
+		// Removes cells from graph
+		graphmodel.remove(cells);
+
 		// If no stations remains gray select and link buttons
 		if (graphmodel.getRootCount() == 0) {
 			componentBar.clearButtonGroupSelection(0);
@@ -1343,6 +1472,7 @@
 			setConnect.setEnabled(false);
 			setSelect.setEnabled(false);
 			actionSetRight.setEnabled(false);
+			actionSnapToGrid.setEnabled(false);
 		}
 
 		// Selects components from removed blocking regions
@@ -1504,9 +1634,23 @@
 		// whether the Position is Null, the application call the reposition's method
 		if (!containPosition) {
 			adjustGraph();
+		} else {
+			Object[] objCells = graph.getDescendants(graph.getRoots());
+			Integer[] Xmin = new Integer[objCells.length];
+			Integer[] Ymin = new Integer[objCells.length];
+			for(int i = 0; i < objCells.length; i++) {
+				if (objCells[i] instanceof JmtCell) {
+					Rectangle2D rett = GraphConstants.getBounds(((JmtCell) objCells[i]).getAttributes());
+					Xmin[i] = (int) rett.getMinX();
+					Ymin[i] = (int) rett.getMinY();
+				}
+			}
+			putSelectedCellsInGoodPlace(objCells, Xmin, Ymin);
+
 		}
 		graphRepaint();
 		graph.getGraphLayoutCache().reload();
+
 	}
 
 	/**
@@ -1676,7 +1820,7 @@
 							if (((JmtEdge) overlapping[j]).getSource() != cell.getChildAt(0)) {
 								ArrayList<Point2D> intersectionPoints = ((JmtEdge) overlapping[j]).getIntersectionVertexPoint();
 								Point2D tmp = (intersectionPoints.get(0));
-								Rectangle2D cellBound = GraphConstants.getBounds(((SourceCell) cell).getAttributes());
+								Rectangle2D cellBound = bounds; // GraphConstants.getBounds(((SourceCell) cell).getAttributes());
 								double vertexMaxX = (int) cellBound.getMaxX();
 								double vertexMaxY = (int) cellBound.getMaxY();
 								double vertexHeight = (int) cellBound.getHeight();
@@ -1690,11 +1834,19 @@
 									if ((int) tmp.getX() < valoreIntermedio) {
 										Point newPosition = (this.overlapping).findFreePosition(((JmtEdge) overlapping[j]), cell, cellBound, tmp,
 												false, false, true, false);
-										bounds.setLocation(newPosition);
+										if (newPosition.equals(bounds.getLocation())) {
+											bounds.setLocation(x, y);
+										} else {
+											bounds.setLocation(newPosition);
+										}
 									} else {
 										Point newPosition = (this.overlapping).findFreePosition(((JmtEdge) overlapping[j]), cell, cellBound, tmp,
 												false, false, false, true);
-										bounds.setLocation(newPosition);
+										if (newPosition.equals(bounds.getLocation())) {
+											bounds.setLocation(x, y);
+										} else {
+											bounds.setLocation(newPosition);
+										}
 									}
 								} else if (leftSideIntersaction && rightSideIntersaction) {
 									int valoreIntermedio = ((int) vertexMaxY - (int) (vertexHeight / 2));
@@ -1701,31 +1853,55 @@
 									if ((int) tmp.getY() < valoreIntermedio) {
 										Point newPosition = (this.overlapping).findFreePosition(((JmtEdge) overlapping[j]), cell, cellBound, tmp,
 												false, true, false, false);
-										Point newPosition2 = new Point(newPosition.x, newPosition.y + sp);
-										bounds.setLocation(newPosition2);
-										sp = sp + 2;
+										if (newPosition.equals(bounds.getLocation())) {
+											bounds.setLocation(x, y);
+										} else {
+											Point newPosition2 = new Point(newPosition.x, newPosition.y + sp);
+											bounds.setLocation(newPosition2);
+											sp = sp + 2;
+										}
 									} else {
 										Point newPosition = (this.overlapping).findFreePosition(((JmtEdge) overlapping[j]), cell, cellBound, tmp,
 												true, false, false, false);
-										bounds.setLocation(newPosition);
+										if (newPosition.equals(bounds.getLocation())) {
+											bounds.setLocation(x, y);
+										} else {
+											bounds.setLocation(newPosition);
+										}
 									}
 								} else if (upperSideIntersaction && rightSideIntersaction) {
 									Point newPosition = (this.overlapping).findFreePosition(((JmtEdge) overlapping[j]), cell, cellBound, tmp, false,
 											false, false, true);
-									bounds.setLocation(newPosition);
+									if (newPosition.equals(bounds.getLocation())) {
+										bounds.setLocation(x, y);
+									} else {
+										bounds.setLocation(newPosition);
+									}
 								} else if (upperSideIntersaction && leftSideIntersaction) {
 									Point newPosition = (this.overlapping).findFreePosition(((JmtEdge) overlapping[j]), cell, cellBound, tmp, false,
 											false, true, false);
-									bounds.setLocation(newPosition);
+									if (newPosition.equals(bounds.getLocation())) {
+										bounds.setLocation(x, y);
+									} else {
+										bounds.setLocation(newPosition);
+									}
 								} else if (lowerSideIntersaction && rightSideIntersaction) {
 									Point2D tmp1 = (intersectionPoints.get(1));
 									Point newPosition = (this.overlapping).findFreePosition(((JmtEdge) overlapping[j]), cell, cellBound, tmp1, false,
 											false, false, true);
-									bounds.setLocation(newPosition);
+									if (newPosition.equals(bounds.getLocation())) {
+										bounds.setLocation(x, y);
+									} else {
+										bounds.setLocation(newPosition);
+									}
 								} else if (lowerSideIntersaction && leftSideIntersaction) {
 									Point newPosition = (this.overlapping).findFreePosition(((JmtEdge) overlapping[j]), cell, cellBound, tmp, false,
 											false, true, false);
-									bounds.setLocation(newPosition);
+									if (newPosition.equals(bounds.getLocation())) {
+										bounds.setLocation(x, y);
+									} else {
+										bounds.setLocation(newPosition);
+									}
 								}
 								access = true;
 							}
@@ -1737,7 +1913,7 @@
 										GraphConstants.getBounds(((SinkCell) cell).getAttributes()))) {
 									ArrayList<Point2D> intersectionPoints = ((JmtEdge) overlapping[j]).getIntersectionVertexPoint();
 									Point2D tmp = (intersectionPoints.get(0));
-									Rectangle2D cellBound = GraphConstants.getBounds(((SinkCell) cell).getAttributes());
+									Rectangle2D cellBound = bounds; // GraphConstants.getBounds(((SinkCell) cell).getAttributes());
 									double vertexMaxX = (int) cellBound.getMaxX();
 									double vertexMaxY = (int) cellBound.getMaxY();
 									double vertexHeight = (int) cellBound.getHeight();
@@ -1751,11 +1927,19 @@
 										if ((int) tmp.getX() < valoreIntermedio) {
 											Point newPosition = (this.overlapping).findFreePosition(((JmtEdge) overlapping[j]), cell, cellBound, tmp,
 													false, false, true, false);
-											bounds.setLocation(newPosition);
+											if (newPosition.equals(bounds.getLocation())) {
+												bounds.setLocation(x, y);
+											} else {
+												bounds.setLocation(newPosition);
+											}
 										} else {
 											Point newPosition = (this.overlapping).findFreePosition(((JmtEdge) overlapping[j]), cell, cellBound, tmp,
 													false, false, false, true);
-											bounds.setLocation(newPosition);
+											if (newPosition.equals(bounds.getLocation())) {
+												bounds.setLocation(x, y);
+											} else {
+												bounds.setLocation(newPosition);
+											}
 										}
 									} else if (leftSideIntersaction && rightSideIntersaction) {
 										int valoreIntermedio = ((int) vertexMaxY - (int) (vertexHeight / 2));
@@ -1762,31 +1946,55 @@
 										if ((int) tmp.getY() < valoreIntermedio) {
 											Point newPosition = (this.overlapping).findFreePosition(((JmtEdge) overlapping[j]), cell, cellBound, tmp,
 													false, true, false, false);
-											Point newPosition2 = new Point(newPosition.x, newPosition.y + sp);
-											bounds.setLocation(newPosition2);
-											sp = sp + 3;
+											if (newPosition.equals(bounds.getLocation())) {
+												bounds.setLocation(x, y);
+											} else {
+												Point newPosition2 = new Point(newPosition.x, newPosition.y + sp);
+												bounds.setLocation(newPosition2);
+												sp = sp + 3;
+											}
 										} else {
 											Point newPosition = (this.overlapping).findFreePosition(((JmtEdge) overlapping[j]), cell, cellBound, tmp,
 													true, false, false, false);
-											bounds.setLocation(newPosition);
+											if (newPosition.equals(bounds.getLocation())) {
+												bounds.setLocation(x, y);
+											} else {
+												bounds.setLocation(newPosition);
+											}
 										}
 									} else if (upperSideIntersaction && rightSideIntersaction) {
 										Point newPosition = (this.overlapping).findFreePosition(((JmtEdge) overlapping[j]), cell, cellBound, tmp,
 												false, false, false, true);
-										bounds.setLocation(newPosition);
+										if (newPosition.equals(bounds.getLocation())) {
+											bounds.setLocation(x, y);
+										} else {
+											bounds.setLocation(newPosition);
+										}
 									} else if (upperSideIntersaction && leftSideIntersaction) {
 										Point newPosition = (this.overlapping).findFreePosition(((JmtEdge) overlapping[j]), cell, cellBound, tmp,
 												false, false, true, false);
-										bounds.setLocation(newPosition);
+										if (newPosition.equals(bounds.getLocation())) {
+											bounds.setLocation(x, y);
+										} else {
+											bounds.setLocation(newPosition);
+										}
 									} else if (lowerSideIntersaction && rightSideIntersaction) {
 										Point2D tmp1 = (intersectionPoints.get(1));
 										Point newPosition = (this.overlapping).findFreePosition(((JmtEdge) overlapping[j]), cell, cellBound, tmp1,
 												false, false, false, true);
-										bounds.setLocation(newPosition);
+										if (newPosition.equals(bounds.getLocation())) {
+											bounds.setLocation(x, y);
+										} else {
+											bounds.setLocation(newPosition);
+										}
 									} else if (lowerSideIntersaction && leftSideIntersaction) {
 										Point newPosition = (this.overlapping).findFreePosition(((JmtEdge) overlapping[j]), cell, cellBound, tmp,
 												false, false, true, false);
-										bounds.setLocation(newPosition);
+										if (newPosition.equals(bounds.getLocation())) {
+											bounds.setLocation(x, y);
+										} else {
+											bounds.setLocation(newPosition);
+										}
 									}
 									access2 = true;
 								}
@@ -1794,7 +2002,7 @@
 						}
 
 						if (!isInGroup(overlapping[j]) && !access && !access2 && overlapping[j] instanceof JmtEdge) {
-							if ((numberOfChild == 2)
+							if ((numberOfChild >= 2)
 									&& ((JmtEdge) overlapping[j]).getSource() != cell.getChildAt(0)
 									&& ((JmtEdge) overlapping[j]).getSource() != cell.getChildAt(1)
 									&& ((JmtEdge) overlapping[j]).getTarget() != cell.getChildAt(0)
@@ -1810,7 +2018,7 @@
 									return;
 								} else {
 									Point2D tmp = (intersectionPoints.get(0));
-									Rectangle2D cellBound = GraphConstants.getBounds(cell.getAttributes());
+									Rectangle2D cellBound = bounds; //GraphConstants.getBounds(cell.getAttributes());
 									double vertexMaxX = (int) cellBound.getMaxX();
 									double vertexMaxY = (int) cellBound.getMaxY();
 									double vertexHeight = (int) cellBound.getHeight();
@@ -1824,11 +2032,19 @@
 										if ((int) tmp.getX() < valoreIntermedio) {
 											Point newPosition = (this.overlapping).findFreePosition(((JmtEdge) overlapping[j]), cell, cellBound, tmp,
 													false, false, true, false);
-											bounds.setLocation(newPosition);
+											if (newPosition.equals(bounds.getLocation())) {
+												bounds.setLocation(x, y);
+											} else {
+												bounds.setLocation(newPosition);
+											}
 										} else {
 											Point newPosition = (this.overlapping).findFreePosition(((JmtEdge) overlapping[j]), cell, cellBound, tmp,
 													false, false, false, true);
-											bounds.setLocation(newPosition);
+											if (newPosition.equals(bounds.getLocation())) {
+												bounds.setLocation(x, y);
+											} else {
+												bounds.setLocation(newPosition);
+											}
 										}
 									} else if (leftSideIntersaction && rightSideIntersaction) {
 										int valoreIntermedio = ((int) vertexMaxY - (int) (vertexHeight / 2));
@@ -1835,31 +2051,55 @@
 										if ((int) tmp.getY() < valoreIntermedio) {
 											Point newPosition = (this.overlapping).findFreePosition(((JmtEdge) overlapping[j]), cell, cellBound, tmp,
 													false, true, false, false);
-											Point newPosition2 = new Point(newPosition.x, newPosition.y + sp);
-											bounds.setLocation(newPosition2);
-											sp = sp + 3;
+											if (newPosition.equals(bounds.getLocation())) {
+												bounds.setLocation(x, y);
+											} else {
+												Point newPosition2 = new Point(newPosition.x, newPosition.y + sp);
+												bounds.setLocation(newPosition2);
+												sp = sp + 3;
+											}
 										} else {
 											Point newPosition = (this.overlapping).findFreePosition(((JmtEdge) overlapping[j]), cell, cellBound, tmp,
 													true, false, false, false);
-											bounds.setLocation(newPosition);
+											if (newPosition.equals(bounds.getLocation())) {
+												bounds.setLocation(x, y);
+											} else {
+												bounds.setLocation(newPosition);
+											}
 										}
 									} else if (upperSideIntersaction && rightSideIntersaction) {
 										Point newPosition = (this.overlapping).findFreePosition(((JmtEdge) overlapping[j]), cell, cellBound, tmp,
 												false, false, false, true);
-										bounds.setLocation(newPosition);
+										if (newPosition.equals(bounds.getLocation())) {
+											bounds.setLocation(x, y);
+										} else {
+											bounds.setLocation(newPosition);
+										}
 									} else if (upperSideIntersaction && leftSideIntersaction) {
 										Point newPosition = (this.overlapping).findFreePosition(((JmtEdge) overlapping[j]), cell, cellBound, tmp,
 												false, false, true, false);
-										bounds.setLocation(newPosition);
+										if (newPosition.equals(bounds.getLocation())) {
+											bounds.setLocation(x, y);
+										} else {
+											bounds.setLocation(newPosition);
+										}
 									} else if (lowerSideIntersaction && rightSideIntersaction) {
 										Point2D tmp1 = (intersectionPoints.get(1));
 										Point newPosition = (this.overlapping).findFreePosition(((JmtEdge) overlapping[j]), cell, cellBound, tmp1,
 												false, false, false, true);
-										bounds.setLocation(newPosition);
+										if (newPosition.equals(bounds.getLocation())) {
+											bounds.setLocation(x, y);
+										} else {
+											bounds.setLocation(newPosition);
+										}
 									} else if (lowerSideIntersaction && leftSideIntersaction) {
 										Point newPosition = (this.overlapping).findFreePosition(((JmtEdge) overlapping[j]), cell, cellBound, tmp,
 												false, false, true, false);
-										bounds.setLocation(newPosition);
+										if (newPosition.equals(bounds.getLocation())) {
+											bounds.setLocation(x, y);
+										} else {
+											bounds.setLocation(newPosition);
+										}
 									}
 								}
 							}
@@ -2884,14 +3124,21 @@
 			JmtCell current = (JmtCell) cell;
 			Map<Object, Map> nested = new Hashtable<Object, Map>();
 			Map attributeMap = new Hashtable();
-			ImageIcon icon;
+			Icon icon;
 			if (current.isLeftInputCell()) {
 				icon = JMTImageLoader.loadImage(current.getIcon(), ImageLoader.MODIFIER_MIRROR);
 			} else {
 				icon = JMTImageLoader.loadImage(current.getIcon());
 			}
-			GraphConstants.setIcon(attributeMap, icon);
 
+			if (current.isPinned()) {
+				Rectangle2D bounds = GraphConstants.getBounds(current.getAttributes());
+				ImageIcon lockIcon = JMTImageLoader.loadImage("lock", new Dimension(16, 16));
+				GraphConstants.setIcon(attributeMap, new MergedIcon(icon, lockIcon, current.isLeftInputCell() ? (int) bounds.getWidth() - 16 : 0, 0));
+			} else {
+				GraphConstants.setIcon(attributeMap, icon);
+			}
+
 			nested.put(cell, attributeMap);
 			current.setLeftInputCell(!current.isLeftInputCell());
 			current.updatePortPositions(nested, icon, current.getSize(graph));
@@ -2952,7 +3199,9 @@
 		List<Object> max = new ArrayList<Object>();
 
 		cells = graph.getDescendants(graph.getRoots());
+		//Object[] nonPinnedCells = new Object[cells.length];
 
+		//int j = 0;
 		for (int i = 0; i < cells.length; i++) {
 			if (cells[i] instanceof JmtCell) {
 				Rectangle bounds = GraphConstants.getBounds(((JmtCell) cells[i]).getAttributes()).getBounds();
@@ -2965,9 +3214,14 @@
 				if (!((JmtCell) cells[i]).isLeftInputCell()) {
 					rotateComponent(new Object[] { cells[i] });
 				}
+				/*if (!((JmtCell) cells[i]).isPinned()) {
+					nonPinnedCells[j++] = cells[i];
+				}*/
 			}
 		}
 
+		//cells = nonPinnedCells;
+
 		boolean sourceIn = false;
 		for (int i = 0; i < cells.length; i++) {
 			if (cells[i] instanceof JmtCell) {
@@ -3089,7 +3343,11 @@
 						- (int) (boundspadre.getHeight() / 2) + 30);
 			}
 
-			GraphConstants.setBounds(prev.getAttributes(), boundspadre);
+			// Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+			// Don't move this component if it is pinned
+			//if (!prev.isPinned()) {
+				GraphConstants.setBounds(prev.getAttributes(), boundspadre);
+			//}
 			x = (int) boundspadre.getCenterX() + widthMax + 50;
 			prev.seen = true;
 			flag2 = true;
@@ -3121,7 +3379,10 @@
 			Rectangle bounds = GraphConstants.getBounds(((JmtCell) next.get(0)).getAttributes()).getBounds();
 			bounds.setLocation((int) (boundspadre.getCenterX()) + widthMax + 50 - (int) (bounds.getWidth() / 2),
 					(int) boundspadre.getCenterY() - (int) (bounds.getHeight() / 2));
-			GraphConstants.setBounds(((JmtCell) next.get(0)).getAttributes(), bounds);
+			// Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+			// Don't move this component if it is pinned
+			//if (!(((JmtCell) next.get(0)).isPinned()))
+				GraphConstants.setBounds(((JmtCell) next.get(0)).getAttributes(), bounds);
 
 			((JmtCell) next.get(0)).seen = true;
 			j = searchNext((JmtCell) next.get(0));
@@ -3160,8 +3421,12 @@
 				Rectangle bounds = GraphConstants.getBounds(((JmtCell) sons.get(i)).getAttributes()).getBounds();
 				bounds.setLocation((int) (boundspadre.getCenterX()) + widthMax + 50 - (int) (bounds.getWidth() / 2),
 						w - (int) (bounds.getHeight() / 2) + 80);
-				GraphConstants.setBounds(((JmtCell) sons.get(i)).getAttributes(), bounds);
 
+				// Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+				// Don't move this component if it is pinned
+				//if (!(((JmtCell) sons.get(i)).isPinned()))
+					GraphConstants.setBounds(((JmtCell) sons.get(i)).getAttributes(), bounds);
+
 				((JmtCell) sons.get(i)).seen = true;
 				listEdges = DefaultGraphModel.getOutgoingEdges(graphmodel, sons.get(i));
 
@@ -3324,6 +3589,7 @@
 			setConnect.setEnabled(false);
 			setSelect.setEnabled(false);
 			actionSetRight.setEnabled(false);
+			actionSnapToGrid.setEnabled(false);
 		}
 
 		// Selects components from removed blocking regions
@@ -3349,4 +3615,228 @@
 		}
 	}
 
+	// Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+	/**
+	 *
+	 * @param x
+	 * @param y
+	 * @return
+	 */
+	public PortView getFreeOutPortViewAt(int x, int y) {
+		return (PortView) graph.getGraphLayoutCache().getMapping(graph.getFreeOutPortAt(x, y), false);
+	}
+
+	// Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+	// Try to adjust the graph, then displays a confirmation message to prompt the user to keep the result or restore the initial state
+	public void tryAdjustGraph() {
+		// This introduces some potential quirks that need to be fixed
+		boolean atLeastOnePinned = false;
+		Object[] cells = graph.getDescendants(graph.getRoots());
+		// Previous cell positions
+		Rectangle2D[] cellsBounds = new Rectangle2D[cells.length];
+		// The algorithm changes the rotate state, we need to save them in order to restore if the users undoes the operation
+		boolean[] cellsRotateState = new boolean[cells.length];
+		for (int i = 0; i < cells.length; i++) {
+			if (cells[i] instanceof JmtCell) {
+				JmtCell cell = (JmtCell) cells[i];
+				cellsBounds[i] = GraphConstants.getBounds(cell.getAttributes()).getBounds();
+				cellsRotateState[i] = cell.isLeftInputCell();
+				if (cell.isPinned()) {
+					atLeastOnePinned = true;
+				}
+			}
+
+		}
+
+		adjustGraph();
+
+		// Simple heuristics that prevents components to be arranged of the graph's bounds
+		/*if (atLeastOnePinned) {
+			double xdirection;
+			double ydirection;
+			double minDistance = Double.POSITIVE_INFINITY;
+			double dx = 0;
+			double dy = 0;
+			int minIndex = -1;
+
+			for (int i = 0; i < cells.length; i++) {
+				if (cells[i] instanceof JmtCell) {
+					JmtCell cell = (JmtCell) cells[i];
+					if (!cell.isPinned()) {
+						Rectangle2D repositionedBounds = GraphConstants.getBounds(cell.getAttributes()).getBounds();
+						double euclideanDist = Math.sqrt(Math.pow((cellsBounds[i].getX() - repositionedBounds.getX()), 2) + Math.pow((cellsBounds[i].getY() - repositionedBounds.getY()), 2));
+						// Store the minimum euclidean distance between the original component position and the arranged one, and the slope of this segment
+						if (euclideanDist < minDistance) {
+							minDistance = euclideanDist;
+							//slope = (repositionedBounds.getY() - cellsBounds[i].getY()) / (repositionedBounds.getX() - cellsBounds[i].getX());
+							dx = Math.abs((repositionedBounds.getX() - cellsBounds[i].getX()));
+							dy = Math.abs((repositionedBounds.getY() - cellsBounds[i].getY()));
+							minIndex = i;
+						}
+					}
+				}
+			}
+
+			for (int i = 0; i < cells.length; i++) {
+				if (cells[i] instanceof JmtCell) {
+					JmtCell cell = (JmtCell) cells[i];
+					if (!cell.isPinned()) {
+						if (i == minIndex) {
+							GraphConstants.setBounds(cell.getAttributes(), cellsBounds[i]);
+						} else {
+							Rectangle2D repositionedBounds = GraphConstants.getBounds(cell.getAttributes()).getBounds();
+							if (cellsBounds[i].getX() > repositionedBounds.getX()) {
+								xdirection = 1;
+							} else {
+								xdirection = -1;
+							}
+
+							if (cellsBounds[i].getY() > repositionedBounds.getY()) {
+								ydirection = 1;
+							} else {
+								ydirection = -1;
+							}
+
+							// Move all the other components by the same amount of distance, constrained by the fact that
+							// the movement segment should have the same slope of the minimum
+							// one found in the previous cycle.
+							//double xfinal = direction * Math.sqrt(minDistance * minDistance / (1 + slope * slope)) + repositionedBounds.getX();
+							//double yfinal = slope * (xfinal - repositionedBounds.getX()) + repositionedBounds.getY();
+							repositionedBounds.setRect(repositionedBounds.getX() + xdirection * dx, repositionedBounds.getY() + ydirection * dy, repositionedBounds.getWidth(), repositionedBounds.getHeight());
+							GraphConstants.setBounds(cell.getAttributes(), repositionedBounds);
+						}
+					}
+				}
+			}
+
+			graphRepaint();
+			graph.getGraphLayoutCache().reload();
+			avoidOverlappingCell(cells);
+		}*/
+
+		// Display confirmation message
+		int result = JOptionPane.showConfirmDialog(mainWindow, "Keep the result of autoarrange?", "Autoarrange", JOptionPane.YES_NO_OPTION);
+		if (result == JOptionPane.NO_OPTION) {
+			// Restore cells position and rotate state in case of undo
+			for (int i = 0; i < cells.length; i++) {
+				if(cells[i] instanceof JmtCell) {
+					JmtCell cell = (JmtCell) cells[i];
+					GraphConstants.setBounds(cell.getAttributes(), cellsBounds[i]);
+					if (cell.isLeftInputCell() != cellsRotateState[i]) { // adjustGraph has rotated this cell, restore its previous state
+						rotateComponent(new Object[] { cell });
+					}
+				}
+			}
+			graphRepaint();
+			graph.getGraphLayoutCache().reload();
+			avoidOverlappingCell(cells);
+		}
+	}
+
+
+	// Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+	// Reposition components by aligning them to a grid with user-supplied cell size
+	public boolean snapToGrid() {
+		int cellSize;
+		String size = JOptionPane.showInputDialog(mainWindow, "Please specify the cells size in pixels (min 10, max 100):", 50);
+		if (size != null) {
+			try {
+				cellSize = Integer.parseInt(size);
+				if (cellSize < 10) {
+					cellSize = 10;
+				} else if(cellSize > 100) {
+					cellSize = 100;
+				}
+			} catch (NumberFormatException e) {
+				cellSize = 50;
+			}
+
+			Object[] cells = graph.getDescendants(graph.getRoots());
+
+			for (Object cell : cells) {
+				if (cell instanceof JmtCell) {
+					JmtCell jcell = (JmtCell) cell;
+					if (!jcell.isPinned()) {
+						Rectangle2D bounds = GraphConstants.getBounds(jcell.getAttributes()).getBounds();
+						bounds.setRect(Math.round(bounds.getX() / cellSize) * cellSize, Math.round(bounds.getY() / cellSize) * cellSize, bounds.getWidth(), bounds.getHeight());
+						GraphConstants.setBounds(jcell.getAttributes(), bounds);
+					}
+				}
+			}
+
+			// With larger cell size, some components may overlap, solve this issue by moving the necessary components in adjacent cells.
+			boolean needRecompute = true;
+			while (needRecompute) {
+				needRecompute = false;
+				for (int i = 0; i < cells.length; i++) {
+					if (cells[i] instanceof JmtCell) {
+						JmtCell cell1 = (JmtCell) cells[i];
+						Rectangle2D bounds1 = GraphConstants.getBounds(cell1.getAttributes()).getBounds();
+						for (int j = i + 1; j < cells.length; j++) {
+							if (cells[j] instanceof JmtCell) {
+								JmtCell cell2 = (JmtCell) cells[j];
+								Rectangle2D bounds2 = GraphConstants.getBounds(cell2.getAttributes()).getBounds();
+								if (intersectRect(bounds1, bounds2)) {
+									if (!cell2.isPinned()) {
+										bounds2.setRect(bounds2.getX() + cellSize, bounds2.getY(), bounds2.getWidth(), bounds2.getHeight());
+										GraphConstants.setBounds(cell2.getAttributes(), bounds2);
+									} else {
+										bounds1.setRect(bounds1.getX() + cellSize, bounds1.getY(), bounds1.getWidth(), bounds1.getHeight());
+										GraphConstants.setBounds(cell1.getAttributes(), bounds1);
+									}
+									needRecompute = true;
+								}
+							}
+						}
+					}
+				}
+			}
+
+			graphRepaint();
+			graph.getGraphLayoutCache().reload();
+			avoidOverlappingCell(cells);
+			return true;
+		}
+		return false;
+	}
+
+	// Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+	// Try to snap components to the grid, then displays a confirmation message to prompt the user to keep the result or restore the initial state
+	public void trySnapToGrid() {
+		Object[] cells = graph.getDescendants(graph.getRoots());
+		Rectangle2D[] cellsBounds = new Rectangle2D[cells.length];
+		for (int i = 0; i < cells.length; i++) {
+			if (cells[i] instanceof JmtCell) {
+				JmtCell cell = (JmtCell) cells[i];
+				cellsBounds[i] = GraphConstants.getBounds(cell.getAttributes()).getBounds();
+			}
+
+		}
+
+		if (snapToGrid()) {
+			// Undo only if snap was actually performed
+			int result = JOptionPane.showConfirmDialog(mainWindow, "Keep the result of snap to grid?", "Snap to grid", JOptionPane.YES_NO_OPTION);
+			if (result == JOptionPane.NO_OPTION) {
+				for (int i = 0; i < cells.length; i++) {
+					if (cells[i] instanceof JmtCell) {
+						JmtCell cell = (JmtCell) cells[i];
+						GraphConstants.setBounds(cell.getAttributes(), cellsBounds[i]);
+					}
+				}
+				graphRepaint();
+				graph.getGraphLayoutCache().reload();
+				avoidOverlappingCell(cells);
+			}
+		}
+
+	}
+
+	// Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+	// Checks whether two rectangles intersect.
+	private boolean intersectRect(Rectangle2D r1, Rectangle2D r2) {
+		return !(r2.getMinX() > r1.getMaxX() ||
+				r2.getMaxX() < r1.getMinX() ||
+				r2.getMinY() > r1.getMaxY() ||
+				r2.getMaxY() < r1.getMinY());
+	}
 }
Index: src/main/java/jmt/gui/jsimgraph/controller/SelectState.java
===================================================================
--- src/main/java/jmt/gui/jsimgraph/controller/SelectState.java	(revision 978)
+++ src/main/java/jmt/gui/jsimgraph/controller/SelectState.java	(working copy)
@@ -172,6 +172,7 @@
 		if (ml.getHandler() != null && ml.getHandler() == ml.getMarquee()) {
 			ml.getMarquee().mouseDragged(e);
 		} else if (ml.getHandler() == null && !mediator.isGraphEditing() && ml.getFocus() != null) {
+
 			if (!mediator.isCellSelected(ml.getFocus().getCell())) {
 				mediator.selectCellForEvent(ml.getFocus().getCell(), e);
 				ml.setCell(null);
@@ -184,35 +185,43 @@
 		if (ml.getHandle() != null && ml.getHandler() == ml.getHandle()) {
 			// BERTOLI MARCO - Added to avoid dragging of unselected elements (caused bugs)
 			if (mediator.getGraph().getSelectionCells().length > 0) {
-				ml.getHandle().mouseDragged(e);
 				Xmin = null;
 				Ymin = null;
 				Xmax = null;
 				Ymax = null;
 				graphtmp = (JmtJGraph) mediator.getGraph();
-				cells = graphtmp.getSelectionCells();
-				Xmin = new Integer[cells.length];
-				Ymin = new Integer[cells.length];
-				Xmax = new Integer[cells.length];
-				Ymax = new Integer[cells.length];
+				Object[] selectionCells = graphtmp.getSelectionCells();
+				cells = new Object[selectionCells.length];
+				Xmin = new Integer[selectionCells.length];
+				Ymin = new Integer[selectionCells.length];
+				Xmax = new Integer[selectionCells.length];
+				Ymax = new Integer[selectionCells.length];
 				//System.out.println("Numero di cell  in drag: " + cells.length);
-				if (cells.length > 0) {
-					for (int i = 0; i < cells.length; i++) {
-						if (cells[i] instanceof JmtCell) {
-							Rectangle2D rett = GraphConstants.getBounds(((JmtCell) cells[i]).getAttributes());
-							//rappresentano l angolo altro-sinistro di ogni cella selezionata
-							Xmin[i] = new Integer((int) rett.getMinX());
-							Ymin[i] = new Integer((int) rett.getMinY());
-							Xmax[i] = new Integer((int) rett.getMaxX());
-							Ymax[i] = new Integer((int) rett.getMaxY());
-							moved = true;
+				if (selectionCells.length > 0) {
+					int j = 0;
+					for (int i = 0; i < selectionCells.length; i++) {
+						if (selectionCells[i] instanceof JmtCell) {
+							if (((JmtCell) selectionCells[i]).isPinned()) {
+								graphtmp.getSelectionModel().removeSelectionCell(selectionCells[i]);
+								return;
+							} else {
+								Rectangle2D rett = GraphConstants.getBounds(((JmtCell) selectionCells[i]).getAttributes());
+								//rappresentano l angolo altro-sinistro di ogni cella selezionata
+								Xmin[j] = new Integer((int) rett.getMinX());
+								Ymin[j] = new Integer((int) rett.getMinY());
+								Xmax[j] = new Integer((int) rett.getMaxX());
+								Ymax[j] = new Integer((int) rett.getMaxY());
+								cells[j++] = selectionCells[i];
+								moved = true;
+							}
 						}
-						if (cells[i] instanceof BlockingRegion) {
-							CellView groupview = (graphtmp.getGraphLayoutCache()).getMapping(cells[i], false);
+						if (selectionCells[i] instanceof BlockingRegion) {
+							CellView groupview = (graphtmp.getGraphLayoutCache()).getMapping(selectionCells[i], false);
 							Rectangle2D rett2 = groupview.getBounds();
 
 							Object[] celgru = new Object[1];
-							celgru[0] = cells[i];
+							celgru[0] = selectionCells[i];
+							cells[j] = selectionCells[i];
 							//celle presenti nel blocking region incluse port e regione
 
 							//Object[] celless=graphtmp.getDescendants(celgru);
@@ -220,8 +229,8 @@
 
 							if (rett2 != null) {
 								//System.out.println("Dentro DRAG mi restituisce un rettangolo se è di tipoBLockingRegion");
-								Xmin[i] = new Integer((int) rett2.getMinX());
-								Ymin[i] = new Integer((int) rett2.getMinY());
+								Xmin[j] = new Integer((int) rett2.getMinX());
+								Ymin[j++] = new Integer((int) rett2.getMinY());
 								//Xmax[i]=new Integer((int) rett2.getMaxX());
 								//Ymax[i]=new Integer((int) rett2.getMaxY());
 								//System.out.println("Valori: "+ X[i]+", "+Y[i]);
@@ -231,6 +240,7 @@
 						}
 					}
 				}
+				ml.getHandle().mouseDragged(e);
 			}
 		}
 
Index: src/main/java/jmt/gui/jsimgraph/controller/actions/ActionSetRight.java
===================================================================
--- src/main/java/jmt/gui/jsimgraph/controller/actions/ActionSetRight.java	(revision 978)
+++ src/main/java/jmt/gui/jsimgraph/controller/actions/ActionSetRight.java	(working copy)
@@ -5,6 +5,8 @@
 
 import jmt.gui.jsimgraph.controller.Mediator;
 
+import javax.swing.*;
+
 /**
  * A class representing a "redo" action.
  * @author Giuseppe De Cicco & Fabio Granara
@@ -34,7 +36,9 @@
 	 */
 	boolean repeat = false;
 
+
 	public void actionPerformed(ActionEvent e) {
-		mediator.adjustGraph();
+		// Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+		mediator.tryAdjustGraph();
 	}
 }
Index: src/main/java/jmt/gui/jsimgraph/mainGui/ComponentBar.java
===================================================================
--- src/main/java/jmt/gui/jsimgraph/mainGui/ComponentBar.java	(revision 978)
+++ src/main/java/jmt/gui/jsimgraph/mainGui/ComponentBar.java	(working copy)
@@ -63,6 +63,8 @@
 		addGenericButton(m.getRotate());
 		// Set right button
 		addGenericButton(m.getSetRight());
+		// Snap to grid button
+		addGenericButton(m.getSnapToGrid());
 
 		// Disables all components button
 		enableButtons(false);
Index: src/main/java/jmt/gui/jsimgraph/panels/StationNamePanel.java
===================================================================
--- src/main/java/jmt/gui/jsimgraph/panels/StationNamePanel.java	(revision 978)
+++ src/main/java/jmt/gui/jsimgraph/panels/StationNamePanel.java	(working copy)
@@ -24,10 +24,7 @@
 import java.awt.event.KeyEvent;
 import java.awt.event.KeyListener;
 
-import javax.swing.Box;
-import javax.swing.JLabel;
-import javax.swing.JPanel;
-import javax.swing.JTextField;
+import javax.swing.*;
 import javax.swing.border.EtchedBorder;
 import javax.swing.border.TitledBorder;
 
@@ -49,6 +46,8 @@
 	private JmodelStationDefinition sd;
 	private Object key;
 	private JTextField name = new JTextField();
+	// Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+	private JCheckBox pinned = new JCheckBox();
 
 	/**
 	 * Creates a new Station Name Panel
@@ -65,15 +64,28 @@
 	 * Inits this panel's components and their action listeners
 	 */
 	private void init() {
+		BorderLayout pinLayout = new BorderLayout(5, 0);
+		JPanel pinPanel = new JPanel();
+		pinPanel.setLayout(pinLayout);
 		setLayout(new BorderLayout(5, 5));
 		setBorder(new TitledBorder(new EtchedBorder(), "Station Name"));
 		add(new JLabel("Station Name: "), BorderLayout.WEST);
 		name.setText(sd.getStationName(key));
+		pinned.setSelected(sd.isPinned(key));
 		add(name, BorderLayout.CENTER);
+		// Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+		pinPanel.add(new JLabel("Pin:"), BorderLayout.WEST);
+		pinPanel.add(pinned, BorderLayout.CENTER);
+
+		add(pinPanel, BorderLayout.EAST);
 		add(Box.createVerticalStrut(5), BorderLayout.SOUTH);
 		inputListener listener = new inputListener();
 		name.addKeyListener(listener);
 		name.addFocusListener(listener);
+
+		// Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+		pinned.addFocusListener(listener);
+		pinned.addKeyListener(listener);
 	}
 
 	/**
@@ -86,7 +98,10 @@
 		 */
 		protected void updateValues() {
 			sd.setStationName(key, name.getText());
+			sd.setIsPinned(key, pinned.isSelected());
 			name.setText(sd.getStationName(key));
+			// Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+			pinned.setSelected(sd.isPinned(key));
 		}
 
 		public void focusLost(FocusEvent e) {
Index: src/main/resources/jmt/common/xml/JModelGUI.xsd
===================================================================
--- src/main/resources/jmt/common/xml/JModelGUI.xsd	(revision 978)
+++ src/main/resources/jmt/common/xml/JModelGUI.xsd	(working copy)
@@ -31,6 +31,7 @@
 									<xs:attribute name="x" type="jdouble" use="required"/>
 									<xs:attribute name="y" type="jdouble" use="required"/>
 									<xs:attribute name="rotate" type="xs:boolean" use="optional"/>
+									<xs:attribute name="pin" type="xs:boolean" use="optional"/>
 								</xs:complexType>
 							</xs:element>
 						</xs:sequence>
