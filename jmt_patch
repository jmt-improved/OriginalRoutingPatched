Index: src/main/java/jmt/commandline/JSIMSolver.java
===================================================================
--- src/main/java/jmt/commandline/JSIMSolver.java	(revision 978)
+++ src/main/java/jmt/commandline/JSIMSolver.java	(working copy)
@@ -49,7 +49,7 @@
 		}
 		File model = new File(args[0]);
 		if (!model.isFile()) {
-			System.err.print("Invalid model file: " + model.getAbsolutePath());
+			System.err.print("INVALID model file: " + model.getAbsolutePath());
 			System.exit(1);
 		}
 
@@ -60,7 +60,7 @@
 			try {
 				dispatcher.setSimulationSeed(Long.parseLong(args[1]));
 			} catch (NumberFormatException ex) {
-				System.err.println("Invalid simulation seed");
+				System.err.println("INVALID simulation seed");
 				System.exit(1);
 			}
 		}
Index: src/main/java/jmt/commandline/Jmt.java
===================================================================
--- src/main/java/jmt/commandline/Jmt.java	(revision 978)
+++ src/main/java/jmt/commandline/Jmt.java	(working copy)
@@ -139,7 +139,7 @@
 
 	public static void mva(File model, File result) throws SolverException, InputDataException, IOException {
 		if (!model.isFile()) {
-			System.err.print("Invalid model file: " + model.getAbsolutePath());
+			System.err.print("INVALID model file: " + model.getAbsolutePath());
 			System.exit(1);
 		}
 
@@ -223,7 +223,7 @@
 			try {
 				dispatcher.setSimulationSeed(Long.parseLong(options.get(OPTION_SEED)));
 			} catch (NumberFormatException ex) {
-				System.err.println("Invalid simulation seed. Should be a number.");
+				System.err.println("INVALID simulation seed. Should be a number.");
 				System.exit(1);
 			}
 		}
@@ -232,7 +232,7 @@
 			try {
 				dispatcher.setSimulationMaxDuration(Long.parseLong(options.get(OPTION_MAXTIME)) * 1000);
 			} catch (NumberFormatException ex) {
-				System.err.println("Invalid maximum simulation time. Should be a number.");
+				System.err.println("INVALID maximum simulation time. Should be a number.");
 				System.exit(1);
 			}	
 		}
Index: src/main/java/jmt/engine/math/parser/Parser.java
===================================================================
--- src/main/java/jmt/engine/math/parser/Parser.java	(revision 978)
+++ src/main/java/jmt/engine/math/parser/Parser.java	(working copy)
@@ -203,7 +203,7 @@
 			try {
 				d = Double.valueOf(s).doubleValue();
 			} catch (NumberFormatException ex) {
-				throw new ParseError("Invalid number: " + s, inp_cur);
+				throw new ParseError("INVALID number: " + s, inp_cur);
 			}
 			return new Element(NUM, d);
 		}
Index: src/main/java/jmt/gui/common/definitions/CommonModel.java
===================================================================
--- src/main/java/jmt/gui/common/definitions/CommonModel.java	(revision 978)
+++ src/main/java/jmt/gui/common/definitions/CommonModel.java	(working copy)
@@ -3542,9 +3542,15 @@
 		/** Reference to owner blocking station or null */
 		public Object blockingRegion;
 
+		// Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+		public boolean pinned;
+
 		public StationData(String name, String type) {
 			this.name = name;
 			this.type = type;
+			// Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+			// by default this station is free to move when autoarrange/snap to grid is utilized
+			this.pinned = false;
 		}
 	}
 
@@ -4053,6 +4059,32 @@
 		}
 	}
 
+	// Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+	@Override
+	public boolean isPinned(Object stationKey) {
+		StationData sd;
+		if (stationDataHM.containsKey(stationKey)) {
+			sd = (StationData) stationDataHM.get(stationKey);
+		} else {
+			return false;
+		}
+
+		return sd.pinned;
+	}
+
+	// Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+	@Override
+	public void setIsPinned(Object stationKey, boolean value) {
+		StationData sd;
+		if (stationDataHM.containsKey(stationKey)) {
+			sd = (StationData) stationDataHM.get(stationKey);
+		} else {
+			return;
+		}
+
+		sd.pinned = value;
+	}
+
 	/**
 	 * Returns given name if a mode with the same name does not exist or makes it unique
 	 * for a transition
Index: src/main/java/jmt/gui/common/definitions/StationDefinition.java
===================================================================
--- src/main/java/jmt/gui/common/definitions/StationDefinition.java	(revision 978)
+++ src/main/java/jmt/gui/common/definitions/StationDefinition.java	(working copy)
@@ -637,4 +637,15 @@
 	 */
 	public void setFiringOutcome(Object stationKey, int modeIndex, Object stationOutKey, Object classKey, Integer value);
 
+	/**
+	 * Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+	 * Returns pin status for <code>stationKey</code>
+	 */
+	boolean isPinned(Object stationKey);
+
+	/**
+	 * Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+	 * Sets new pin status for <code>stationKey</code>
+	 */
+	void setIsPinned(Object statioKey, boolean value);
 }
Index: src/main/java/jmt/gui/common/xml/GuiXMLConstants.java
===================================================================
--- src/main/java/jmt/gui/common/xml/GuiXMLConstants.java	(revision 978)
+++ src/main/java/jmt/gui/common/xml/GuiXMLConstants.java	(working copy)
@@ -41,6 +41,7 @@
 	public static final String XML_A_POSITION_X = "x";
 	public static final String XML_A_POSITION_Y = "y";
 	public static final String XML_A_POSITION_ROTATE = "rotate";
+	public static final String XML_A_PIN = "pin";
 
 	public static final String XML_E_PARAMETRIC = "parametric";
 	public static final String XML_A_PARAMETRIC_CLASSPATH = "classPath";
Index: src/main/java/jmt/gui/common/xml/GuiXMLReader.java
===================================================================
--- src/main/java/jmt/gui/common/xml/GuiXMLReader.java	(revision 978)
+++ src/main/java/jmt/gui/common/xml/GuiXMLReader.java	(working copy)
@@ -135,6 +135,8 @@
 		Element station, position;
 		String name;
 		double x, y;
+		// Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+		boolean pinned = false;
 		boolean rotate = false;
 		// For each stored Station
 		for (int i = 0; i < stations.getLength(); i++) {
@@ -146,11 +148,18 @@
 			if (position.hasAttribute(XML_A_POSITION_ROTATE)) {
 				rotate = Boolean.TRUE.toString().equalsIgnoreCase(position.getAttribute(XML_A_POSITION_ROTATE));
 			}
+			/* Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+			 * Sets pin status based on XML attribute's value, if not present, by default it is set to false.
+			 */
+			if (position.hasAttribute(XML_A_PIN)) {
+				pinned = Boolean.parseBoolean(position.getAttribute(XML_A_PIN));
+			}
 			if (names.containsKey(name)) {
 				model.setStationPosition(names.get(name), new JMTPoint(x, y, rotate));
 			} else {
 				System.out.println("Error - Found position info for station '" + name + "' which is not present into current model.");
 			}
+			model.setIsPinned(names.get(name), pinned);
 		}
 	}
 
Index: src/main/java/jmt/gui/common/xml/GuiXMLWriter.java
===================================================================
--- src/main/java/jmt/gui/common/xml/GuiXMLWriter.java	(revision 978)
+++ src/main/java/jmt/gui/common/xml/GuiXMLWriter.java	(working copy)
@@ -181,6 +181,8 @@
 			position.setAttribute(XML_A_POSITION_X, String.valueOf(model.getStationPosition(stationKey).getX()));
 			position.setAttribute(XML_A_POSITION_Y, String.valueOf(model.getStationPosition(stationKey).getY()));
 			position.setAttribute(XML_A_POSITION_ROTATE, String.valueOf(model.getStationPosition(stationKey).isRotate()));
+			// Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+			position.setAttribute(XML_A_PIN, String.valueOf(model.isPinned(stations.get(i))));
 			station.appendChild(position);
 			guiNode.appendChild(station);
 		}
Index: src/main/java/jmt/gui/exact/table/ExactTable.java
===================================================================
--- src/main/java/jmt/gui/exact/table/ExactTable.java	(revision 978)
+++ src/main/java/jmt/gui/exact/table/ExactTable.java	(working copy)
@@ -597,7 +597,7 @@
 		int[] colsselected = getSelectedColumns();
 		if (!((numrows - 1 == rowsselected[rowsselected.length - 1] - rowsselected[0] && numrows == rowsselected.length) && (numcols - 1 == colsselected[colsselected.length - 1]
 				- colsselected[0] && numcols == colsselected.length))) {
-			JOptionPane.showMessageDialog(null, "Invalid Copy Selection", "Invalid Copy Selection", JOptionPane.ERROR_MESSAGE);
+			JOptionPane.showMessageDialog(null, "INVALID Copy Selection", "INVALID Copy Selection", JOptionPane.ERROR_MESSAGE);
 			return;
 		}
 		for (int i = 0; i < numrows; i++) {
@@ -636,7 +636,7 @@
 		int[] colsselected = getSelectedColumns();
 		if (!((numrows - 1 == rowsselected[rowsselected.length - 1] - rowsselected[0] && numrows == rowsselected.length) && (numcols - 1 == colsselected[colsselected.length - 1]
 				- colsselected[0] && numcols == colsselected.length))) {
-			JOptionPane.showMessageDialog(null, "Invalid Clear Selection", "Invalid Clear Selection", JOptionPane.ERROR_MESSAGE);
+			JOptionPane.showMessageDialog(null, "INVALID Clear Selection", "INVALID Clear Selection", JOptionPane.ERROR_MESSAGE);
 			return;
 		}
 		for (int i = 0; i < numrows; i++) {
Index: src/main/java/jmt/gui/jsimgraph/JGraphMod/CellComponent.java
===================================================================
--- src/main/java/jmt/gui/jsimgraph/JGraphMod/CellComponent.java	(revision 978)
+++ src/main/java/jmt/gui/jsimgraph/JGraphMod/CellComponent.java	(working copy)
@@ -54,6 +54,12 @@
 	}
 
 	/**
+	 * Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+	 * Returns pin status based on the value stored in the JModelStationDefinition instance attached to this CellComponent.
+	 */
+	public boolean isPinned() { return sd.isPinned(key); }
+
+	/**
 	 * Returns key referencing this station
 	 * @return this station's key
 	 */
Index: src/main/java/jmt/gui/jsimgraph/JGraphMod/ClassSwitchCell.java
===================================================================
--- src/main/java/jmt/gui/jsimgraph/JGraphMod/ClassSwitchCell.java	(revision 978)
+++ src/main/java/jmt/gui/jsimgraph/JGraphMod/ClassSwitchCell.java	(working copy)
@@ -20,7 +20,9 @@
 
 import org.jgraph.graph.Port;
 
- /**
+import java.awt.geom.Point2D;
+
+/**
  * It represent a component that switches class of jobs coming into it. 
  * @author John
  *
Index: src/main/java/jmt/gui/jsimgraph/JGraphMod/JmtCell.java
===================================================================
--- src/main/java/jmt/gui/jsimgraph/JGraphMod/JmtCell.java	(revision 978)
+++ src/main/java/jmt/gui/jsimgraph/JGraphMod/JmtCell.java	(working copy)
@@ -1,16 +1,16 @@
 /**
  * Copyright (C) 2016, Laboratorio di Valutazione delle Prestazioni - Politecnico di Milano
-
+ * <p>
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
-
+ * <p>
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  * GNU General Public License for more details.
-
+ * <p>
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
@@ -26,8 +26,7 @@
 import java.awt.font.FontRenderContext;
 import java.awt.geom.Point2D;
 import java.awt.geom.Rectangle2D;
-import java.util.Hashtable;
-import java.util.Map;
+import java.util.*;
 
 import javax.swing.Icon;
 import javax.swing.ImageIcon;
@@ -35,251 +34,271 @@
 
 import jmt.gui.common.JMTImageLoader;
 
+import jmt.gui.common.MergedIcon;
 import org.jgraph.JGraph;
-import org.jgraph.graph.DefaultGraphCell;
-import org.jgraph.graph.DefaultPort;
-import org.jgraph.graph.GraphConstants;
-import org.jgraph.graph.Port;
+import org.jgraph.graph.*;
 
 /**
  * vertex cell for jmt
  *
  * @author Federico Granata
- * Date: 11-lug-2003
- * Time: 13.48.34
- *
+ *         Date: 11-lug-2003
+ *         Time: 13.48.34
  * @author Bertoli Marco
  */
 public abstract class JmtCell extends DefaultGraphCell {
 
-	private static final long serialVersionUID = 1L;
-	private Dimension imageDimension;
-	// Used to determine if parent of this cell has changed (to detect enter and exit from
-	// blocking regions)
-	private TreeNode parentRef;
-	/**
-	 * Different kind of nodes.
-	 */
-	public static final int SOURCE = 0;
-	public static final int TERMINAL = 1;
-	public static final int DELAY = 2;
-	public static final int SERVER = 3;
-	public static final int SINK = 4;
-	public static final int FORK = 5;
-	public static final int JOIN = 6;
-	public static final int LDSERVER = 7;
-	public static final int CLASSSWITCH = 8;
-	public static final int SEMAPHORE = 9;
-	public static final int SCALER = 10;
-	public static final int PLACE = 11;
-	public static final int TRANSITION = 12;
+    private static final long serialVersionUID = 1L;
+    private Dimension imageDimension;
+    // Used to determine if parent of this cell has changed (to detect enter and exit from
+    // blocking regions)
+    private TreeNode parentRef;
 
-	private Port[] ports;
+    /**
+     * Different kind of nodes.
+     */
+    public static final int SOURCE = 0;
+    public static final int TERMINAL = 1;
+    public static final int DELAY = 2;
+    public static final int SERVER = 3;
+    public static final int SINK = 4;
+    public static final int FORK = 5;
+    public static final int JOIN = 6;
+    public static final int LDSERVER = 7;
+    public static final int CLASSSWITCH = 8;
+    public static final int SEMAPHORE = 9;
+    public static final int SCALER = 10;
+    public static final int PLACE = 11;
+    public static final int TRANSITION = 12;
 
-	// Giuseppe De Cicco & Fabio Granara
-	public boolean seen = false;
-	public int in = 0;
-	public int out = 0;
-	public boolean okin = false;
-	public boolean okout = false;
-	public int sons = 1;
-	public int type;
-	private boolean leftInputCell = true;
+    private Port[] ports;
 
-	/**
-	 * Tells if this component can be placed on JGraph or has been disabled. This is
-	 * useful to load old models with disabled components (like terminals)
-	 */
-	public static final boolean canBePlaced = true;
+    // Giuseppe De Cicco & Fabio Granara
+    public boolean seen = false;
+    public int in = 1;
+    public int out = 1;
+    public boolean okin = false;
+    public boolean okout = false;
+    public int sons = 1;
+    public int type;
+    private boolean leftInputCell = true;
 
-	/**
-	 * Creates a graph cell and initializes it with the specified user object.
-	 *
-	 * @param userObject an Object provided by the user that constitutes
-	 *                   the cell's data
-	 *
-	 * Conti Andrea  01-09-2003
-	 * Bertoli Marco 04-giu-2005
-	 */
-	public JmtCell(String icon, Object userObject) {
-		super(userObject);
-		ImageIcon ico = JMTImageLoader.loadImage(icon);
-		GraphConstants.setIcon(attributes, ico);
-		imageDimension = new Dimension(ico.getIconWidth(), ico.getIconHeight());
-		GraphConstants.setSizeable(attributes, false);
-		GraphConstants.setSize(attributes, imageDimension);
-	}
+    /**
+     * Tells if this component can be placed on JGraph or has been disabled. This is
+     * useful to load old models with disabled components (like terminals)
+     */
+    public static final boolean canBePlaced = true;
 
-	// Giuseppe De Cicco & Fabio Granara
-	public void AddIn() {
-		in += 1;
-	}
+    /**
+     * Creates a graph cell and initializes it with the specified user object.
+     *
+     * @param userObject an Object provided by the user that constitutes
+     *                   the cell's data
+     *                   <p>
+     *                   Conti Andrea  01-09-2003
+     *                   Bertoli Marco 04-giu-2005
+     */
+    public JmtCell(String icon, Object userObject) {
+        super(userObject);
+        ImageIcon ico = JMTImageLoader.loadImage(icon);
+        // Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+        // Display a lock if this cell is pinned.
+        if (isPinned()) {
+            ImageIcon lockIcon = JMTImageLoader.loadImage("lock", new Dimension(16, 16));
+            GraphConstants.setIcon(attributes, new MergedIcon(JMTImageLoader.loadImage(icon), lockIcon));
+        } else {
+            GraphConstants.setIcon(attributes, ico);
+        }
+        imageDimension = new Dimension(ico.getIconWidth(), ico.getIconHeight());
+        GraphConstants.setSizeable(attributes, false);
+        GraphConstants.setSize(attributes, imageDimension);
+    }
 
-	// Giuseppe De Cicco & Fabio Granara
-	public void SubIn() {
-		in -= 1;
-	}
+    // Giuseppe De Cicco & Fabio Granara
+    public void AddIn() {
+        in += 1;
+    }
 
-	// Giuseppe De Cicco & Fabio Granara
-	public void AddOut() {
-		out += 1;
-	}
+    // Giuseppe De Cicco & Fabio Granara
+    public void SubIn() {
+        in -= 1;
+    }
 
-	// Giuseppe De Cicco & Fabio Granara
-	public void SubOut() {
-		out -= 1;
-	}
+    // Giuseppe De Cicco & Fabio Granara
+    public void AddOut() {
+        out += 1;
+    }
 
-	/**
-	 * Returns Cell's real size (this method considers Icon and name size)
-	 *
-	 * @param graph <code>JGraph</code> object to retrieve font dimension informations
-	 * @return cell's real size
-	 *
-	 * Bertoli Marco  4-giu-2005
-	 */
-	public Dimension getSize(JGraph graph) {
-		Dimension cellDimension = (Dimension) imageDimension.clone();
-		// Gets the graph font
-		Font font = graph.getFont();
-		// Gets the graphical context
-		Graphics2D g2D = (Graphics2D) graph.getGraphics();
-		// Gets the bounds of the cell name
-		FontRenderContext frc = g2D.getFontRenderContext();
-		Rectangle r = font.getStringBounds(getUserObject().toString(), frc).getBounds();
-		// Sets the cell dimension
-		cellDimension.height += r.height + 5;
-		cellDimension.width = Math.max(cellDimension.width, r.width + 10);
-		return cellDimension;
-	}
+    // Giuseppe De Cicco & Fabio Granara
+    public void SubOut() {
+        out -= 1;
+    }
 
-	/**
-	 * Creates the ports for this vertex
-	 *
-	 * @return array of ports
-	 */
-	public abstract Port[] createPorts();
+    public int numInEdges() {
+        return in;
+    }
 
-	/**
-	 * Sets all the attributes like background colour, dimensions, port number
-	 * & position
-	 *
-	 * @param pt
-	 * @return created map
-	 */
-	public Hashtable<Object, Map> setAttributes(Point2D pt, JGraph graph) {
-		//contains attribute of the cell & ports
-		Hashtable<Object, Map> nest = new Hashtable<Object, Map>();
+    public int numOutEdges() {
+        return out;
+    }
 
-		Dimension cellDimension = getSize(graph);
-		//contains attrib of cell
-		Map attr = getAttributes();
-		GraphConstants.setBounds(attr, new Rectangle2D.Double(pt.getX(), pt.getY(), cellDimension.getWidth(), cellDimension.getHeight()));
-		GraphConstants.setEditable(attr, false);
-		GraphConstants.setBackground(attr, graph.getBackground());
-		nest.put(this, attr);
+    // Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+    public boolean isPinned() {
+        return ((CellComponent) getUserObject()).isPinned();
+    }
 
-		//create ports
-		ports = createPorts();
-		Icon icon = GraphConstants.getIcon(attr);
-		updatePortPositions(nest, icon, cellDimension);
-		for (Port port : ports) {
-			add((DefaultPort) port);
-		}
-		return nest;
-	}
+    /**
+     * Returns Cell's real size (this method considers Icon and name size)
+     *
+     * @param graph <code>JGraph</code> object to retrieve font dimension informations
+     * @return cell's real size
+     * <p>
+     * Bertoli Marco  4-giu-2005
+     */
+    public Dimension getSize(JGraph graph) {
+        Dimension cellDimension = (Dimension) imageDimension.clone();
+        // Gets the graph font
+        Font font = graph.getFont();
+        // Gets the graphical context
+        Graphics2D g2D = (Graphics2D) graph.getGraphics();
+        // Gets the bounds of the cell name
+        FontRenderContext frc = g2D.getFontRenderContext();
+        Rectangle r = font.getStringBounds(getUserObject().toString(), frc).getBounds();
+        // Sets the cell dimension
+        cellDimension.height += r.height + 5;
+        cellDimension.width = Math.max(cellDimension.width, r.width + 10);
+        return cellDimension;
+    }
 
-	public void updatePortPositions(Map<Object, Map> nest, Icon icon, Dimension cellDimension) {
-		for (Port port : ports) {
-			Map attr = new Hashtable();
-			if (port instanceof InputPort && isLeftInputCell() || port instanceof OutputPort && !isLeftInputCell()) {
-				GraphConstants.setOffset(attr, getInPortOffset(icon, cellDimension));
-			} else {
-				GraphConstants.setOffset(attr, getOutPortoffset(icon, cellDimension));
-			}
-			nest.put(port, attr);
-		}
-	}
+    /**
+     * Creates the ports for this vertex
+     *
+     * @return array of ports
+     */
+    public abstract Port[] createPorts();
 
-	protected Point getInPortOffset(Icon icon, Dimension cellDimension) {
-		int iconHeight = icon.getIconHeight();
-		int iconWidth = icon.getIconWidth();
-		int xOff = (cellDimension.width - iconWidth) / 2 * 1000 / cellDimension.width;
-		int yOff = iconHeight / 2 * 1000 / cellDimension.height;
-		return new Point(xOff, yOff);
-	}
+    /**
+     * Sets all the attributes like background colour, dimensions, port number
+     * & position
+     *
+     * @param pt
+     * @return created map
+     */
+    public Hashtable<Object, Map> setAttributes(Point2D pt, JGraph graph) {
+        //contains attribute of the cell & ports
+        Hashtable<Object, Map> nest = new Hashtable<Object, Map>();
 
-	protected Point getOutPortoffset(Icon icon, Dimension cellDimension) {
-		int iconHeight = icon.getIconHeight();
-		int iconWidth = icon.getIconWidth();
-		int xOff = (cellDimension.width - iconWidth) / 2 * 1000 / cellDimension.width + iconWidth * 1000 / cellDimension.width;
-		int yOff = iconHeight / 2 * 1000 / cellDimension.height;
-		return new Point(xOff, yOff);
-	}
+        Dimension cellDimension = getSize(graph);
+        //contains attrib of cell
+        Map attr = getAttributes();
+        GraphConstants.setBounds(attr, new Rectangle2D.Double(pt.getX(), pt.getY(), cellDimension.getWidth(), cellDimension.getHeight()));
+        GraphConstants.setEditable(attr, false);
+        GraphConstants.setBackground(attr, graph.getBackground());
+        nest.put(this, attr);
 
-	/**
-	 * Tells if the InputPort of this cell is on the left side
-	 * @return true if the InputPort of this cell is on the left side
-	 */
-	// Giuseppe De Cicco & Fabio Granara
-	public boolean isLeftInputCell() {
-		return leftInputCell;
-	}
+        //create ports
+        ports = createPorts();
+        Icon icon = GraphConstants.getIcon(attr);
+        updatePortPositions(nest, icon, cellDimension);
+        for (Port port : ports) {
+            add((DefaultPort) port);
+        }
 
-	// Giuseppe De Cicco & Fabio Granara
-	public void setLeftInputCell(boolean state) {
-		leftInputCell = state;
-	}
+        return nest;
+    }
 
-	/**
-	 * Resets stored parent information for this cell
-	 */
-	public void resetParent() {
-		parentRef = getParent();
-	}
+    public void updatePortPositions(Map<Object, Map> nest, Icon icon, Dimension cellDimension) {
+        for (Port port : ports) {
+            Map attr = new Hashtable();
+            if (port instanceof InputPort && isLeftInputCell() || port instanceof OutputPort && !isLeftInputCell()) {
+                GraphConstants.setOffset(attr, getInPortOffset(icon, cellDimension));
+            } else {
+                Point offset = getOutPortoffset(icon, cellDimension);
+                GraphConstants.setOffset(attr, offset);
+            }
+            nest.put(port, attr);
+        }
+    }
 
-	/**
-	 * Tells if this cell parent was changed since last call to resetParent() method
-	 *
-	 * @return true if parent changed, false otherwise
-	 * @see #resetParent()
-	 */
-	public boolean parentChanged() {
-		if (parentRef == null && getParent() == null) {
-			return false;
-		} else if (parentRef == null || getParent() == null) {
-			return true;
-		} else {
-			return !parentRef.equals(getParent());
-		}
-	}
+    protected Point getInPortOffset(Icon icon, Dimension cellDimension) {
+        int iconHeight = icon.getIconHeight();
+        int iconWidth = icon.getIconWidth();
+        int xOff = (cellDimension.width - iconWidth) / 2 * 1000 / cellDimension.width;
+        int yOff = iconHeight / 2 * 1000 / cellDimension.height;
+        return new Point(xOff, yOff);
+    }
 
-	/**
-	 * Tells if this station generates or destroys jobs (useful for blocking region
-	 * management)
-	 *
-	 * @return true if this station generates or destroy jobs, false otherwise
-	 */
-	public boolean generateOrDestroyJobs() {
-		return false;
-	}
+    protected Point getOutPortoffset(Icon icon, Dimension cellDimension) {
+        int iconHeight = icon.getIconHeight();
+        int iconWidth = icon.getIconWidth();
+        int xOff = (cellDimension.width - iconWidth) / 2 * 1000 / cellDimension.width + iconWidth * 1000 / cellDimension.width;
+        int yOff = iconHeight / 2 * 1000 / cellDimension.height;
+        return new Point(xOff, yOff);
+    }
 
-	/**
-	 * Returns previous parent of this cell (the one present when resetParent()
-	 * method was called)
-	 *
-	 * @return previous parent of this cell
-	 * @see #resetParent()
-	 */
-	public TreeNode getPrevParent() {
-		return parentRef;
-	}
+    /**
+     * Tells if the InputPort of this cell is on the left side
+     *
+     * @return true if the InputPort of this cell is on the left side
+     */
+    // Giuseppe De Cicco & Fabio Granara
+    public boolean isLeftInputCell() {
+        return leftInputCell;
+    }
 
-	/**
-	 * Returns the name of the icon of this cell
-	 *
-	 * @return the name of the icon of this cell
-	 */
-	public abstract String getIcon();
+    // Giuseppe De Cicco & Fabio Granara
+    public void setLeftInputCell(boolean state) {
+        leftInputCell = state;
+    }
 
+    /**
+     * Resets stored parent information for this cell
+     */
+    public void resetParent() {
+        parentRef = getParent();
+    }
+
+    /**
+     * Tells if this cell parent was changed since last call to resetParent() method
+     *
+     * @return true if parent changed, false otherwise
+     * @see #resetParent()
+     */
+    public boolean parentChanged() {
+        if (parentRef == null && getParent() == null) {
+            return false;
+        } else if (parentRef == null || getParent() == null) {
+            return true;
+        } else {
+            return !parentRef.equals(getParent());
+        }
+    }
+
+    /**
+     * Tells if this station generates or destroys jobs (useful for blocking region
+     * management)
+     *
+     * @return true if this station generates or destroy jobs, false otherwise
+     */
+    public boolean generateOrDestroyJobs() {
+        return false;
+    }
+
+    /**
+     * Returns previous parent of this cell (the one present when resetParent()
+     * method was called)
+     *
+     * @return previous parent of this cell
+     * @see #resetParent()
+     */
+    public TreeNode getPrevParent() {
+        return parentRef;
+    }
+
+    /**
+     * Returns the name of the icon of this cell
+     *
+     * @return the name of the icon of this cell
+     */
+    public abstract String getIcon();
 }
Index: src/main/java/jmt/gui/jsimgraph/JGraphMod/JmtEdge.java
===================================================================
--- src/main/java/jmt/gui/jsimgraph/JGraphMod/JmtEdge.java	(revision 978)
+++ src/main/java/jmt/gui/jsimgraph/JGraphMod/JmtEdge.java	(working copy)
@@ -47,6 +47,18 @@
  * 
  */
 public class JmtEdge extends DefaultEdge {
+
+	/*
+	 * Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+	 * Identifies the type of edge, useful for routing purposes.
+	 */
+	public enum Type {
+		INVALID,
+		LOOP_BACK_UPPER,
+		LEFT_TO_RIGHT,
+		LOOP_BACK_LOWER
+	};
+
 	/**
 	 * 
 	 */
@@ -69,6 +81,14 @@
 	private Mediator mediator;
 	public ArrayList<Point2D> intersectionEdgePoint = new ArrayList<Point2D>();
 
+	/*
+	 * Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+	 * Stores the last routing points computed by the algorithm in class JmtRouting
+	 */
+	private List<Point2D> routedPoints = new ArrayList<>();
+
+	private Type type = Type.INVALID;
+
 	//    public ArrayList intersectionEdgePoint2=new ArrayList();
 
 	public JmtEdge() {
@@ -767,4 +787,38 @@
 		return (int) (max - boundsSource.getMaxX());
 	}
 
+	/*
+	 * Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+	 * Sets new routing points for this edge
+	 */
+	public void setRoutedPoints(List<Point2D> points) {
+		routedPoints.clear();
+		routedPoints.addAll(points);
+	}
+
+	/*
+	 * Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+	 * Gets last computed routing points for this edge
+	 */
+	public List<Point2D> getRoutedPoints() {
+		return routedPoints;
+	}
+
+	/*
+	 * Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+	 * Sets new edge type for this JmtEdge
+	 */
+	public void setType(Type newType) {
+		type = newType;
+	}
+
+	/*
+	 * Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+	 * Gets the edge type for this JmtEdge
+	 */
+	public Type getType() {
+		return type;
+	}
+
+
 }
Index: src/main/java/jmt/gui/jsimgraph/JGraphMod/JmtJGraph.java
===================================================================
--- src/main/java/jmt/gui/jsimgraph/JGraphMod/JmtJGraph.java	(revision 978)
+++ src/main/java/jmt/gui/jsimgraph/JGraphMod/JmtJGraph.java	(working copy)
@@ -27,13 +27,7 @@
 import org.freehep.graphics2d.VectorGraphics;
 import org.freehep.graphicsbase.util.export.ExportDialog;
 import org.jgraph.JGraph;
-import org.jgraph.graph.BasicMarqueeHandler;
-import org.jgraph.graph.CellView;
-import org.jgraph.graph.DefaultCellViewFactory;
-import org.jgraph.graph.DefaultGraphModel;
-import org.jgraph.graph.DefaultGraphSelectionModel;
-import org.jgraph.graph.GraphLayoutCache;
-import org.jgraph.graph.GraphModel;
+import org.jgraph.graph.*;
 
 /** Jmt version of JGraph.
 
@@ -167,6 +161,30 @@
 		return null;
 	}
 
+	// Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+	/** Gets a free inport port for the cell under Point(x,y), if this doesn't exists, a new one it is created
+	 * @param x  horizontal coordinate
+	 * @param y  vertical coordinate
+	 * @return the inport port if available else null
+	 */
+	public InputPort getFreeInPortAt(int x, int y) {
+		JmtCell cell = getVertexAt(x, y);
+		for (int i = 0; i < getModel().getChildCount(cell); i++) {
+			Object child = getModel().getChild(cell, i);
+			if (child instanceof InputPort && ((InputPort) child).getEdges().size() == 0) {
+				return (InputPort) child;
+			}
+		}
+		if (cell != null) {
+			InputPort newPort = new InputPort(cell);
+			cell.insert(newPort, cell.getChildCount() - 1);
+			cell.AddIn();
+			getGraphLayoutCache().putMapping(newPort, new PortView(newPort));
+			return newPort;
+		}
+		return null;
+	}
+
 	/** Gets the outport port for the cell under Point(x,y)
 	 *
 	 * @param x  horizontal coordinate
@@ -242,6 +260,31 @@
 		Defaults.save();
 	}
 
+	// Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+	/** Gets a free output port for the cell under Point(x,y), if this doesn't exists, a new one it is created
+	 *
+	 * @param x  horizontal coordinate
+	 * @param y  vertical coordinate
+	 * @return the outport port if available else null
+	 */
+	public OutputPort getFreeOutPortAt(int x, int y) {
+		JmtCell cell = getVertexAt(x, y);
+		for (int i = 0; i < getModel().getChildCount(cell); i++) {
+			Object child = getModel().getChild(cell, i);
+			if (child instanceof OutputPort && ((OutputPort) child).getEdges().size() == 0) {
+				return (OutputPort) child;
+			}
+		}
+		if (cell != null) {
+			OutputPort newPort = new OutputPort(cell);
+			cell.insert(newPort, cell.getChildCount() - 1);
+			cell.AddOut();
+			getGraphLayoutCache().putMapping(newPort, new PortView(newPort));
+			return newPort;
+		}
+		return null;
+	}
+
 	// ------------------------------------------------------------------------------------------
 
 }
Index: src/main/java/jmt/gui/jsimgraph/JGraphMod/JmtRouting.java
===================================================================
--- src/main/java/jmt/gui/jsimgraph/JGraphMod/JmtRouting.java	(revision 978)
+++ src/main/java/jmt/gui/jsimgraph/JGraphMod/JmtRouting.java	(working copy)
@@ -18,18 +18,22 @@
 
 package jmt.gui.jsimgraph.JGraphMod;
 
+import java.awt.*;
 import java.awt.geom.Point2D;
 import java.awt.geom.Rectangle2D;
-import java.util.ArrayList;
+import java.lang.reflect.InvocationTargetException;
+import java.util.*;
 import java.util.List;
 
-import org.jgraph.graph.CellView;
-import org.jgraph.graph.DefaultPort;
-import org.jgraph.graph.Edge;
-import org.jgraph.graph.EdgeView;
-import org.jgraph.graph.GraphConstants;
-import org.jgraph.graph.PortView;
+import jdk.internal.util.xml.impl.Input;
+import jmt.gui.common.JMTImageLoader;
+import jmt.gui.jsimgraph.controller.Mediator;
+import org.jgraph.graph.*;
 
+import javax.print.attribute.standard.Media;
+import javax.swing.*;
+
+
 /**
 
  * @author Federico Granata
@@ -38,9 +42,58 @@
 
  * Heavily modified by Bertoli Marco to support JGraph 5.8 - 21/mar/2006
  * Heavily modified by De Cicco Giuseppe & Fabio Granara to new JmtRouting - 23/sett/2006
+ * Heavily modified by Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio for supporting multiple incoming/outgoing edges for the same component - 30/Jan/2017
  */
 public class JmtRouting implements Edge.Routing {
 
+	// Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+	Mediator mediator;
+
+	// Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+	/*
+	 * Class that represents an interval between two numbers.
+	 */
+	class Interval {
+		private double lower;
+		private double upper;
+
+		public Interval(double b1, double b2) {
+			lower = b1 <= b2 ? b1 : b2;
+			upper = b1 <= b2 ? b2 : b1;
+		}
+
+		/**
+		 * Checks if a value is contained in this interval
+		 * @param p The value to test
+		 * @return True if the value is contained
+		 */
+		public boolean contains(double p) {
+			return p >= lower && p <= upper;
+		}
+	}
+
+	// Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+	// User-defined predicate to apply on a generic element
+	interface Predicate<T> {
+		boolean evaluate(T v);
+	}
+
+	// Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+	// Partitions a list into two sublists, one containing the elements that satisfy a given predicate and another list with the rest of the elements.
+	static <T> Map<Boolean, List<T>> partition(Predicate<T> predicate, List<T> collection) {
+		Map<Boolean, List<T>> result = new HashMap<>();
+		try {
+			result.put(true, collection.getClass().getConstructor().newInstance());
+			result.put(false, collection.getClass().getConstructor().newInstance());
+			for (T v: collection) {
+				result.get(predicate.evaluate(v)).add(v);
+			}
+		} catch (InstantiationException | IllegalAccessException | InvocationTargetException | NoSuchMethodException e) {
+			e.printStackTrace();
+		}
+		return result;
+	}
+
 	private static final long serialVersionUID = 1L;
 	private int offset = 15; //offset per il source
 	private int offsetTo2 = -15; //offset per il target
@@ -65,20 +118,20 @@
 
 			Point2D[] routed;
 			int offset = this.offset;
-			int changeoff = edge.getOffset();
+//			int changeoff = edge.getOffset();
 
 			int offsetTo2 = this.offsetTo2;
 			//int ringOffset=8;
-			Rectangle2D sourceBounds = (Rectangle2D) source.getAttributes().get("bounds");
-			Rectangle2D targetBounds = (Rectangle2D) target.getAttributes().get("bounds");
+			final Rectangle2D sourceBounds = (Rectangle2D) source.getAttributes().get("bounds");
+			final Rectangle2D targetBounds = (Rectangle2D) target.getAttributes().get("bounds");
 
 			//System.out.println("Punto del from: "+ from.getX()+", punto del bound: "+sourceBounds.getMaxX());
 			int boundFrom = (int) (sourceBounds.getCenterX() + (sourceBounds.getWidth() / 2));
 			int boundTo = (int) (targetBounds.getCenterX() - (targetBounds.getWidth() / 2));
-			if (changeoff > 0 && source.isLeftInputCell()) {
+/*			if (changeoff > 0 && source.isLeftInputCell()) {
 				//System.out.println(changeoff);
 				offset = changeoff + 15;
-			}
+			}*/
 			if (!source.isLeftInputCell()) {
 				offset = -offset;
 				//ringOffset=-ringOffset;
@@ -102,6 +155,7 @@
 
 			} else {
 				//the source is on the left of the target
+				edge.setType(JmtEdge.Type.LEFT_TO_RIGHT);
 				if ((int) from.getY() == (int) to.getY()
 						&& ((boundFrom < boundTo && offset > 0 && offsetTo2 < 0) || (boundFrom > boundTo && offset < 0 && offsetTo2 > 0))) {
 					list.add(from);
@@ -110,10 +164,10 @@
 				}
 				if ((((boundTo - boundFrom) > offset * (1.1)) && (offset > 0 && offsetTo2 < 0))
 						|| (((boundFrom - boundTo) > (-offset * (1.1))) && (offset < 0 && offsetTo2 > 0))) {
+
 					routed = new Point2D[2];
 					routed[0] = new Point2D.Double(boundFrom + offset, from.getY());
 					routed[1] = new Point2D.Double(routed[0].getX(), to.getY());
-
 				}
 				//____________inizio
 				else if ((offset < 0 && offsetTo2 < 0)) {
@@ -188,14 +242,78 @@
 				} else {
 
 					if ((from.getY() + sourceBounds.getHeight() - 4) < (to.getY() - (targetBounds.getHeight() / 2))) {
+						// Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+						// this code is similar to the else case, with suitable changes.
+						// edge going from right to left circumventing the model on the upper side
+						edge.setType(JmtEdge.Type.LOOP_BACK_UPPER);
 						routed = new Point2D[4];
 						routed[0] = new Point2D.Double(boundFrom + offset, from.getY());
 						routed[3] = new Point2D.Double(boundTo + (offsetTo2), to.getY());
-						double maxY = sourceBounds.getMaxY() + 20;
-						routed[1] = new Point2D.Double(routed[0].getX(), maxY);
-						routed[2] = new Point2D.Double(routed[3].getX(), maxY);
+						//double maxY = sourceBounds.getMaxY() + 20;
+
+						// Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+						// Compute the y coordinate of the loop back edge taking into account other edges of the same type,
+						// in order to avoid overlapping lines.
+						List<OutputPort> outPorts = new ArrayList<>();
+						Enumeration ports = source.children();
+
+						while (ports.hasMoreElements()) {
+							Object port = ports.nextElement();
+							if (port instanceof OutputPort) {
+								outPorts.add((OutputPort) port);
+							}
+						}
+
+						double minY;
+						if (outPorts.size() > 1) {
+							Map<Boolean, List<OutputPort>> parts = partition(new Predicate<OutputPort>() {
+								@Override
+								public boolean evaluate(OutputPort v) {
+									JmtEdge e = (JmtEdge) (v.getEdges().iterator().next());
+									JmtCell thisTarget = (JmtCell) ((InputPort) e.getTarget()).getParent();
+									Rectangle2D thisTargetBounds = (Rectangle2D) thisTarget.getAttributes().get("bounds");
+									return thisTargetBounds.getX() > targetBounds.getX() && thisTargetBounds.getX() < sourceBounds.getX();
+								}
+							}, outPorts);
+							minY = Math.min(sourceBounds.getMinY() - 30 * (parts.get(true).size() + 1), targetBounds.getMinY() - 30);
+						} else {
+							minY = Math.min(sourceBounds.getMinY() - 30, targetBounds.getMinY() - 36);
+						}
+
+						routed[1] = new Point2D.Double(routed[0].getX(), minY);
+						routed[2] = new Point2D.Double(routed[3].getX(), minY);
+						if (offset > 0) {
+							double x;
+							double left = sourceBounds.getX() - offset - 4;
+							x = Math.min(routed[2].getX(), left);
+							routed[2].setLocation(x, routed[2].getY());
+							routed[3].setLocation(x, routed[3].getY());
+
+							if (from.getY() < to.getY()) {
+								double x2;
+								double right = targetBounds.getX() + targetBounds.getWidth() + offset;
+								x2 = Math.max(routed[0].getX(), right);
+								routed[0].setLocation(x2, routed[0].getY());
+								routed[1].setLocation(x2, routed[1].getY());
+							}
+						} else {
+							double x;
+							double left = sourceBounds.getX() + sourceBounds.getWidth() + offset + 4;
+							x = Math.max(routed[2].getX(), left);
+							routed[2].setLocation(x, routed[2].getY());
+							routed[3].setLocation(x, routed[3].getY());
+
+							if (from.getY() < to.getY()) {
+								double x2;
+								double left2 = targetBounds.getX() - offset;
+								x2 = Math.min(routed[0].getX(), left2);
+								routed[0].setLocation(x2, routed[0].getY());
+								routed[1].setLocation(x2, routed[1].getY());
+							}
+						}
 					} else {
-
+						// edge going from right to left circumventing the model on the lower side
+						edge.setType(JmtEdge.Type.LOOP_BACK_LOWER);
 						routed = new Point2D[4];
 						routed[0] = new Point2D.Double(boundFrom + offset, from.getY());
 						//System.out.println("Differenza "+ (sourceBounds.getMaxY()-(routed[0].getY() + sourceBounds.getBounds().getHeight()+2)));
@@ -202,7 +320,36 @@
 						routed[3] = new Point2D.Double(boundTo + offsetTo2, to.getY());
 						//double maxY = Math.max(routed[0].getY() + sourceBounds.getBounds().getHeight()+2,
 						//		routed[3].getY() + targetBounds.getBounds().getHeight()+8);
-						double maxY = Math.max(sourceBounds.getMaxY() + 20, targetBounds.getMaxY() + 26);
+
+						// Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+						// Compute the y coordinate of the loop back edge taking into account other edges of the same type,
+						// in order to avoid overlapping lines.
+						List<OutputPort> outPorts = new ArrayList<>();
+						Enumeration ports = source.children();
+
+						while (ports.hasMoreElements()) {
+							Object port = ports.nextElement();
+							if (port instanceof OutputPort) {
+								outPorts.add((OutputPort) port);
+							}
+						}
+
+						double maxY;
+						if (outPorts.size() > 1) {
+							Map<Boolean, List<OutputPort>> parts = partition(new Predicate<OutputPort>() {
+								@Override
+								public boolean evaluate(OutputPort v) {
+									JmtEdge e = (JmtEdge) (v.getEdges().iterator().next());
+									JmtCell thisTarget = (JmtCell) ((InputPort) e.getTarget()).getParent();
+									Rectangle2D thisTargetBounds = (Rectangle2D) thisTarget.getAttributes().get("bounds");
+									return thisTargetBounds.getX() > targetBounds.getX() && thisTargetBounds.getX() < sourceBounds.getX();
+								}
+							}, outPorts);
+							maxY = Math.max(sourceBounds.getMaxY() + 20 * (parts.get(true).size() + 1), targetBounds.getMaxY() + 26);
+						} else {
+							maxY = Math.max(sourceBounds.getMaxY() + 20, targetBounds.getMaxY() + 26);
+						}
+
 						routed[1] = new Point2D.Double(routed[0].getX(), maxY);
 						routed[2] = new Point2D.Double(routed[3].getX(), maxY);
 
@@ -238,18 +385,438 @@
 					}
 				}
 			}
+
+			// Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+			// Adjust outport ports and this edge offsets w.r.t. component's border based on specific criteria
+			double startY = from.getY();
+			{
+				Icon i = JMTImageLoader.loadImage(source.getIcon());
+				Dimension d = source.getSize(mediator.getGraph());
+				// Handle multiple outgoing edges from the same JmtCell
+				Dimension sourceSize = (Dimension) source.getAttributes().get("size");
+
+				List<OutputPort> outPorts = new ArrayList<>();
+				Enumeration ports = source.children();
+
+				while (ports.hasMoreElements()) {
+					Object port = ports.nextElement();
+					if (port instanceof OutputPort) {
+						outPorts.add((OutputPort) port);
+					}
+				}
+
+				// Calculate space between ports/edges based on #number of outgoing edges + 1
+				double division = sourceSize.getHeight() / (source.numOutEdges() + 1.0);
+				double divisionOffset = source.getOutPortoffset(i, d).getY() * 2 / (source.numOutEdges() + 1.0);
+
+				// The whole list is partitioned in three sub lists one for each type of edge
+				// For each sublist a different order criteria is applied.
+				Map<Boolean, List<OutputPort>> parts = partition(new Predicate<OutputPort>() {
+					@Override
+					public boolean evaluate(OutputPort v) {
+						if (v.getEdges().size() > 0) {
+							JmtEdge e = (JmtEdge) (v.getEdges().iterator().next());
+							return e.getType() == JmtEdge.Type.LOOP_BACK_UPPER;
+						}
+						return false;
+					}
+				}, outPorts);
+
+				List<OutputPort> portsLoopBackUpper = parts.get(true);
+
+				// The more the port has lower y offset the more the destination component is near the source one.
+				Collections.sort(portsLoopBackUpper, new Comparator<OutputPort>() {
+					@Override
+					public int compare(OutputPort o1, OutputPort o2) {
+						JmtEdge e1 = (JmtEdge) (o1.getEdges().iterator().next());
+						JmtEdge e2 = (JmtEdge) (o2.getEdges().iterator().next());
+
+						JmtCell c1 = (JmtCell) ((InputPort) e1.getTarget()).getParent();
+						JmtCell c2 = (JmtCell) ((InputPort) e2.getTarget()).getParent();
+
+						return (int) Math.ceil(((Rectangle2D) c2.getAttributes().get("bounds")).getMaxX() - ((Rectangle2D) c1.getAttributes().get("bounds")).getMaxX());
+					}
+				});
+
+				parts = partition(new Predicate<OutputPort>() {
+					@Override
+					public boolean evaluate(OutputPort v) {
+						if (v.getEdges().size() > 0) {
+							JmtEdge e = (JmtEdge) (v.getEdges().iterator().next());
+							return e.getType() == JmtEdge.Type.LEFT_TO_RIGHT;
+						}
+						return false;
+					}
+				}, parts.get(false));
+
+				List<OutputPort> portsLeftToRight = parts.get(true);
+
+				// The more the port has lower y offset, the more the destination component has lower y coordinate.
+				Collections.sort(portsLeftToRight, new Comparator<OutputPort>() {
+					@Override
+					public int compare(OutputPort o1, OutputPort o2) {
+						JmtEdge e1 = (JmtEdge) (o1.getEdges().iterator().next());
+						JmtEdge e2 = (JmtEdge) (o2.getEdges().iterator().next());
+
+						JmtCell c1 = (JmtCell) ((InputPort) e1.getTarget()).getParent();
+						JmtCell c2 = (JmtCell) ((InputPort) e2.getTarget()).getParent();
+
+						return (int) Math.ceil(((Rectangle2D) c1.getAttributes().get("bounds")).getMaxY() - ((Rectangle2D) c2.getAttributes().get("bounds")).getMaxY());
+					}
+				});
+
+				parts = partition(new Predicate<OutputPort>() {
+					@Override
+					public boolean evaluate(OutputPort v) {
+						if (v.getEdges().size() > 0) {
+							JmtEdge e = (JmtEdge) (v.getEdges().iterator().next());
+							return e.getType() == JmtEdge.Type.LOOP_BACK_LOWER;
+						}
+						return false;
+					}
+				}, parts.get(false));
+
+				List<OutputPort> portsLoopBackLower = parts.get(true);
+
+				// The more the porr has greater y offset the more the destination component is near the source one.
+				Collections.sort(portsLoopBackLower, new Comparator<OutputPort>() {
+					@Override
+					public int compare(OutputPort o1, OutputPort o2) {
+						JmtEdge e1 = (JmtEdge) (o1.getEdges().iterator().next());
+						JmtEdge e2 = (JmtEdge) (o2.getEdges().iterator().next());
+
+						JmtCell c1 = (JmtCell) ((InputPort) e1.getTarget()).getParent();
+						JmtCell c2 = (JmtCell) ((InputPort) e2.getTarget()).getParent();
+
+						return (int) Math.ceil(((Rectangle2D) c1.getAttributes().get("bounds")).getMaxX() - ((Rectangle2D) c2.getAttributes().get("bounds")).getMaxX());
+					}
+				});
+
+				// Rebuild the outport list in this exact order, so to minimize intersections between outgoing edges.
+				outPorts.clear();
+				outPorts.addAll(portsLoopBackUpper);
+				outPorts.addAll(portsLeftToRight);
+				outPorts.addAll(portsLoopBackLower);
+
+				for (int index = 0; index < outPorts.size(); index++) {
+					OutputPort outPort = outPorts.get(index);
+					JmtEdge outEdge = (JmtEdge) (outPort.getEdges().iterator().next());
+					JmtCell targetO = (JmtCell) ((InputPort) outEdge.getTarget()).getParent();
+					if (targetO == target) {
+						// We have found the index in the outport array for this edge, adjusts its offset.
+						startY = sourceBounds.getMinY() + (division * (index + 1));
+						routed[0].setLocation(routed[0].getX(), startY);
+					}
+
+					// If the component is rotated, the x offset must be changed accordingly.
+					Point2D portOffset = source.isLeftInputCell() ? source.getOutPortoffset(i, d) : source.getInPortOffset(i, d);
+					// Adjust offset of each port, if the attribute doesn't exist, create a new one.
+					if (outPort.getAttributes().get("offset") != null) {
+						((Point2D.Double) outPort.getAttributes().get("offset")).setLocation(portOffset.getX(), divisionOffset * (index + 1));
+					} else {
+						outPort.getAttributes().put("offset", new Point2D.Double(portOffset.getX(), divisionOffset * (index + 1)));
+					}
+				}
+
+				if (outPorts.size() > 1) {
+					// check if other edges that start from the same source component overlap this edge along their way
+					boolean needRecompute = true;
+					while (needRecompute) {
+						needRecompute = false;
+						for (int index = 0; index < outPorts.size(); index++) {
+							OutputPort outPort = outPorts.get(index);
+							// handle corner cases
+							if (outPort.getEdges().size() == 0) {
+								continue;
+							}
+
+							// we have found the same edge that we are routing
+							JmtEdge otherEdge = (JmtEdge) outPort.getEdges().iterator().next();
+							if (((DefaultPort) otherEdge.getSource()).getParent() == source && ((DefaultPort)otherEdge.getTarget()).getParent() == target) {
+								continue;
+							}
+
+							// Check this other edge with the one that we are routing by iterating over their (routed) points
+							List<Point2D> otherPoints = otherEdge.getRoutedPoints();
+							for (int ir = 0; ir < (routed.length - 1); ir++) {
+								int dir;
+								if (routed[ir].getY() == routed[ir + 1].getY()) {
+									dir = 1; // Horizontal direction
+								} else {
+									dir = 2; // Vertical direction
+								}
+								for (int io = 0; io < (otherPoints.size() - 1); io++) {
+									if (dir == 1 && (otherPoints.get(io).getY() == otherPoints.get(io + 1).getY() && (otherPoints.get(io).getY() == routed[ir].getY()))) {
+										// This segments have same directions, let's check if one (or both) point is contained over the routed segment
+										Interval interval = new Interval(routed[ir].getX(), routed[ir + 1].getX());
+										if (interval.contains(otherPoints.get(io).getX()) || interval.contains(otherPoints.get(io + 1).getX())) {
+											// There's overlap, change x coordinate by some amount, we have to discriminate between loop back edges and left-to-right edges.
+											int sign;
+											if (ir > 1 && target.isLeftInputCell()) {
+												sign = -1;
+											} else if (ir > 1 && !target.isLeftInputCell()) {
+												sign = 1;
+											} else if (target.isLeftInputCell()) {
+												sign = 1;
+											} else {
+												sign = -1;
+											}
+
+											routed[ir].setLocation(routed[ir].getX(), routed[ir].getY() + sign * offset);
+											routed[ir + 1].setLocation(routed[ir + 1].getX(), routed[ir + 1].getY() + sign * offset);
+											// We have modified some coordinates, we have to recheck that all the edges don't overlap again
+											needRecompute = true;
+										}
+									} else if (dir == 2 && (otherPoints.get(io).getX() == otherPoints.get(io + 1).getX() && (otherPoints.get(io).getX() == routed[ir].getX()))) {
+										Interval interval = new Interval(routed[ir].getY(), routed[ir + 1].getY());
+										if (interval.contains(otherPoints.get(io).getY()) || interval.contains(otherPoints.get(io + 1).getY())) {
+											int sign;
+											if (ir > 1 && target.isLeftInputCell()) {
+												sign = -1;
+											} else if (ir > 1 && !target.isLeftInputCell()) {
+												sign = 1;
+											} else if (target.isLeftInputCell()) {
+												sign = 1;
+											} else {
+												sign = -1;
+											}
+
+											routed[ir].setLocation(routed[ir].getX() + sign * offset, routed[ir].getY());
+											routed[ir + 1].setLocation(routed[ir + 1].getX() + sign * offset, routed[ir + 1].getY());
+											needRecompute = true;
+										}
+									}
+								}
+							}
+						}
+					}
+				}
+ 			}
+
+			// Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+			// Adjust input ports and this edge offsets w.r.t. component's border based on specific criteria
+			// This is the dual case of the previous one, except for the fact that here we are handling incoming edges and input ports.
+			double finalY = to.getY();
+			{
+				Icon i = JMTImageLoader.loadImage(target.getIcon());
+				Dimension d = target.getSize(mediator.getGraph());
+				// Handle multiple incoming edges to the same JmtCell
+				Dimension targetSize = (Dimension) target.getAttributes().get("size");
+
+				List<InputPort> inPorts = new ArrayList<>();
+				Enumeration ports = target.children();
+
+				while (ports.hasMoreElements()) {
+					Object port = ports.nextElement();
+					if (port instanceof InputPort) {
+						inPorts.add((InputPort) port);
+					}
+				}
+
+				double division = targetSize.getHeight() / (target.numInEdges() + 1.0);
+				double divisionOffset = target.getInPortOffset(i, d).getY() * 2 / (target.numInEdges() + 1.0);
+
+				Map<Boolean, List<InputPort>> parts = partition(new Predicate<InputPort>() {
+					@Override
+					public boolean evaluate(InputPort v) {
+						if (v.getEdges().size() > 0) {
+							JmtEdge e = (JmtEdge) (v.getEdges().iterator().next());
+							return e.getType() == JmtEdge.Type.LOOP_BACK_UPPER;
+						}
+						return false;
+					}
+				}, inPorts);
+
+				List<InputPort> portsLoopBackUpper = parts.get(true);
+
+				Collections.sort(portsLoopBackUpper, new Comparator<InputPort>() {
+					@Override
+					public int compare(InputPort o1, InputPort o2) {
+						JmtEdge e1 = (JmtEdge) (o1.getEdges().iterator().next());
+						JmtEdge e2 = (JmtEdge) (o2.getEdges().iterator().next());
+
+						JmtCell c1 = (JmtCell) ((OutputPort) e1.getSource()).getParent();
+						JmtCell c2 = (JmtCell) ((OutputPort) e2.getSource()).getParent();
+
+						return (int) Math.ceil(((Rectangle2D) c2.getAttributes().get("bounds")).getMaxY() - ((Rectangle2D) c1.getAttributes().get("bounds")).getMaxY());
+					}
+				});
+
+
+				parts = partition(new Predicate<InputPort>() {
+					@Override
+					public boolean evaluate(InputPort v) {
+						if (v.getEdges().size() > 0) {
+							JmtEdge e = (JmtEdge) (v.getEdges().iterator().next());
+							return e.getType() == JmtEdge.Type.LEFT_TO_RIGHT;
+						}
+						return false;
+					}
+				}, parts.get(false));
+
+				List<InputPort> portsLeftToRight = parts.get(true);
+
+				Collections.sort(portsLeftToRight, new Comparator<InputPort>() {
+					@Override
+					public int compare(InputPort o1, InputPort o2) {
+						JmtEdge e1 = (JmtEdge) (o1.getEdges().iterator().next());
+						JmtEdge e2 = (JmtEdge) (o2.getEdges().iterator().next());
+
+						JmtCell c1 = (JmtCell) ((OutputPort) e1.getSource()).getParent();
+						JmtCell c2 = (JmtCell) ((OutputPort) e2.getSource()).getParent();
+
+						return (int) Math.ceil(((Rectangle2D) c1.getAttributes().get("bounds")).getMaxY() - ((Rectangle2D) c2.getAttributes().get("bounds")).getMaxY());
+					}
+				});
+
+				parts = partition(new Predicate<InputPort>() {
+					@Override
+					public boolean evaluate(InputPort v) {
+						if (v.getEdges().size() > 0) {
+							JmtEdge e = (JmtEdge) (v.getEdges().iterator().next());
+							return e.getType() == JmtEdge.Type.LOOP_BACK_LOWER;
+						}
+						return false;
+					}
+				}, parts.get(false));
+
+				List<InputPort> portsLoopBackLower = parts.get(true);
+
+				Collections.sort(portsLoopBackLower, new Comparator<InputPort>() {
+					@Override
+					public int compare(InputPort o1, InputPort o2) {
+						JmtEdge e1 = (JmtEdge) (o1.getEdges().iterator().next());
+						JmtEdge e2 = (JmtEdge) (o2.getEdges().iterator().next());
+
+						JmtCell c1 = (JmtCell) ((OutputPort) e1.getSource()).getParent();
+						JmtCell c2 = (JmtCell) ((OutputPort) e2.getSource()).getParent();
+
+						return (int) Math.ceil(((Rectangle2D) c2.getAttributes().get("bounds")).getMaxY() - ((Rectangle2D) c1.getAttributes().get("bounds")).getMaxY());
+					}
+				});
+
+				inPorts.clear();
+				inPorts.addAll(portsLoopBackUpper);
+				inPorts.addAll(portsLeftToRight);
+				inPorts.addAll(portsLoopBackLower);
+
+				for (int index = 0; index < inPorts.size(); index++) {
+					InputPort inPort = inPorts.get(index);
+					JmtEdge inEdge = (JmtEdge) (inPort.getEdges().iterator().next());
+					JmtCell sourceI = (JmtCell) ((OutputPort) inEdge.getSource()).getParent();
+					if (sourceI == source) {
+						finalY = targetBounds.getMinY() + (division * (index + 1));
+						routed[routed.length - 1] = new Point2D.Double(routed[routed.length - 1].getX(), finalY);
+					}
+
+					Point2D portOffset = target.isLeftInputCell() ? target.getInPortOffset(i, d) : target.getOutPortoffset(i, d);
+					if (inPort.getAttributes().get("offset") != null) {
+						((Point2D.Double) inPort.getAttributes().get("offset")).setLocation(portOffset.getX(), divisionOffset * (index + 1));
+					} else {
+						inPort.getAttributes().put("offset", new Point2D.Double(portOffset.getX(), divisionOffset * (index + 1)));
+					}
+				}
+
+				if (inPorts.size() > 1) {
+					boolean needRecompute = true;
+					while (needRecompute) {
+						needRecompute = false;
+						for (int index = 0; index < inPorts.size(); index++) {
+							InputPort inPort = inPorts.get(index);
+							if (inPort.getEdges().size() == 0) {
+								continue;
+							}
+							JmtEdge otherEdge = (JmtEdge) inPort.getEdges().iterator().next();
+							if (((DefaultPort) otherEdge.getSource()).getParent() == source && ((DefaultPort)otherEdge.getTarget()).getParent() == target) {
+								continue;
+							}
+
+							List<Point2D> otherPoints = otherEdge.getRoutedPoints();
+							for (int ir = 0; ir < (routed.length - 1); ir++) {
+								int dir;
+								if (routed[ir].getY() == routed[ir + 1].getY()) {
+									dir = 1;
+								} else {
+									dir = 2;
+								}
+								for (int io = 0; io < (otherPoints.size() - 1); io++) {
+									if (dir == 1 && (otherPoints.get(io).getY() == otherPoints.get(io + 1).getY() && (otherPoints.get(io).getY() == routed[ir].getY()))) {
+										Interval interval = new Interval(routed[ir].getX(), routed[ir + 1].getX());
+										if (interval.contains(otherPoints.get(io).getX()) || interval.contains(otherPoints.get(io + 1).getX())) {
+											int sign;
+											if (ir > 1 && target.isLeftInputCell()) {
+												sign = -1;
+											} else if (ir > 1 && !target.isLeftInputCell()) {
+												sign = 1;
+											} else if (target.isLeftInputCell()) {
+												sign = 1;
+											} else {
+												sign = -1;
+											}
+											routed[ir].setLocation(routed[ir].getX(), routed[ir].getY() + sign * offset);
+											routed[ir + 1].setLocation(routed[ir + 1].getX(), routed[ir + 1].getY() + sign *offset);
+											needRecompute = true;
+										}
+									} else if (dir == 2 && (otherPoints.get(io).getX() == otherPoints.get(io + 1).getX() && (otherPoints.get(io).getX() == routed[ir].getX()))) {
+										Interval interval = new Interval(routed[ir].getY(), routed[ir + 1].getY());
+										if (interval.contains(otherPoints.get(io).getY()) || interval.contains(otherPoints.get(io + 1).getY())) {
+											int sign;
+											if (ir > 1 && target.isLeftInputCell()) {
+												sign = -1;
+											} else if (ir > 1 && !target.isLeftInputCell()) {
+												sign = 1;
+											} else if (target.isLeftInputCell()) {
+												sign = 1;
+											} else {
+												sign = -1;
+											}
+											routed[ir].setLocation(routed[ir].getX() + sign * offset, routed[ir].getY());
+											routed[ir + 1].setLocation(routed[ir + 1].getX() + sign * offset, routed[ir + 1].getY());
+											needRecompute = true;
+										}
+									}
+								}
+							}
+						}
+					}
+				}
+			}
+
+			/*if (target.isLeftInputCell() && (routed[routed.length - 1].getX() > (targetBounds.getMinX() - offset)) && routed.length > 1 && routed[routed.length - 1] != null && routed[routed.length - 2] != null) {
+				routed[routed.length - 1].setLocation(routed[routed.length - 1].getX() - 2 * Math.max(offset, routed[routed.length - 1].getX() - targetBounds.getMinX()), routed[routed.length - 1].getY());
+
+				Point2D newRouted[] = new Point2D[routed.length + 2];
+				System.arraycopy(routed, 0, newRouted, 0, routed.length - 1);
+				double diffY = Math.abs(routed[routed.length - 2].getY() - routed[routed.length - 1].getY()) * 0.5;
+				if (routed[routed.length - 1].getY() > routed[routed.length - 2].getY()) {
+					// edge is going down
+					newRouted[routed.length - 1] = new Point2D.Double(routed[routed.length - 2].getX(), routed[routed.length - 2].getY() + diffY);
+					newRouted[routed.length] = new Point2D.Double(routed[routed.length - 1].getX(), routed[routed.length - 2].getY() + diffY);
+				} else {
+					newRouted[routed.length - 1] = new Point2D.Double(routed[routed.length - 2].getX(), routed[routed.length - 2].getY() - diffY);
+					newRouted[routed.length] = new Point2D.Double(routed[routed.length - 1].getX(), routed[routed.length - 2].getY() - diffY);
+				}
+
+				newRouted[routed.length + 1] = routed[routed.length - 1];
+
+				routed = newRouted;
+
+			}*/
+
 			//Sets add points
-			list.add(from);
-			for (Point2D element : routed) {
-				list.add(element);
-			}
-			list.add(to);
+			list.add(new Point2D.Double(from.getX(), startY));
+			Collections.addAll(list, routed);
+			list.add(new Point2D.Double(to.getX(), finalY));
+			edge.setRoutedPoints(list);
 		}
 		return list;
 	}
 
+	public void setMediator(Mediator m) {
+		mediator = m;
+	}
+
 	public int getPreferredLineStyle(EdgeView edgeView) {
-
 		return GraphConstants.STYLE_ORTHOGONAL;
 	}
 
Index: src/main/java/jmt/gui/jsimgraph/JGraphMod/SemaphoreCell.java
===================================================================
--- src/main/java/jmt/gui/jsimgraph/JGraphMod/SemaphoreCell.java	(revision 978)
+++ src/main/java/jmt/gui/jsimgraph/JGraphMod/SemaphoreCell.java	(working copy)
@@ -62,6 +62,7 @@
 		ports[0] = new InputPort(this);
 		ports[1] = new OutputPort(this);
 		return ports;
+
 	}
 
 	/**
Index: src/main/java/jmt/gui/jsimgraph/controller/ConnectState.java
===================================================================
--- src/main/java/jmt/gui/jsimgraph/controller/ConnectState.java	(revision 978)
+++ src/main/java/jmt/gui/jsimgraph/controller/ConnectState.java	(working copy)
@@ -64,7 +64,9 @@
 	public void handlePress(MouseEvent e) {
 		if (!e.isConsumed()) {
 			start = mediator.snap(e.getPoint());
-			firstPort = port = getOutPortViewAt(e.getX(), e.getY());
+			// Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+			// Request a (possibly new) free output port
+			firstPort = port = getFreeOutPortViewAt(e.getX(), e.getY());
 			if (firstPort != null) {
 				start = mediator.toScreen(firstPort.getLocation(null));
 			}
@@ -113,7 +115,9 @@
 	@Override
 	public void handleRelease(MouseEvent e) {
 		if (e != null && !e.isConsumed()) {
-			PortView end = getInPortViewAt(e.getX(), e.getY());
+			// Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+			// Request a (possibly new) free input port
+			PortView end = getFreeInPortViewAt(e.getX(), e.getY());
 			if (end != null) {
 				mediator.connect(start, current, end, firstPort);
 				if ((firstPort != null) && ((VertexView) (firstPort.getParentView()) != null)) {
@@ -133,6 +137,17 @@
 		current = null;
 	}
 
+	// Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+	/** gets the first free portView of the input port of the cell at position
+	 *
+	 * @param x
+	 * @param y
+	 * @return portView of the input port
+	 */
+	private PortView getFreeInPortViewAt(int x, int y) {
+		return mediator.getFreeInPortViewAt(x, y);
+	}
+
 	/** gets the first portView of the input port of the cell at position
 	 *
 	 * @param x
@@ -153,6 +168,17 @@
 		return mediator.getOutPortViewAt(x, y);
 	}
 
+	// Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+	/** gets the first free portView of the output port of the cell at position
+	 *
+	 * @param x
+	 * @param y
+	 * @return portView of the output port
+	 */
+	protected PortView getFreeOutPortViewAt(int x, int y) {
+		return mediator.getFreeOutPortViewAt(x, y);
+	}
+
 	public void overlay(Graphics2D g) {
 		if (start != null && current != null) {
 			g.draw(new Line2D.Double(start.getX(), start.getY(), current.getX(), current.getY()));
Index: src/main/java/jmt/gui/jsimgraph/controller/JmtGraphUI.java
===================================================================
--- src/main/java/jmt/gui/jsimgraph/controller/JmtGraphUI.java	(revision 978)
+++ src/main/java/jmt/gui/jsimgraph/controller/JmtGraphUI.java	(working copy)
@@ -142,6 +142,7 @@
 				mediator.enableAddBlockingRegion(!cannotAddBlockingRegion);
 				mediator.enableRotateAction(true);
 				mediator.enableSetRight(true);
+				mediator.enableSnapToGrid(true);
 			} else if (foundBlockingRegion) {
 				mediator.enableCopyAction(true);
 				mediator.enableCutAction(true);
Index: src/main/java/jmt/gui/jsimgraph/controller/Mediator.java
===================================================================
--- src/main/java/jmt/gui/jsimgraph/controller/Mediator.java	(revision 978)
+++ src/main/java/jmt/gui/jsimgraph/controller/Mediator.java	(working copy)
@@ -32,21 +32,14 @@
 import java.awt.geom.Point2D;
 import java.awt.geom.Rectangle2D;
 import java.io.File;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.Hashtable;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-import java.util.Vector;
+import java.io.ObjectInput;
+import java.util.*;
 
-import javax.swing.ImageIcon;
-import javax.swing.JFrame;
-import javax.swing.JOptionPane;
+import javax.swing.*;
 
+import javafx.scene.control.Cell;
+import jdk.internal.util.xml.impl.Input;
+import jmt.commandline.Jmt;
 import jmt.framework.gui.components.JMTMenuBar;
 import jmt.framework.gui.components.JMTToolBar;
 import jmt.framework.gui.image.ImageLoader;
@@ -54,6 +47,7 @@
 import jmt.gui.common.CommonConstants;
 import jmt.gui.common.Defaults;
 import jmt.gui.common.JMTImageLoader;
+import jmt.gui.common.MergedIcon;
 import jmt.gui.common.controller.DispatcherThread;
 import jmt.gui.common.controller.ModelChecker;
 import jmt.gui.common.controller.PADispatcherThread;
@@ -78,56 +72,8 @@
 import jmt.gui.common.xml.ModelLoader;
 import jmt.gui.common.xml.XMLWriter;
 import jmt.gui.jsimgraph.DialogFactory;
-import jmt.gui.jsimgraph.JGraphMod.BlockingRegion;
-import jmt.gui.jsimgraph.JGraphMod.CellComponent;
-import jmt.gui.jsimgraph.JGraphMod.CellFactory;
-import jmt.gui.jsimgraph.JGraphMod.InputPort;
-import jmt.gui.jsimgraph.JGraphMod.JmtCell;
-import jmt.gui.jsimgraph.JGraphMod.JmtDefaultCellViewFactory;
-import jmt.gui.jsimgraph.JGraphMod.JmtEdge;
-import jmt.gui.jsimgraph.JGraphMod.JmtEdgeView;
-import jmt.gui.jsimgraph.JGraphMod.JmtGraphConstants;
-import jmt.gui.jsimgraph.JGraphMod.JmtJGraph;
-import jmt.gui.jsimgraph.JGraphMod.JmtOverlapping;
-import jmt.gui.jsimgraph.JGraphMod.OutputPort;
-import jmt.gui.jsimgraph.JGraphMod.SinkCell;
-import jmt.gui.jsimgraph.JGraphMod.SourceCell;
-import jmt.gui.jsimgraph.controller.actions.About;
-import jmt.gui.jsimgraph.controller.actions.AbstractJmodelAction;
-import jmt.gui.jsimgraph.controller.actions.ActionCopy;
-import jmt.gui.jsimgraph.controller.actions.ActionCut;
-import jmt.gui.jsimgraph.controller.actions.ActionDelete;
-import jmt.gui.jsimgraph.controller.actions.ActionPaste;
-import jmt.gui.jsimgraph.controller.actions.ActionRedo;
-import jmt.gui.jsimgraph.controller.actions.ActionRotate;
-import jmt.gui.jsimgraph.controller.actions.ActionSetRight;
-import jmt.gui.jsimgraph.controller.actions.ActionUndo;
-import jmt.gui.jsimgraph.controller.actions.AddBlockingRegion;
-import jmt.gui.jsimgraph.controller.actions.CloseModel;
-import jmt.gui.jsimgraph.controller.actions.DownloadDefaultTemplates;
-import jmt.gui.jsimgraph.controller.actions.EditDefaults;
-import jmt.gui.jsimgraph.controller.actions.EditMeasures;
-import jmt.gui.jsimgraph.controller.actions.EditPAParams;
-import jmt.gui.jsimgraph.controller.actions.EditSimParams;
-import jmt.gui.jsimgraph.controller.actions.EditUserClasses;
-import jmt.gui.jsimgraph.controller.actions.Exit;
-import jmt.gui.jsimgraph.controller.actions.NewModel;
-import jmt.gui.jsimgraph.controller.actions.OpenHelp;
-import jmt.gui.jsimgraph.controller.actions.OpenModel;
-import jmt.gui.jsimgraph.controller.actions.PauseSimulation;
-import jmt.gui.jsimgraph.controller.actions.SaveModel;
-import jmt.gui.jsimgraph.controller.actions.SaveModelAs;
-import jmt.gui.jsimgraph.controller.actions.SetConnectState;
-import jmt.gui.jsimgraph.controller.actions.SetOptions;
-import jmt.gui.jsimgraph.controller.actions.SetSelectState;
-import jmt.gui.jsimgraph.controller.actions.ShowResults;
-import jmt.gui.jsimgraph.controller.actions.Simulate;
-import jmt.gui.jsimgraph.controller.actions.SolveAnalytic;
-import jmt.gui.jsimgraph.controller.actions.SolveApprox;
-import jmt.gui.jsimgraph.controller.actions.StopSimulation;
-import jmt.gui.jsimgraph.controller.actions.SwitchToExactSolver;
-import jmt.gui.jsimgraph.controller.actions.TakeScreenShot;
-import jmt.gui.jsimgraph.controller.actions.UseTemplate;
+import jmt.gui.jsimgraph.JGraphMod.*;
+import jmt.gui.jsimgraph.controller.actions.*;
 import jmt.gui.jsimgraph.definitions.JMTPoint;
 import jmt.gui.jsimgraph.definitions.JSimGraphModel;
 import jmt.gui.jsimgraph.definitions.JmodelClassDefinition;
@@ -233,6 +179,8 @@
 	private AbstractJmodelAction takeScreenShot;
 	private AbstractJmodelAction actionRotate;
 	private AbstractJmodelAction actionSetRight;
+	// Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+	private AbstractJmodelAction actionSnapToGrid;
 	private AbstractJmodelAction editUndo;
 	private AbstractJmodelAction editRedo;
 
@@ -320,6 +268,7 @@
 		addBlockingRegion = new AddBlockingRegion(this);
 
 		actionSetRight = new ActionSetRight(this);
+		actionSnapToGrid = new SnapToGrid(this);
 		takeScreenShot = new TakeScreenShot(this);
 
 		actionRotate = new ActionRotate(this);
@@ -330,6 +279,9 @@
 		switchToExactSolver = new SwitchToExactSolver(this);
 		// Initialize new Component bar
 		componentBar = new ComponentBar(this);
+
+		// Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+		((JmtRouting)JmtGraphConstants.ROUTING_JMT).setMediator(this);
 	}
 
 	/**
@@ -415,6 +367,11 @@
 		addBlockingRegion.setEnabled(state);
 	}
 
+	// Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+	public void enableSnapToGrid(boolean state) {
+		actionSnapToGrid.setEnabled(state);
+	}
+
 	public void enableSetRight(boolean state) {
 		actionSetRight.setEnabled(state);
 	}
@@ -423,6 +380,11 @@
 		return actionSetRight;
 	}
 
+	// Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+	public AbstractJmodelAction getSnapToGrid() {
+		return actionSnapToGrid;
+	}
+
 	public AbstractJmodelAction getEditDefaults() {
 		return editDefaults;
 	}
@@ -689,6 +651,8 @@
 		setSelect.setEnabled(false);
 		actionRotate.setEnabled(false);
 		actionSetRight.setEnabled(false);
+		// Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+		actionSnapToGrid.setEnabled(false);
 
 		// Enable the action to perform editing user classes
 		editUserClasses.setEnabled(true);
@@ -781,6 +745,8 @@
 		actionDelete.setEnabled(false);
 		actionRotate.setEnabled(false);
 		actionSetRight.setEnabled(false);
+		// Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+		actionSnapToGrid.setEnabled(false);
 
 		setSelect.setEnabled(false);
 		simulate.setEnabled(false);
@@ -1017,6 +983,23 @@
 			// Visualizes connection only if it can be created into data structure
 			if (model.setConnected(sourceKey, targetKey, true)) {
 				graph.getModel().insert(insert, viewMap, cs, null, null);
+			} else {
+				// Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+				// duplicate connection
+				// remove the new ports created just before
+				InputPort inputPort = (InputPort) inPort.getCell();
+				JmtCell target = (JmtCell) inputPort.getParent();
+				if (target != null && target.numInEdges() > 1) {
+					target.SubIn();
+					target.remove(inputPort);
+				}
+
+				OutputPort outputPort = (OutputPort) outPort.getCell();
+				JmtCell source = (JmtCell) outputPort.getParent();
+				if (source != null && source.numOutEdges() > 1) {
+					source.SubOut();
+					source.remove(outputPort);
+				}
 			}
 		}
 	}
@@ -1062,7 +1045,8 @@
 		viewMap.put(connection, map);
 		Object[] insert = new Object[] { connection };
 		ConnectionSet cs = new ConnectionSet();
-		// Finds sourcePort
+		// Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+		// Finds free sourcePort
 		Iterator it;
 		it = source.getChildren().iterator();
 		DefaultPort tmpPort, sourcePort, targetPort;
@@ -1069,27 +1053,58 @@
 		sourcePort = null;
 		while (it.hasNext()) {
 			tmpPort = (DefaultPort) it.next();
-			if (tmpPort instanceof OutputPort) {
+			if (tmpPort instanceof OutputPort && tmpPort.getEdges().size() == 0) {
 				sourcePort = tmpPort;
 			}
 		}
-		// Finds targetPort
+
+		// Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+		// Otherwise create a new one
+		if (sourcePort == null) {
+			sourcePort = new OutputPort(source);
+			source.insert(sourcePort, source.getChildCount() - 1);
+			source.AddOut();
+			graph.getGraphLayoutCache().putMapping(sourcePort, new PortView(sourcePort));
+		}
+
+		// Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+		// Finds free targetPort
 		it = target.getChildren().iterator();
 		targetPort = null;
 		while (it.hasNext()) {
 			tmpPort = (DefaultPort) it.next();
-			if (tmpPort instanceof InputPort) {
+			if (tmpPort instanceof InputPort && tmpPort.getEdges().size() == 0) {
 				targetPort = tmpPort;
 			}
 		}
-		if (sourcePort != null && targetPort != null) {
-			cs.connect(connection, sourcePort, true);
-			cs.connect(connection, targetPort, false);
-			// Adds connection to the graph only if it can be created into data structure
-			if (model.setConnected(sourceKey, targetKey, true) || forced) {
-				graph.getModel().insert(insert, viewMap, cs, null, null);
-				return connection;
+
+		// Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+		// Otherwise create a new one
+		if (targetPort == null) {
+			targetPort = new InputPort(target);
+			target.insert(targetPort, target.getChildCount() - 1);
+			target.AddIn();
+			graph.getGraphLayoutCache().putMapping(targetPort, new PortView(targetPort));
+		}
+
+		cs.connect(connection, sourcePort, true);
+		cs.connect(connection, targetPort, false);
+		// Adds connection to the graph only if it can be created into data structure
+		if (model.setConnected(sourceKey, targetKey, true) || forced) {
+			graph.getModel().insert(insert, viewMap, cs, null, null);
+			return connection;
+		} else {
+			// Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+			// Add failed, remove ports if necessary
+			if (source.numOutEdges() > 1) {
+				source.SubOut();
+				source.remove(sourcePort);
 			}
+
+			if (target.numInEdges() > 1) {
+				target.SubIn();
+				target.remove(targetPort);
+			}
 		}
 		return null;
 	}
@@ -1122,8 +1137,22 @@
 	 */
 	public PortView getInPortViewAt(int x, int y) {
 		return (PortView) graph.getGraphLayoutCache().getMapping(graph.getInPortAt(x, y), false);
+
 	}
 
+	// Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+	/** gets the first free portView of the input port of the cell at position
+	 *
+	 * @param x
+	 * @param y
+	 * @return the portView of the input port
+	 */
+	public PortView getFreeInPortViewAt(int x, int y) {
+		InputPort p = graph.getFreeInPortAt(x, y);
+		return (PortView) graph.getGraphLayoutCache().getMapping(p, false);
+
+	}
+
 	/** gets the first portView of the output port of the cell at position
 	 *
 	 * @param x
@@ -1166,6 +1195,7 @@
 					((CellComponent) jcell.getUserObject()).getKey());
 			// Adds on the top a panel to change station name
 			stationPanel.add(new StationNamePanel(model, ((CellComponent) jcell.getUserObject()).getKey()), BorderLayout.NORTH);
+			boolean oldPinState = jcell.isPinned();
 			dialogFactory.getDialog(stationPanel, "Editing " + jcell.getUserObject().toString() + " Properties...");
 
 			// Updates cell dimensions if name was changed too much...
@@ -1179,7 +1209,22 @@
 				jcell.updatePortPositions(nest, GraphConstants.getIcon(attr), cellDimension);
 				graph.getGraphLayoutCache().edit(nest);
 			}
-		}
+
+			// Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+			// Change icon so to display a small lock indicating that this component is pinned
+			if (oldPinState != jcell.isPinned()) {
+				ImageIcon lockIcon = JMTImageLoader.loadImage("lock", new Dimension(16, 16));
+				Icon newIcon;
+				if (jcell.isPinned()) {
+					newIcon = new MergedIcon(JMTImageLoader.loadImage(jcell.getIcon()), lockIcon);
+				} else {
+					newIcon = JMTImageLoader.loadImage(jcell.getIcon());
+				}
+				GraphConstants.setIcon(jcell.getAttributes(), newIcon);
+				graph.getGraphLayoutCache().reload();
+				graphRepaint();
+			}
+ 		}
 		// Blocking region editing
 		else if ((cell != null) && (cell instanceof BlockingRegion)) {
 			Object regionKey = ((BlockingRegion) cell).getKey();
@@ -1290,11 +1335,33 @@
 
 		if (!edges.isEmpty()) {
 			// Removes edges from graph
+			List<Object> cellsList = java.util.Arrays.asList(cells);
+			for (Object e: edges) {
+				if (cellsList.indexOf(e) < 0) {
+					// Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+					// delete only unselected edges
+					JmtEdge link = (JmtEdge) e;
+					InputPort targetPort = (InputPort) link.getTarget();
+					JmtCell target = (JmtCell) targetPort.getParent();
+					if (target.numInEdges() > 1) {
+						// Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+						// avoid situation in which there are no InputPorts for target
+						target.SubIn();
+						target.remove(targetPort);
+					}
+
+					OutputPort sourcePort = (OutputPort) link.getSource();
+					JmtCell source = (JmtCell) sourcePort.getParent();
+					if (source.numOutEdges() > 1) {
+						// Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+						// avoid situation in which there are no OutputPorts for source
+						source.SubOut();
+						source.remove(sourcePort);
+					}
+				}
+			}
 			graphmodel.remove(edges.toArray());
 		}
-		// Removes cells from graph
-		graphmodel.remove(cells);
-
 		// Checks if all children of a blocking region have been removed
 		Iterator<Object> it = regions.iterator();
 		while (it.hasNext()) {
@@ -1333,10 +1400,34 @@
 				model.deleteStation(((CellComponent) ((JmtCell) cell).getUserObject()).getKey());
 			} else if (cell instanceof JmtEdge) {
 				JmtEdge link = (JmtEdge) cell;
+				InputPort targetPort = (InputPort) link.getTarget();
+				// Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+				if (targetPort != null) {
+					JmtCell target = (JmtCell) targetPort.getParent();
+					if (target.numInEdges() > 1) {
+						// avoid situation in which there are no InputPorts for target
+						target.SubIn();
+						target.remove(targetPort);
+					}
+				}
+
+				// Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+				OutputPort sourcePort = (OutputPort) link.getSource();
+				if (sourcePort != null) {
+					JmtCell source = (JmtCell) sourcePort.getParent();
+					if (source.numOutEdges() > 1) {
+						// avoid situation in which there are no OutputPorts for source
+						source.SubOut();
+						source.remove(sourcePort);
+					}
+				}
 				model.setConnected(link.getSourceKey(), link.getTargetKey(), false);
 			}
 		}
 
+		// Removes cells from graph
+		graphmodel.remove(cells);
+
 		// If no stations remains gray select and link buttons
 		if (graphmodel.getRootCount() == 0) {
 			componentBar.clearButtonGroupSelection(0);
@@ -1343,6 +1434,7 @@
 			setConnect.setEnabled(false);
 			setSelect.setEnabled(false);
 			actionSetRight.setEnabled(false);
+			actionSnapToGrid.setEnabled(false);
 		}
 
 		// Selects components from removed blocking regions
@@ -2884,14 +2976,21 @@
 			JmtCell current = (JmtCell) cell;
 			Map<Object, Map> nested = new Hashtable<Object, Map>();
 			Map attributeMap = new Hashtable();
-			ImageIcon icon;
+			Icon icon;
 			if (current.isLeftInputCell()) {
 				icon = JMTImageLoader.loadImage(current.getIcon(), ImageLoader.MODIFIER_MIRROR);
 			} else {
 				icon = JMTImageLoader.loadImage(current.getIcon());
 			}
-			GraphConstants.setIcon(attributeMap, icon);
 
+			if (current.isPinned()) {
+				Rectangle2D bounds = GraphConstants.getBounds(current.getAttributes());
+				ImageIcon lockIcon = JMTImageLoader.loadImage("lock", new Dimension(16, 16));
+				GraphConstants.setIcon(attributeMap, new MergedIcon(icon, lockIcon, current.isLeftInputCell() ? (int) bounds.getWidth() - 16 : 0, 0));
+			} else {
+				GraphConstants.setIcon(attributeMap, icon);
+			}
+
 			nested.put(cell, attributeMap);
 			current.setLeftInputCell(!current.isLeftInputCell());
 			current.updatePortPositions(nested, icon, current.getSize(graph));
@@ -3089,7 +3188,11 @@
 						- (int) (boundspadre.getHeight() / 2) + 30);
 			}
 
-			GraphConstants.setBounds(prev.getAttributes(), boundspadre);
+			// Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+			// Don't move this component if it is pinned
+			if (!prev.isPinned()) {
+				GraphConstants.setBounds(prev.getAttributes(), boundspadre);
+			}
 			x = (int) boundspadre.getCenterX() + widthMax + 50;
 			prev.seen = true;
 			flag2 = true;
@@ -3121,7 +3224,10 @@
 			Rectangle bounds = GraphConstants.getBounds(((JmtCell) next.get(0)).getAttributes()).getBounds();
 			bounds.setLocation((int) (boundspadre.getCenterX()) + widthMax + 50 - (int) (bounds.getWidth() / 2),
 					(int) boundspadre.getCenterY() - (int) (bounds.getHeight() / 2));
-			GraphConstants.setBounds(((JmtCell) next.get(0)).getAttributes(), bounds);
+			// Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+			// Don't move this component if it is pinned
+			if (!(((JmtCell) next.get(0)).isPinned()))
+				GraphConstants.setBounds(((JmtCell) next.get(0)).getAttributes(), bounds);
 
 			((JmtCell) next.get(0)).seen = true;
 			j = searchNext((JmtCell) next.get(0));
@@ -3160,8 +3266,12 @@
 				Rectangle bounds = GraphConstants.getBounds(((JmtCell) sons.get(i)).getAttributes()).getBounds();
 				bounds.setLocation((int) (boundspadre.getCenterX()) + widthMax + 50 - (int) (bounds.getWidth() / 2),
 						w - (int) (bounds.getHeight() / 2) + 80);
-				GraphConstants.setBounds(((JmtCell) sons.get(i)).getAttributes(), bounds);
 
+				// Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+				// Don't move this component if it is pinned
+				if (!(((JmtCell) sons.get(i)).isPinned()))
+					GraphConstants.setBounds(((JmtCell) sons.get(i)).getAttributes(), bounds);
+
 				((JmtCell) sons.get(i)).seen = true;
 				listEdges = DefaultGraphModel.getOutgoingEdges(graphmodel, sons.get(i));
 
@@ -3324,6 +3434,7 @@
 			setConnect.setEnabled(false);
 			setSelect.setEnabled(false);
 			actionSetRight.setEnabled(false);
+			actionSnapToGrid.setEnabled(false);
 		}
 
 		// Selects components from removed blocking regions
@@ -3349,4 +3460,212 @@
 		}
 	}
 
+	// Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+	/**
+	 *
+	 * @param x
+	 * @param y
+	 * @return
+	 */
+	public PortView getFreeOutPortViewAt(int x, int y) {
+		return (PortView) graph.getGraphLayoutCache().getMapping(graph.getFreeOutPortAt(x, y), false);
+	}
+
+	// Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+	// Try to adjust the graph, then displays a confirmation message to prompt the user to keep the result or restore the initial state
+	public void tryAdjustGraph() {
+		// This introduces some potential quirks that need to be fixed
+		boolean atLeastOnePinned = false;
+		Object[] cells = graph.getDescendants(graph.getRoots());
+		// Previous cell positions
+		Rectangle2D[] cellsBounds = new Rectangle2D[cells.length];
+		// The algorithm changes the rotate state, we need to save them in order to restore if the users undoes the operation
+		boolean[] cellsRotateState = new boolean[cells.length];
+		for (int i = 0; i < cells.length; i++) {
+			if (cells[i] instanceof JmtCell) {
+				JmtCell cell = (JmtCell) cells[i];
+				cellsBounds[i] = GraphConstants.getBounds(cell.getAttributes()).getBounds();
+				cellsRotateState[i] = cell.isLeftInputCell();
+				if (cell.isPinned()) {
+					atLeastOnePinned = true;
+				}
+			}
+
+		}
+
+		adjustGraph();
+
+		// Simple heuristics that prevents components to be arranged of the graph's bounds
+		if (atLeastOnePinned) {
+			double direction;
+			double minDistance = Double.POSITIVE_INFINITY;
+			double slope = 0;
+			int minIndex = -1;
+
+			for (int i = 0; i < cells.length; i++) {
+				if (cells[i] instanceof JmtCell) {
+					JmtCell cell = (JmtCell) cells[i];
+					if (!cell.isPinned()) {
+						Rectangle2D repositionedBounds = GraphConstants.getBounds(cell.getAttributes()).getBounds();
+						double euclideanDist = Math.sqrt(Math.pow((cellsBounds[i].getX() - repositionedBounds.getX()), 2) + Math.pow((cellsBounds[i].getY() - repositionedBounds.getY()), 2));
+						// Store the minimum euclidean distance between the original component position and the arranged one, and the slope of this segment
+						if (euclideanDist < minDistance) {
+							minDistance = euclideanDist;
+							slope = (repositionedBounds.getY() - cellsBounds[i].getY()) / (repositionedBounds.getX() - cellsBounds[i].getX());
+							minIndex = i;
+						}
+					}
+				}
+			}
+
+			for (int i = 0; i < cells.length; i++) {
+				if (cells[i] instanceof JmtCell) {
+					JmtCell cell = (JmtCell) cells[i];
+					if (!cell.isPinned()) {
+						if (i == minIndex) {
+							GraphConstants.setBounds(cell.getAttributes(), cellsBounds[i]);
+						} else {
+							Rectangle2D repositionedBounds = GraphConstants.getBounds(cell.getAttributes()).getBounds();
+							if (cellsBounds[i].getX() > repositionedBounds.getX()) {
+								direction = 1;
+							} else {
+								direction = -1;
+							}
+							// Move all the other components by the same amount of distance, constrained by the fact that
+							// the movement segment should have the same slope of the minimum
+							// one found in the previous cycle.
+							double xfinal = direction * Math.sqrt(minDistance * minDistance / (1 + slope * slope)) + repositionedBounds.getX();
+							double yfinal = slope * (xfinal - repositionedBounds.getX()) + repositionedBounds.getY();
+							repositionedBounds.setRect(xfinal, yfinal, repositionedBounds.getWidth(), repositionedBounds.getHeight());
+							GraphConstants.setBounds(cell.getAttributes(), repositionedBounds);
+						}
+					}
+				}
+			}
+
+			graphRepaint();
+			graph.getGraphLayoutCache().reload();
+			avoidOverlappingCell(cells);
+		}
+
+		// Display confirmation message
+		int result = JOptionPane.showConfirmDialog(mainWindow, "Keep the result of autoarrange?", "Autoarrange", JOptionPane.YES_NO_OPTION);
+		if (result == JOptionPane.NO_OPTION) {
+			// Restore cells position and rotate state in case of undo
+			for (int i = 0; i < cells.length; i++) {
+				if(cells[i] instanceof JmtCell) {
+					JmtCell cell = (JmtCell) cells[i];
+					GraphConstants.setBounds(cell.getAttributes(), cellsBounds[i]);
+					if (cell.isLeftInputCell() != cellsRotateState[i]) { // adjustGraph has rotated this cell, restore its previous state
+						rotateComponent(new Object[] { cell });
+					}
+				}
+			}
+			graphRepaint();
+			graph.getGraphLayoutCache().reload();
+			avoidOverlappingCell(cells);
+		}
+	}
+
+
+	// Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+	// Reposition components by aligning them to a grid with user-supplied cell size
+	public void snapToGrid() {
+		int cellSize;
+		String size = JOptionPane.showInputDialog(mainWindow, "Please specify the cells size in pixels:");
+		if (size != null) {
+			try {
+				cellSize = Integer.parseInt(size);
+				if (cellSize <= 0) {
+					cellSize = 50;
+				}
+			} catch (NumberFormatException e) {
+				cellSize = 50;
+			}
+
+			Object[] cells = graph.getDescendants(graph.getRoots());
+
+			for (Object cell : cells) {
+				if (cell instanceof JmtCell) {
+					JmtCell jcell = (JmtCell) cell;
+					if (!jcell.isPinned()) {
+						Rectangle2D bounds = GraphConstants.getBounds(jcell.getAttributes()).getBounds();
+						bounds.setRect(Math.round(bounds.getX() / cellSize) * cellSize, Math.round(bounds.getY() / cellSize) * cellSize, bounds.getWidth(), bounds.getHeight());
+						GraphConstants.setBounds(jcell.getAttributes(), bounds);
+					}
+				}
+			}
+
+			// With larger cell size, some components may overlap, solve this issue by moving the necessary components in adjacent cells.
+			boolean needRecompute = true;
+			while (needRecompute) {
+				needRecompute = false;
+				for (int i = 0; i < cells.length; i++) {
+					if (cells[i] instanceof JmtCell) {
+						JmtCell cell1 = (JmtCell) cells[i];
+						Rectangle2D bounds1 = GraphConstants.getBounds(cell1.getAttributes()).getBounds();
+						for (int j = i + 1; j < cells.length; j++) {
+							if (cells[j] instanceof JmtCell) {
+								JmtCell cell2 = (JmtCell) cells[j];
+								Rectangle2D bounds2 = GraphConstants.getBounds(cell2.getAttributes()).getBounds();
+								if (intersectRect(bounds1, bounds2)) {
+									if (!cell2.isPinned()) {
+										bounds2.setRect(bounds2.getX() + cellSize, bounds2.getY(), bounds2.getWidth(), bounds2.getHeight());
+										GraphConstants.setBounds(cell2.getAttributes(), bounds2);
+									} else {
+										bounds1.setRect(bounds1.getX() + cellSize, bounds1.getY(), bounds1.getWidth(), bounds1.getHeight());
+										GraphConstants.setBounds(cell1.getAttributes(), bounds1);
+									}
+									needRecompute = true;
+								}
+							}
+						}
+					}
+				}
+			}
+
+			graphRepaint();
+			graph.getGraphLayoutCache().reload();
+			avoidOverlappingCell(cells);
+		}
+	}
+
+	// Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+	// Try to snap components to the grid, then displays a confirmation message to prompt the user to keep the result or restore the initial state
+	public void trySnapToGrid() {
+		Object[] cells = graph.getDescendants(graph.getRoots());
+		Rectangle2D[] cellsBounds = new Rectangle2D[cells.length];
+		for (int i = 0; i < cells.length; i++) {
+			if (cells[i] instanceof JmtCell) {
+				JmtCell cell = (JmtCell) cells[i];
+				cellsBounds[i] = GraphConstants.getBounds(cell.getAttributes()).getBounds();
+			}
+
+		}
+
+		snapToGrid();
+
+		int result = JOptionPane.showConfirmDialog(mainWindow, "Keep the result of snap to grid?", "Snap to grid", JOptionPane.YES_NO_OPTION);
+		if (result == JOptionPane.NO_OPTION) {
+			for (int i = 0; i < cells.length; i++) {
+				if(cells[i] instanceof JmtCell) {
+					JmtCell cell = (JmtCell) cells[i];
+					GraphConstants.setBounds(cell.getAttributes(), cellsBounds[i]);
+				}
+			}
+			graphRepaint();
+			graph.getGraphLayoutCache().reload();
+			avoidOverlappingCell(cells);
+		}
+
+	}
+
+	// Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+	// Checks whether two rectangles intersect.
+	private boolean intersectRect(Rectangle2D r1, Rectangle2D r2) {
+		return !(r2.getMinX() > r1.getMaxX() ||
+				r2.getMaxX() < r1.getMinX() ||
+				r2.getMinY() > r1.getMaxY() ||
+				r2.getMaxY() < r1.getMinY());
+	}
 }
Index: src/main/java/jmt/gui/jsimgraph/controller/actions/ActionSetRight.java
===================================================================
--- src/main/java/jmt/gui/jsimgraph/controller/actions/ActionSetRight.java	(revision 978)
+++ src/main/java/jmt/gui/jsimgraph/controller/actions/ActionSetRight.java	(working copy)
@@ -5,6 +5,8 @@
 
 import jmt.gui.jsimgraph.controller.Mediator;
 
+import javax.swing.*;
+
 /**
  * A class representing a "redo" action.
  * @author Giuseppe De Cicco & Fabio Granara
@@ -34,7 +36,9 @@
 	 */
 	boolean repeat = false;
 
+
 	public void actionPerformed(ActionEvent e) {
-		mediator.adjustGraph();
+		// Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+		mediator.tryAdjustGraph();
 	}
 }
Index: src/main/java/jmt/gui/jsimgraph/mainGui/ComponentBar.java
===================================================================
--- src/main/java/jmt/gui/jsimgraph/mainGui/ComponentBar.java	(revision 978)
+++ src/main/java/jmt/gui/jsimgraph/mainGui/ComponentBar.java	(working copy)
@@ -63,6 +63,8 @@
 		addGenericButton(m.getRotate());
 		// Set right button
 		addGenericButton(m.getSetRight());
+		// Snap to grid button
+		addGenericButton(m.getSnapToGrid());
 
 		// Disables all components button
 		enableButtons(false);
Index: src/main/java/jmt/gui/jsimgraph/panels/StationNamePanel.java
===================================================================
--- src/main/java/jmt/gui/jsimgraph/panels/StationNamePanel.java	(revision 978)
+++ src/main/java/jmt/gui/jsimgraph/panels/StationNamePanel.java	(working copy)
@@ -24,10 +24,7 @@
 import java.awt.event.KeyEvent;
 import java.awt.event.KeyListener;
 
-import javax.swing.Box;
-import javax.swing.JLabel;
-import javax.swing.JPanel;
-import javax.swing.JTextField;
+import javax.swing.*;
 import javax.swing.border.EtchedBorder;
 import javax.swing.border.TitledBorder;
 
@@ -49,6 +46,8 @@
 	private JmodelStationDefinition sd;
 	private Object key;
 	private JTextField name = new JTextField();
+	// Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+	private JCheckBox pinned = new JCheckBox();
 
 	/**
 	 * Creates a new Station Name Panel
@@ -65,15 +64,28 @@
 	 * Inits this panel's components and their action listeners
 	 */
 	private void init() {
+		BorderLayout pinLayout = new BorderLayout(5, 0);
+		JPanel pinPanel = new JPanel();
+		pinPanel.setLayout(pinLayout);
 		setLayout(new BorderLayout(5, 5));
 		setBorder(new TitledBorder(new EtchedBorder(), "Station Name"));
 		add(new JLabel("Station Name: "), BorderLayout.WEST);
 		name.setText(sd.getStationName(key));
+		pinned.setSelected(sd.isPinned(key));
 		add(name, BorderLayout.CENTER);
+		// Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+		pinPanel.add(new JLabel("Pin:"), BorderLayout.WEST);
+		pinPanel.add(pinned, BorderLayout.CENTER);
+
+		add(pinPanel, BorderLayout.EAST);
 		add(Box.createVerticalStrut(5), BorderLayout.SOUTH);
 		inputListener listener = new inputListener();
 		name.addKeyListener(listener);
 		name.addFocusListener(listener);
+
+		// Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+		pinned.addFocusListener(listener);
+		pinned.addKeyListener(listener);
 	}
 
 	/**
@@ -86,7 +98,10 @@
 		 */
 		protected void updateValues() {
 			sd.setStationName(key, name.getText());
+			sd.setIsPinned(key, pinned.isSelected());
 			name.setText(sd.getStationName(key));
+			// Fioratto Raffaele, Pellizzari Filippo, Cardinale Claudio
+			pinned.setSelected(sd.isPinned(key));
 		}
 
 		public void focusLost(FocusEvent e) {
Index: src/main/java/jmt/gui/jsimgraph/panels/TemplateAddingPanel.java
===================================================================
--- src/main/java/jmt/gui/jsimgraph/panels/TemplateAddingPanel.java	(revision 978)
+++ src/main/java/jmt/gui/jsimgraph/panels/TemplateAddingPanel.java	(working copy)
@@ -543,7 +543,7 @@
 			} catch (MalformedURLException e) {
 				// if the URL format is invalid, shows the err msg
 				publish("the URL is invalid");
-				JOptionPane.showMessageDialog(parent, "Invalid URL");
+				JOptionPane.showMessageDialog(parent, "INVALID URL");
 				Thread.sleep(1000);
 				publish("");
 			} catch (IOException e) {
Index: src/main/java/jmt/gui/jwat/trafficAnalysis/utils/Loader.java
===================================================================
--- src/main/java/jmt/gui/jwat/trafficAnalysis/utils/Loader.java	(revision 978)
+++ src/main/java/jmt/gui/jwat/trafficAnalysis/utils/Loader.java	(working copy)
@@ -213,7 +213,7 @@
 				if (defaultFilter.accept(getSelectedFile())) {
 					super.approveSelection();
 				} else {
-					JOptionPane.showMessageDialog(this, "Invalid Extension\nSelect only *.log files", "Invalid Extension", JOptionPane.ERROR_MESSAGE);
+					JOptionPane.showMessageDialog(this, "INVALID Extension\nSelect only *.log files", "INVALID Extension", JOptionPane.ERROR_MESSAGE);
 				}
 
 			}
Index: src/main/java/jmt/jmva/analytical/solvers/Basis/BTFCoMoMBasis.java
===================================================================
--- src/main/java/jmt/jmva/analytical/solvers/Basis/BTFCoMoMBasis.java	(revision 978)
+++ src/main/java/jmt/jmva/analytical/solvers/Basis/BTFCoMoMBasis.java	(working copy)
@@ -41,7 +41,7 @@
 		int population_position = order.indexOf(n);
 		int queue_added = m;
 
-		if (population_position == -1) throw new InternalErrorException("Invalid PopulationChangeVector:" + n);
+		if (population_position == -1) throw new InternalErrorException("INVALID PopulationChangeVector:" + n);
 
 		//No queues added, constant is in Lambda_Y
 		if (queue_added == 0) {
Index: src/main/java/jmt/jmva/analytical/solvers/Basis/CoMoMBasis.java
===================================================================
--- src/main/java/jmt/jmva/analytical/solvers/Basis/CoMoMBasis.java	(revision 978)
+++ src/main/java/jmt/jmva/analytical/solvers/Basis/CoMoMBasis.java	(working copy)
@@ -101,7 +101,7 @@
 	 */
 	public int indexOf(PopulationChangeVector n, int m) throws InternalErrorException {
 		int population_position = order.indexOf(n);
-		if (population_position == -1) throw new InternalErrorException("Invalid PopulationChangeVector");
+		if (population_position == -1) throw new InternalErrorException("INVALID PopulationChangeVector");
 
 		//order multiplicities 0,1,2,3,...M
 		return population_position*(qnm.M + 1) + m;
Index: src/main/java/jmt/jmva/analytical/solvers/Basis/CoMoMBasisMLorder.java
===================================================================
--- src/main/java/jmt/jmva/analytical/solvers/Basis/CoMoMBasisMLorder.java	(revision 978)
+++ src/main/java/jmt/jmva/analytical/solvers/Basis/CoMoMBasisMLorder.java	(working copy)
@@ -40,7 +40,7 @@
 		int population_position = order.indexOf(n);
 		int queue_added = m;
 
-		if (population_position == -1) throw new InternalErrorException("Invalid PopulationChangeVector");
+		if (population_position == -1) throw new InternalErrorException("INVALID PopulationChangeVector");
 
 		if (queue_added == 0) {
 			return MiscFunctions.binomialCoefficient(M + R - 1 , M)*M + population_position;
Index: src/main/java/jmt/jmva/commandline/JMVASolver.java
===================================================================
--- src/main/java/jmt/jmva/commandline/JMVASolver.java	(revision 978)
+++ src/main/java/jmt/jmva/commandline/JMVASolver.java	(working copy)
@@ -48,7 +48,7 @@
 		}
 		File model = new File(args[0]);
 		if (!model.isFile()) {
-			System.err.print("Invalid model file: " + model.getAbsolutePath());
+			System.err.print("INVALID model file: " + model.getAbsolutePath());
 			System.exit(1);
 		}
 
Index: src/main/java/jmt/jmva/gui/exact/panels/AMVAPanel.java
===================================================================
--- src/main/java/jmt/jmva/gui/exact/panels/AMVAPanel.java	(revision 978)
+++ src/main/java/jmt/jmva/gui/exact/panels/AMVAPanel.java	(working copy)
@@ -328,7 +328,7 @@
 			ew.getData().setTolerance(tol);
 		}
 		else {
-			JOptionPane.showMessageDialog(ew, "Error: Invalid tolerance value. Using last valid value.", "Input data error", JOptionPane.ERROR_MESSAGE);
+			JOptionPane.showMessageDialog(ew, "Error: INVALID tolerance value. Using last valid value.", "Input data error", JOptionPane.ERROR_MESSAGE);
 		}
 	}
 
@@ -338,7 +338,7 @@
         if (mSamples != null) {
             model.setMaxSamples(mSamples);
         } else {
-            JOptionPane.showMessageDialog(ew, "Error: Invalid max samples value. Using last valid value.", "Input data error", JOptionPane.ERROR_MESSAGE);
+            JOptionPane.showMessageDialog(ew, "Error: INVALID max samples value. Using last valid value.", "Input data error", JOptionPane.ERROR_MESSAGE);
         }
     }
 
Index: src/main/java/jmt/jmva/gui/exact/panels/WhatIfPanel.java
===================================================================
--- src/main/java/jmt/jmva/gui/exact/panels/WhatIfPanel.java	(revision 978)
+++ src/main/java/jmt/jmva/gui/exact/panels/WhatIfPanel.java	(working copy)
@@ -543,7 +543,7 @@
 							data.setWhatifAlgorithmTolerance(algorithm, tol);
 						}
 						else {
-							JOptionPane.showMessageDialog(WhatIfPanel.this, "Error: Invalid tolerance value. Using last valid value.", "Input data error", JOptionPane.ERROR_MESSAGE);
+							JOptionPane.showMessageDialog(WhatIfPanel.this, "Error: INVALID tolerance value. Using last valid value.", "Input data error", JOptionPane.ERROR_MESSAGE);
 						}
 					}
 					
@@ -562,7 +562,7 @@
 								data.setWhatifAlgorithmTolerance(algorithm, tol);
 							}
 							else {
-								JOptionPane.showMessageDialog(WhatIfPanel.this, "Error: Invalid tolerance value. Using last valid value.", "Input data error", JOptionPane.ERROR_MESSAGE);
+								JOptionPane.showMessageDialog(WhatIfPanel.this, "Error: INVALID tolerance value. Using last valid value.", "Input data error", JOptionPane.ERROR_MESSAGE);
 							}
 						}
 					}
Index: src/main/resources/jmt/common/xml/JModelGUI.xsd
===================================================================
--- src/main/resources/jmt/common/xml/JModelGUI.xsd	(revision 978)
+++ src/main/resources/jmt/common/xml/JModelGUI.xsd	(working copy)
@@ -31,6 +31,7 @@
 									<xs:attribute name="x" type="jdouble" use="required"/>
 									<xs:attribute name="y" type="jdouble" use="required"/>
 									<xs:attribute name="rotate" type="xs:boolean" use="optional"/>
+									<xs:attribute name="pin" type="xs:boolean" use="optional"/>
 								</xs:complexType>
 							</xs:element>
 						</xs:sequence>
Index: src/test/java/jmt/util/Jmt.java
===================================================================
--- src/test/java/jmt/util/Jmt.java	(revision 978)
+++ src/test/java/jmt/util/Jmt.java	(working copy)
@@ -96,7 +96,7 @@
 			File result = new File(args[1]+"-result.jmva");
 			
 			if (!model.isFile()) {
-				System.err.print("Invalid model file: " + model.getAbsolutePath());
+				System.err.print("INVALID model file: " + model.getAbsolutePath());
 				System.exit(1);
 			}
 
@@ -147,7 +147,7 @@
 				try {
 					dispatcher.setSimulationSeed(Long.parseLong(options.get(OPTION_SEED)));
 				} catch (NumberFormatException ex) {
-					System.err.println("Invalid simulation seed. Should be a number.");
+					System.err.println("INVALID simulation seed. Should be a number.");
 					System.exit(1);
 				}
 			}
@@ -156,7 +156,7 @@
 				try {
 					dispatcher.setSimulationMaxDuration(Long.parseLong(options.get(OPTION_MAXTIME)) * 1000);
 				} catch (NumberFormatException ex) {
-					System.err.println("Invalid maximum simulation time. Should be a number.");
+					System.err.println("INVALID maximum simulation time. Should be a number.");
 					System.exit(1);
 				}	
 			}
