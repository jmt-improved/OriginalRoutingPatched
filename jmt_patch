Index: src/main/java/jmt/gui/common/definitions/CommonModel.java
===================================================================
--- src/main/java/jmt/gui/common/definitions/CommonModel.java	(revision 978)
+++ src/main/java/jmt/gui/common/definitions/CommonModel.java	(working copy)
@@ -3542,9 +3542,12 @@
 		/** Reference to owner blocking station or null */
 		public Object blockingRegion;
 
+		public boolean pinned;
+
 		public StationData(String name, String type) {
 			this.name = name;
 			this.type = type;
+			this.pinned = false;
 		}
 	}
 
@@ -4053,6 +4056,30 @@
 		}
 	}
 
+	@Override
+	public boolean isPinned(Object stationKey) {
+		StationData sd;
+		if (stationDataHM.containsKey(stationKey)) {
+			sd = (StationData) stationDataHM.get(stationKey);
+		} else {
+			return false;
+		}
+
+		return sd.pinned;
+	}
+
+	@Override
+	public void setIsPinned(Object stationKey, boolean value) {
+		StationData sd;
+		if (stationDataHM.containsKey(stationKey)) {
+			sd = (StationData) stationDataHM.get(stationKey);
+		} else {
+			return;
+		}
+
+		sd.pinned = value;
+	}
+
 	/**
 	 * Returns given name if a mode with the same name does not exist or makes it unique
 	 * for a transition
Index: src/main/java/jmt/gui/common/definitions/StationDefinition.java
===================================================================
--- src/main/java/jmt/gui/common/definitions/StationDefinition.java	(revision 978)
+++ src/main/java/jmt/gui/common/definitions/StationDefinition.java	(working copy)
@@ -637,4 +637,7 @@
 	 */
 	public void setFiringOutcome(Object stationKey, int modeIndex, Object stationOutKey, Object classKey, Integer value);
 
+	boolean isPinned(Object key);
+
+	void setIsPinned(Object key, boolean value);
 }
Index: src/main/java/jmt/gui/common/xml/GuiXMLConstants.java
===================================================================
--- src/main/java/jmt/gui/common/xml/GuiXMLConstants.java	(revision 978)
+++ src/main/java/jmt/gui/common/xml/GuiXMLConstants.java	(working copy)
@@ -41,6 +41,7 @@
 	public static final String XML_A_POSITION_X = "x";
 	public static final String XML_A_POSITION_Y = "y";
 	public static final String XML_A_POSITION_ROTATE = "rotate";
+	public static final String XML_A_PIN = "pin";
 
 	public static final String XML_E_PARAMETRIC = "parametric";
 	public static final String XML_A_PARAMETRIC_CLASSPATH = "classPath";
Index: src/main/java/jmt/gui/common/xml/GuiXMLReader.java
===================================================================
--- src/main/java/jmt/gui/common/xml/GuiXMLReader.java	(revision 978)
+++ src/main/java/jmt/gui/common/xml/GuiXMLReader.java	(working copy)
@@ -135,6 +135,7 @@
 		Element station, position;
 		String name;
 		double x, y;
+		boolean pinned = false;
 		boolean rotate = false;
 		// For each stored Station
 		for (int i = 0; i < stations.getLength(); i++) {
@@ -146,11 +147,15 @@
 			if (position.hasAttribute(XML_A_POSITION_ROTATE)) {
 				rotate = Boolean.TRUE.toString().equalsIgnoreCase(position.getAttribute(XML_A_POSITION_ROTATE));
 			}
+			if (position.hasAttribute(XML_A_PIN)) {
+				pinned = Boolean.parseBoolean(position.getAttribute(XML_A_PIN));
+			}
 			if (names.containsKey(name)) {
 				model.setStationPosition(names.get(name), new JMTPoint(x, y, rotate));
 			} else {
 				System.out.println("Error - Found position info for station '" + name + "' which is not present into current model.");
 			}
+			model.setIsPinned(names.get(name), pinned);
 		}
 	}
 
Index: src/main/java/jmt/gui/common/xml/GuiXMLWriter.java
===================================================================
--- src/main/java/jmt/gui/common/xml/GuiXMLWriter.java	(revision 978)
+++ src/main/java/jmt/gui/common/xml/GuiXMLWriter.java	(working copy)
@@ -181,6 +181,7 @@
 			position.setAttribute(XML_A_POSITION_X, String.valueOf(model.getStationPosition(stationKey).getX()));
 			position.setAttribute(XML_A_POSITION_Y, String.valueOf(model.getStationPosition(stationKey).getY()));
 			position.setAttribute(XML_A_POSITION_ROTATE, String.valueOf(model.getStationPosition(stationKey).isRotate()));
+			position.setAttribute(XML_A_PIN, String.valueOf(model.isPinned(stations.get(i))));
 			station.appendChild(position);
 			guiNode.appendChild(station);
 		}
Index: src/main/java/jmt/gui/jsimgraph/JGraphMod/CellComponent.java
===================================================================
--- src/main/java/jmt/gui/jsimgraph/JGraphMod/CellComponent.java	(revision 978)
+++ src/main/java/jmt/gui/jsimgraph/JGraphMod/CellComponent.java	(working copy)
@@ -53,6 +53,8 @@
 		return sd.getStationName(key);
 	}
 
+	public boolean isPinned() { return sd.isPinned(key); }
+
 	/**
 	 * Returns key referencing this station
 	 * @return this station's key
Index: src/main/java/jmt/gui/jsimgraph/JGraphMod/ClassSwitchCell.java
===================================================================
--- src/main/java/jmt/gui/jsimgraph/JGraphMod/ClassSwitchCell.java	(revision 978)
+++ src/main/java/jmt/gui/jsimgraph/JGraphMod/ClassSwitchCell.java	(working copy)
@@ -20,7 +20,11 @@
 
 import org.jgraph.graph.Port;
 
- /**
+import java.awt.geom.Point2D;
+import java.util.LinkedList;
+import java.util.List;
+
+/**
  * It represent a component that switches class of jobs coming into it. 
  * @author John
  *
@@ -54,10 +58,13 @@
 	 * @return array of ports
 	 */
 	@Override
-	public Port[] createPorts() {
-		Port[] ports = new Port[2];
-		ports[0] = new InputPort(this);
-		ports[1] = new OutputPort(this);
+	public List<Port> createPorts() {
+		//Port[] ports = new Port[2];
+		//ports[0] = new InputPort(this);
+		//ports[1] = new OutputPort(this);
+		List<Port> ports = new LinkedList<>();
+		ports.add(new InputPort(this));
+		ports.add(new OutputPort(this));
 		return ports;
 	}
 
Index: src/main/java/jmt/gui/jsimgraph/JGraphMod/DelayCell.java
===================================================================
--- src/main/java/jmt/gui/jsimgraph/JGraphMod/DelayCell.java	(revision 978)
+++ src/main/java/jmt/gui/jsimgraph/JGraphMod/DelayCell.java	(working copy)
@@ -22,6 +22,9 @@
 
 import org.jgraph.graph.Port;
 
+import java.util.LinkedList;
+import java.util.List;
+
 /**
  * Represents a pure Delay service center
  *
@@ -59,10 +62,14 @@
 	 * @return array of ports
 	 */
 	@Override
-	public Port[] createPorts() {
-		Port[] ports = new Port[2];
+	public List<Port> createPorts() {
+		/*Port[] ports = new Port[2];
 		ports[0] = new InputPort(this);
 		ports[1] = new OutputPort(this);
+		return ports;*/
+		List<Port> ports = new LinkedList<>();
+		ports.add(new InputPort(this));
+		ports.add(new OutputPort(this));
 		return ports;
 	}
 
Index: src/main/java/jmt/gui/jsimgraph/JGraphMod/ForkCell.java
===================================================================
--- src/main/java/jmt/gui/jsimgraph/JGraphMod/ForkCell.java	(revision 978)
+++ src/main/java/jmt/gui/jsimgraph/JGraphMod/ForkCell.java	(working copy)
@@ -22,6 +22,9 @@
 
 import org.jgraph.graph.Port;
 
+import java.util.LinkedList;
+import java.util.List;
+
 /**
  * Generates new jobs in open systems, it generates jobs of 1 JobClass only
  *
@@ -59,10 +62,14 @@
 	 * @return array of ports
 	 */
 	@Override
-	public Port[] createPorts() {
-		Port[] ports = new Port[2];
+	public List<Port> createPorts() {
+		/*Port[] ports = new Port[2];
 		ports[0] = new InputPort(this);
 		ports[1] = new OutputPort(this);
+		return ports;*/
+		List<Port> ports = new LinkedList<>();
+		ports.add(new InputPort(this));
+		ports.add(new OutputPort(this));
 		return ports;
 	}
 
Index: src/main/java/jmt/gui/jsimgraph/JGraphMod/JmtCell.java
===================================================================
--- src/main/java/jmt/gui/jsimgraph/JGraphMod/JmtCell.java	(revision 978)
+++ src/main/java/jmt/gui/jsimgraph/JGraphMod/JmtCell.java	(working copy)
@@ -1,16 +1,16 @@
 /**
  * Copyright (C) 2016, Laboratorio di Valutazione delle Prestazioni - Politecnico di Milano
-
+ * <p>
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
-
+ * <p>
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  * GNU General Public License for more details.
-
+ * <p>
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
@@ -26,8 +26,7 @@
 import java.awt.font.FontRenderContext;
 import java.awt.geom.Point2D;
 import java.awt.geom.Rectangle2D;
-import java.util.Hashtable;
-import java.util.Map;
+import java.util.*;
 
 import javax.swing.Icon;
 import javax.swing.ImageIcon;
@@ -35,251 +34,270 @@
 
 import jmt.gui.common.JMTImageLoader;
 
+import jmt.gui.common.MergedIcon;
 import org.jgraph.JGraph;
-import org.jgraph.graph.DefaultGraphCell;
-import org.jgraph.graph.DefaultPort;
-import org.jgraph.graph.GraphConstants;
-import org.jgraph.graph.Port;
+import org.jgraph.graph.*;
 
 /**
  * vertex cell for jmt
  *
  * @author Federico Granata
- * Date: 11-lug-2003
- * Time: 13.48.34
- *
+ *         Date: 11-lug-2003
+ *         Time: 13.48.34
  * @author Bertoli Marco
  */
 public abstract class JmtCell extends DefaultGraphCell {
 
-	private static final long serialVersionUID = 1L;
-	private Dimension imageDimension;
-	// Used to determine if parent of this cell has changed (to detect enter and exit from
-	// blocking regions)
-	private TreeNode parentRef;
-	/**
-	 * Different kind of nodes.
-	 */
-	public static final int SOURCE = 0;
-	public static final int TERMINAL = 1;
-	public static final int DELAY = 2;
-	public static final int SERVER = 3;
-	public static final int SINK = 4;
-	public static final int FORK = 5;
-	public static final int JOIN = 6;
-	public static final int LDSERVER = 7;
-	public static final int CLASSSWITCH = 8;
-	public static final int SEMAPHORE = 9;
-	public static final int SCALER = 10;
-	public static final int PLACE = 11;
-	public static final int TRANSITION = 12;
+    private static final long serialVersionUID = 1L;
+    private Dimension imageDimension;
+    // Used to determine if parent of this cell has changed (to detect enter and exit from
+    // blocking regions)
+    private TreeNode parentRef;
 
-	private Port[] ports;
+    /**
+     * Different kind of nodes.
+     */
+    public static final int SOURCE = 0;
+    public static final int TERMINAL = 1;
+    public static final int DELAY = 2;
+    public static final int SERVER = 3;
+    public static final int SINK = 4;
+    public static final int FORK = 5;
+    public static final int JOIN = 6;
+    public static final int LDSERVER = 7;
+    public static final int CLASSSWITCH = 8;
+    public static final int SEMAPHORE = 9;
+    public static final int SCALER = 10;
+    public static final int PLACE = 11;
+    public static final int TRANSITION = 12;
 
-	// Giuseppe De Cicco & Fabio Granara
-	public boolean seen = false;
-	public int in = 0;
-	public int out = 0;
-	public boolean okin = false;
-	public boolean okout = false;
-	public int sons = 1;
-	public int type;
-	private boolean leftInputCell = true;
+    //private Port[] ports;
 
-	/**
-	 * Tells if this component can be placed on JGraph or has been disabled. This is
-	 * useful to load old models with disabled components (like terminals)
-	 */
-	public static final boolean canBePlaced = true;
+    private List<Port> ports;
 
-	/**
-	 * Creates a graph cell and initializes it with the specified user object.
-	 *
-	 * @param userObject an Object provided by the user that constitutes
-	 *                   the cell's data
-	 *
-	 * Conti Andrea  01-09-2003
-	 * Bertoli Marco 04-giu-2005
-	 */
-	public JmtCell(String icon, Object userObject) {
-		super(userObject);
-		ImageIcon ico = JMTImageLoader.loadImage(icon);
-		GraphConstants.setIcon(attributes, ico);
-		imageDimension = new Dimension(ico.getIconWidth(), ico.getIconHeight());
-		GraphConstants.setSizeable(attributes, false);
-		GraphConstants.setSize(attributes, imageDimension);
-	}
+    // Giuseppe De Cicco & Fabio Granara
+    public boolean seen = false;
+    public int in = 1;
+    public int out = 1;
+    public boolean okin = false;
+    public boolean okout = false;
+    public int sons = 1;
+    public int type;
+    private boolean leftInputCell = true;
 
-	// Giuseppe De Cicco & Fabio Granara
-	public void AddIn() {
-		in += 1;
-	}
+    /**
+     * Tells if this component can be placed on JGraph or has been disabled. This is
+     * useful to load old models with disabled components (like terminals)
+     */
+    public static final boolean canBePlaced = true;
 
-	// Giuseppe De Cicco & Fabio Granara
-	public void SubIn() {
-		in -= 1;
-	}
+    /**
+     * Creates a graph cell and initializes it with the specified user object.
+     *
+     * @param userObject an Object provided by the user that constitutes
+     *                   the cell's data
+     *                   <p>
+     *                   Conti Andrea  01-09-2003
+     *                   Bertoli Marco 04-giu-2005
+     */
+    public JmtCell(String icon, Object userObject) {
+        super(userObject);
+        ImageIcon ico = JMTImageLoader.loadImage(icon);
+        if (isPinned()) {
+            ImageIcon lockIcon = JMTImageLoader.loadImage("lock", new Dimension(16, 16));
+            GraphConstants.setIcon(attributes, new MergedIcon(JMTImageLoader.loadImage(icon), lockIcon));
+        } else {
+            GraphConstants.setIcon(attributes, ico);
+        }
+        imageDimension = new Dimension(ico.getIconWidth(), ico.getIconHeight());
+        GraphConstants.setSizeable(attributes, false);
+        GraphConstants.setSize(attributes, imageDimension);
+    }
 
-	// Giuseppe De Cicco & Fabio Granara
-	public void AddOut() {
-		out += 1;
-	}
+    // Giuseppe De Cicco & Fabio Granara
+    public void AddIn() {
+        in += 1;
+    }
 
-	// Giuseppe De Cicco & Fabio Granara
-	public void SubOut() {
-		out -= 1;
-	}
+    // Giuseppe De Cicco & Fabio Granara
+    public void SubIn() {
+        in -= 1;
+    }
 
-	/**
-	 * Returns Cell's real size (this method considers Icon and name size)
-	 *
-	 * @param graph <code>JGraph</code> object to retrieve font dimension informations
-	 * @return cell's real size
-	 *
-	 * Bertoli Marco  4-giu-2005
-	 */
-	public Dimension getSize(JGraph graph) {
-		Dimension cellDimension = (Dimension) imageDimension.clone();
-		// Gets the graph font
-		Font font = graph.getFont();
-		// Gets the graphical context
-		Graphics2D g2D = (Graphics2D) graph.getGraphics();
-		// Gets the bounds of the cell name
-		FontRenderContext frc = g2D.getFontRenderContext();
-		Rectangle r = font.getStringBounds(getUserObject().toString(), frc).getBounds();
-		// Sets the cell dimension
-		cellDimension.height += r.height + 5;
-		cellDimension.width = Math.max(cellDimension.width, r.width + 10);
-		return cellDimension;
-	}
+    // Giuseppe De Cicco & Fabio Granara
+    public void AddOut() {
+        out += 1;
+    }
 
-	/**
-	 * Creates the ports for this vertex
-	 *
-	 * @return array of ports
-	 */
-	public abstract Port[] createPorts();
+    // Giuseppe De Cicco & Fabio Granara
+    public void SubOut() {
+        out -= 1;
+    }
 
-	/**
-	 * Sets all the attributes like background colour, dimensions, port number
-	 * & position
-	 *
-	 * @param pt
-	 * @return created map
-	 */
-	public Hashtable<Object, Map> setAttributes(Point2D pt, JGraph graph) {
-		//contains attribute of the cell & ports
-		Hashtable<Object, Map> nest = new Hashtable<Object, Map>();
+    public int numInEdges() {
+        return in;
+    }
 
-		Dimension cellDimension = getSize(graph);
-		//contains attrib of cell
-		Map attr = getAttributes();
-		GraphConstants.setBounds(attr, new Rectangle2D.Double(pt.getX(), pt.getY(), cellDimension.getWidth(), cellDimension.getHeight()));
-		GraphConstants.setEditable(attr, false);
-		GraphConstants.setBackground(attr, graph.getBackground());
-		nest.put(this, attr);
+    public int numOutEdges() {
+        return out;
+    }
 
-		//create ports
-		ports = createPorts();
-		Icon icon = GraphConstants.getIcon(attr);
-		updatePortPositions(nest, icon, cellDimension);
-		for (Port port : ports) {
-			add((DefaultPort) port);
-		}
-		return nest;
-	}
+    public boolean isPinned() {
+        return ((CellComponent) getUserObject()).isPinned();
+    }
 
-	public void updatePortPositions(Map<Object, Map> nest, Icon icon, Dimension cellDimension) {
-		for (Port port : ports) {
-			Map attr = new Hashtable();
-			if (port instanceof InputPort && isLeftInputCell() || port instanceof OutputPort && !isLeftInputCell()) {
-				GraphConstants.setOffset(attr, getInPortOffset(icon, cellDimension));
-			} else {
-				GraphConstants.setOffset(attr, getOutPortoffset(icon, cellDimension));
-			}
-			nest.put(port, attr);
-		}
-	}
+    /**
+     * Returns Cell's real size (this method considers Icon and name size)
+     *
+     * @param graph <code>JGraph</code> object to retrieve font dimension informations
+     * @return cell's real size
+     * <p>
+     * Bertoli Marco  4-giu-2005
+     */
+    public Dimension getSize(JGraph graph) {
+        Dimension cellDimension = (Dimension) imageDimension.clone();
+        // Gets the graph font
+        Font font = graph.getFont();
+        // Gets the graphical context
+        Graphics2D g2D = (Graphics2D) graph.getGraphics();
+        // Gets the bounds of the cell name
+        FontRenderContext frc = g2D.getFontRenderContext();
+        Rectangle r = font.getStringBounds(getUserObject().toString(), frc).getBounds();
+        // Sets the cell dimension
+        cellDimension.height += r.height + 5;
+        cellDimension.width = Math.max(cellDimension.width, r.width + 10);
+        return cellDimension;
+    }
 
-	protected Point getInPortOffset(Icon icon, Dimension cellDimension) {
-		int iconHeight = icon.getIconHeight();
-		int iconWidth = icon.getIconWidth();
-		int xOff = (cellDimension.width - iconWidth) / 2 * 1000 / cellDimension.width;
-		int yOff = iconHeight / 2 * 1000 / cellDimension.height;
-		return new Point(xOff, yOff);
-	}
+    /**
+     * Creates the ports for this vertex
+     *
+     * @return array of ports
+     */
+    public abstract List<Port> createPorts();
 
-	protected Point getOutPortoffset(Icon icon, Dimension cellDimension) {
-		int iconHeight = icon.getIconHeight();
-		int iconWidth = icon.getIconWidth();
-		int xOff = (cellDimension.width - iconWidth) / 2 * 1000 / cellDimension.width + iconWidth * 1000 / cellDimension.width;
-		int yOff = iconHeight / 2 * 1000 / cellDimension.height;
-		return new Point(xOff, yOff);
-	}
+    /**
+     * Sets all the attributes like background colour, dimensions, port number
+     * & position
+     *
+     * @param pt
+     * @return created map
+     */
+    public Hashtable<Object, Map> setAttributes(Point2D pt, JGraph graph) {
+        //contains attribute of the cell & ports
+        Hashtable<Object, Map> nest = new Hashtable<Object, Map>();
 
-	/**
-	 * Tells if the InputPort of this cell is on the left side
-	 * @return true if the InputPort of this cell is on the left side
-	 */
-	// Giuseppe De Cicco & Fabio Granara
-	public boolean isLeftInputCell() {
-		return leftInputCell;
-	}
+        Dimension cellDimension = getSize(graph);
+        //contains attrib of cell
+        Map attr = getAttributes();
+        GraphConstants.setBounds(attr, new Rectangle2D.Double(pt.getX(), pt.getY(), cellDimension.getWidth(), cellDimension.getHeight()));
+        GraphConstants.setEditable(attr, false);
+        GraphConstants.setBackground(attr, graph.getBackground());
+        nest.put(this, attr);
 
-	// Giuseppe De Cicco & Fabio Granara
-	public void setLeftInputCell(boolean state) {
-		leftInputCell = state;
-	}
+        //create ports
+        ports = createPorts();
+        Icon icon = GraphConstants.getIcon(attr);
+        updatePortPositions(nest, icon, cellDimension);
+        for (Port port : ports) {
+            add((DefaultPort) port);
+        }
 
-	/**
-	 * Resets stored parent information for this cell
-	 */
-	public void resetParent() {
-		parentRef = getParent();
-	}
+        return nest;
+    }
 
-	/**
-	 * Tells if this cell parent was changed since last call to resetParent() method
-	 *
-	 * @return true if parent changed, false otherwise
-	 * @see #resetParent()
-	 */
-	public boolean parentChanged() {
-		if (parentRef == null && getParent() == null) {
-			return false;
-		} else if (parentRef == null || getParent() == null) {
-			return true;
-		} else {
-			return !parentRef.equals(getParent());
-		}
-	}
+    public void updatePortPositions(Map<Object, Map> nest, Icon icon, Dimension cellDimension) {
+        for (Port port : ports) {
+            Map attr = new Hashtable();
+            if (port instanceof InputPort && isLeftInputCell() || port instanceof OutputPort && !isLeftInputCell()) {
+                GraphConstants.setOffset(attr, getInPortOffset(icon, cellDimension));
+            } else {
+                Point offset = getOutPortoffset(icon, cellDimension);
+                GraphConstants.setOffset(attr, offset);
+            }
+            nest.put(port, attr);
+        }
+    }
 
-	/**
-	 * Tells if this station generates or destroys jobs (useful for blocking region
-	 * management)
-	 *
-	 * @return true if this station generates or destroy jobs, false otherwise
-	 */
-	public boolean generateOrDestroyJobs() {
-		return false;
-	}
+    protected Point getInPortOffset(Icon icon, Dimension cellDimension) {
+        int iconHeight = icon.getIconHeight();
+        int iconWidth = icon.getIconWidth();
+        int xOff = (cellDimension.width - iconWidth) / 2 * 1000 / cellDimension.width;
+        int yOff = iconHeight / 2 * 1000 / cellDimension.height;
+        return new Point(xOff, yOff);
+    }
 
-	/**
-	 * Returns previous parent of this cell (the one present when resetParent()
-	 * method was called)
-	 *
-	 * @return previous parent of this cell
-	 * @see #resetParent()
-	 */
-	public TreeNode getPrevParent() {
-		return parentRef;
-	}
+    protected Point getOutPortoffset(Icon icon, Dimension cellDimension) {
+        int iconHeight = icon.getIconHeight();
+        int iconWidth = icon.getIconWidth();
+        int xOff = (cellDimension.width - iconWidth) / 2 * 1000 / cellDimension.width + iconWidth * 1000 / cellDimension.width;
+        int yOff = iconHeight / 2 * 1000 / cellDimension.height;
+        return new Point(xOff, yOff);
+    }
 
-	/**
-	 * Returns the name of the icon of this cell
-	 *
-	 * @return the name of the icon of this cell
-	 */
-	public abstract String getIcon();
+    /**
+     * Tells if the InputPort of this cell is on the left side
+     *
+     * @return true if the InputPort of this cell is on the left side
+     */
+    // Giuseppe De Cicco & Fabio Granara
+    public boolean isLeftInputCell() {
+        return leftInputCell;
+    }
 
+    // Giuseppe De Cicco & Fabio Granara
+    public void setLeftInputCell(boolean state) {
+        leftInputCell = state;
+    }
+
+    /**
+     * Resets stored parent information for this cell
+     */
+    public void resetParent() {
+        parentRef = getParent();
+    }
+
+    /**
+     * Tells if this cell parent was changed since last call to resetParent() method
+     *
+     * @return true if parent changed, false otherwise
+     * @see #resetParent()
+     */
+    public boolean parentChanged() {
+        if (parentRef == null && getParent() == null) {
+            return false;
+        } else if (parentRef == null || getParent() == null) {
+            return true;
+        } else {
+            return !parentRef.equals(getParent());
+        }
+    }
+
+    /**
+     * Tells if this station generates or destroys jobs (useful for blocking region
+     * management)
+     *
+     * @return true if this station generates or destroy jobs, false otherwise
+     */
+    public boolean generateOrDestroyJobs() {
+        return false;
+    }
+
+    /**
+     * Returns previous parent of this cell (the one present when resetParent()
+     * method was called)
+     *
+     * @return previous parent of this cell
+     * @see #resetParent()
+     */
+    public TreeNode getPrevParent() {
+        return parentRef;
+    }
+
+    /**
+     * Returns the name of the icon of this cell
+     *
+     * @return the name of the icon of this cell
+     */
+    public abstract String getIcon();
 }
Index: src/main/java/jmt/gui/jsimgraph/JGraphMod/JmtJGraph.java
===================================================================
--- src/main/java/jmt/gui/jsimgraph/JGraphMod/JmtJGraph.java	(revision 978)
+++ src/main/java/jmt/gui/jsimgraph/JGraphMod/JmtJGraph.java	(working copy)
@@ -27,13 +27,7 @@
 import org.freehep.graphics2d.VectorGraphics;
 import org.freehep.graphicsbase.util.export.ExportDialog;
 import org.jgraph.JGraph;
-import org.jgraph.graph.BasicMarqueeHandler;
-import org.jgraph.graph.CellView;
-import org.jgraph.graph.DefaultCellViewFactory;
-import org.jgraph.graph.DefaultGraphModel;
-import org.jgraph.graph.DefaultGraphSelectionModel;
-import org.jgraph.graph.GraphLayoutCache;
-import org.jgraph.graph.GraphModel;
+import org.jgraph.graph.*;
 
 /** Jmt version of JGraph.
 
@@ -167,6 +161,24 @@
 		return null;
 	}
 
+	public InputPort getFreeInPortAt(int x, int y) {
+		JmtCell cell = getVertexAt(x, y);
+		for (int i = 0; i < getModel().getChildCount(cell); i++) {
+			Object child = getModel().getChild(cell, i);
+			if (child instanceof InputPort && ((InputPort) child).getEdges().size() == 0) {
+				return (InputPort) child;
+			}
+		}
+		if (cell != null) {
+			InputPort newPort = new InputPort(cell);
+			cell.insert(newPort, cell.getChildCount() - 1);
+			cell.AddIn();
+			getGraphLayoutCache().putMapping(newPort, new PortView(newPort));
+			return newPort;
+		}
+		return null;
+	}
+
 	/** Gets the outport port for the cell under Point(x,y)
 	 *
 	 * @param x  horizontal coordinate
@@ -242,6 +254,24 @@
 		Defaults.save();
 	}
 
+	public OutputPort getFreeOutPortAt(int x, int y) {
+		JmtCell cell = getVertexAt(x, y);
+		for (int i = 0; i < getModel().getChildCount(cell); i++) {
+			Object child = getModel().getChild(cell, i);
+			if (child instanceof OutputPort && ((OutputPort) child).getEdges().size() == 0) {
+				return (OutputPort) child;
+			}
+		}
+		if (cell != null) {
+			OutputPort newPort = new OutputPort(cell);
+			cell.insert(newPort, cell.getChildCount() - 1);
+			cell.AddOut();
+			getGraphLayoutCache().putMapping(newPort, new PortView(newPort));
+			return newPort;
+		}
+		return null;
+	}
+
 	// ------------------------------------------------------------------------------------------
 
 }
Index: src/main/java/jmt/gui/jsimgraph/JGraphMod/JmtRouting.java
===================================================================
--- src/main/java/jmt/gui/jsimgraph/JGraphMod/JmtRouting.java	(revision 978)
+++ src/main/java/jmt/gui/jsimgraph/JGraphMod/JmtRouting.java	(working copy)
@@ -18,11 +18,15 @@
 
 package jmt.gui.jsimgraph.JGraphMod;
 
+import java.awt.*;
 import java.awt.geom.Point2D;
 import java.awt.geom.Rectangle2D;
-import java.util.ArrayList;
+import java.lang.reflect.InvocationTargetException;
+import java.util.*;
 import java.util.List;
 
+import jmt.gui.common.JMTImageLoader;
+import jmt.gui.jsimgraph.controller.Mediator;
 import org.jgraph.graph.CellView;
 import org.jgraph.graph.DefaultPort;
 import org.jgraph.graph.Edge;
@@ -30,6 +34,10 @@
 import org.jgraph.graph.GraphConstants;
 import org.jgraph.graph.PortView;
 
+import javax.print.attribute.standard.Media;
+import javax.swing.*;
+
+
 /**
 
  * @author Federico Granata
@@ -41,6 +49,26 @@
  */
 public class JmtRouting implements Edge.Routing {
 
+	Mediator mediator;
+
+	interface Predicate<T> {
+		boolean evaluate(T v);
+	}
+
+	static <T> Map<Boolean, Collection<T>> partition(Predicate<T> predicate, Collection<T> collection) {
+		Map<Boolean, Collection<T>> result = new HashMap<>();
+		try {
+			result.put(true, collection.getClass().getConstructor().newInstance());
+			result.put(false, collection.getClass().getConstructor().newInstance());
+			for (T v: collection) {
+				result.get(predicate.evaluate(v)).add(v);
+			}
+		} catch (InstantiationException | IllegalAccessException | InvocationTargetException | NoSuchMethodException e) {
+			e.printStackTrace();
+		}
+		return result;
+	}
+
 	private static final long serialVersionUID = 1L;
 	private int offset = 15; //offset per il source
 	private int offsetTo2 = -15; //offset per il target
@@ -65,20 +93,20 @@
 
 			Point2D[] routed;
 			int offset = this.offset;
-			int changeoff = edge.getOffset();
+//			int changeoff = edge.getOffset();
 
 			int offsetTo2 = this.offsetTo2;
 			//int ringOffset=8;
-			Rectangle2D sourceBounds = (Rectangle2D) source.getAttributes().get("bounds");
-			Rectangle2D targetBounds = (Rectangle2D) target.getAttributes().get("bounds");
+			final Rectangle2D sourceBounds = (Rectangle2D) source.getAttributes().get("bounds");
+			final Rectangle2D targetBounds = (Rectangle2D) target.getAttributes().get("bounds");
 
 			//System.out.println("Punto del from: "+ from.getX()+", punto del bound: "+sourceBounds.getMaxX());
 			int boundFrom = (int) (sourceBounds.getCenterX() + (sourceBounds.getWidth() / 2));
 			int boundTo = (int) (targetBounds.getCenterX() - (targetBounds.getWidth() / 2));
-			if (changeoff > 0 && source.isLeftInputCell()) {
+/*			if (changeoff > 0 && source.isLeftInputCell()) {
 				//System.out.println(changeoff);
 				offset = changeoff + 15;
-			}
+			}*/
 			if (!source.isLeftInputCell()) {
 				offset = -offset;
 				//ringOffset=-ringOffset;
@@ -110,10 +138,10 @@
 				}
 				if ((((boundTo - boundFrom) > offset * (1.1)) && (offset > 0 && offsetTo2 < 0))
 						|| (((boundFrom - boundTo) > (-offset * (1.1))) && (offset < 0 && offsetTo2 > 0))) {
+
 					routed = new Point2D[2];
 					routed[0] = new Point2D.Double(boundFrom + offset, from.getY());
 					routed[1] = new Point2D.Double(routed[0].getX(), to.getY());
-
 				}
 				//____________inizio
 				else if ((offset < 0 && offsetTo2 < 0)) {
@@ -188,14 +216,71 @@
 				} else {
 
 					if ((from.getY() + sourceBounds.getHeight() - 4) < (to.getY() - (targetBounds.getHeight() / 2))) {
+						// edge going from right to left circumventing the model on the upper side
 						routed = new Point2D[4];
 						routed[0] = new Point2D.Double(boundFrom + offset, from.getY());
 						routed[3] = new Point2D.Double(boundTo + (offsetTo2), to.getY());
-						double maxY = sourceBounds.getMaxY() + 20;
-						routed[1] = new Point2D.Double(routed[0].getX(), maxY);
-						routed[2] = new Point2D.Double(routed[3].getX(), maxY);
+						//double maxY = sourceBounds.getMaxY() + 20;
+
+						List<OutputPort> outPorts = new ArrayList<>();
+						Enumeration ports = source.children();
+
+						while (ports.hasMoreElements()) {
+							Object port = ports.nextElement();
+							if (port instanceof OutputPort) {
+								outPorts.add((OutputPort) port);
+							}
+						}
+
+						double minY;
+						if (outPorts.size() > 1) {
+							Map<Boolean, Collection<OutputPort>> parts = partition(new Predicate<OutputPort>() {
+								@Override
+								public boolean evaluate(OutputPort v) {
+									JmtEdge e = (JmtEdge) (v.getEdges().iterator().next());
+									JmtCell thisTarget = (JmtCell) ((InputPort) e.getTarget()).getParent();
+									Rectangle2D thisTargetBounds = (Rectangle2D) thisTarget.getAttributes().get("bounds");
+									return thisTargetBounds.getX() > targetBounds.getX() && thisTargetBounds.getX() < sourceBounds.getX();
+								}
+							}, outPorts);
+							minY = Math.min(sourceBounds.getMinY() - 30 * (parts.get(true).size() + 1), targetBounds.getMinY() - 30);
+						} else {
+							minY = Math.min(sourceBounds.getMinY() - 30, targetBounds.getMinY() - 36);
+						}
+
+						routed[1] = new Point2D.Double(routed[0].getX(), minY);
+						routed[2] = new Point2D.Double(routed[3].getX(), minY);
+						if (offset > 0) {
+							double x;
+							double left = sourceBounds.getX() - offset - 4;
+							x = Math.min(routed[2].getX(), left);
+							routed[2].setLocation(x, routed[2].getY());
+							routed[3].setLocation(x, routed[3].getY());
+
+							if (from.getY() < to.getY()) {
+								double x2;
+								double right = targetBounds.getX() + targetBounds.getWidth() + offset;
+								x2 = Math.max(routed[0].getX(), right);
+								routed[0].setLocation(x2, routed[0].getY());
+								routed[1].setLocation(x2, routed[1].getY());
+							}
+						} else {
+							double x;
+							double left = sourceBounds.getX() + sourceBounds.getWidth() + offset + 4;
+							x = Math.max(routed[2].getX(), left);
+							routed[2].setLocation(x, routed[2].getY());
+							routed[3].setLocation(x, routed[3].getY());
+
+							if (from.getY() < to.getY()) {
+								double x2;
+								double left2 = targetBounds.getX() - offset;
+								x2 = Math.min(routed[0].getX(), left2);
+								routed[0].setLocation(x2, routed[0].getY());
+								routed[1].setLocation(x2, routed[1].getY());
+							}
+						}
 					} else {
-
+						// edge going from right to left circumventing the model on the lower side
 						routed = new Point2D[4];
 						routed[0] = new Point2D.Double(boundFrom + offset, from.getY());
 						//System.out.println("Differenza "+ (sourceBounds.getMaxY()-(routed[0].getY() + sourceBounds.getBounds().getHeight()+2)));
@@ -202,7 +287,33 @@
 						routed[3] = new Point2D.Double(boundTo + offsetTo2, to.getY());
 						//double maxY = Math.max(routed[0].getY() + sourceBounds.getBounds().getHeight()+2,
 						//		routed[3].getY() + targetBounds.getBounds().getHeight()+8);
-						double maxY = Math.max(sourceBounds.getMaxY() + 20, targetBounds.getMaxY() + 26);
+
+						List<OutputPort> outPorts = new ArrayList<>();
+						Enumeration ports = source.children();
+
+						while (ports.hasMoreElements()) {
+							Object port = ports.nextElement();
+							if (port instanceof OutputPort) {
+								outPorts.add((OutputPort) port);
+							}
+						}
+
+						double maxY;
+						if (outPorts.size() > 1) {
+							Map<Boolean, Collection<OutputPort>> parts = partition(new Predicate<OutputPort>() {
+								@Override
+								public boolean evaluate(OutputPort v) {
+									JmtEdge e = (JmtEdge) (v.getEdges().iterator().next());
+									JmtCell thisTarget = (JmtCell) ((InputPort) e.getTarget()).getParent();
+									Rectangle2D thisTargetBounds = (Rectangle2D) thisTarget.getAttributes().get("bounds");
+									return thisTargetBounds.getX() > targetBounds.getX() && thisTargetBounds.getX() < sourceBounds.getX();
+								}
+							}, outPorts);
+							maxY = Math.max(sourceBounds.getMaxY() + 20 * (parts.get(true).size() + 1), targetBounds.getMaxY() + 26);
+						} else {
+							maxY = Math.max(sourceBounds.getMaxY() + 20, targetBounds.getMaxY() + 26);
+						}
+
 						routed[1] = new Point2D.Double(routed[0].getX(), maxY);
 						routed[2] = new Point2D.Double(routed[3].getX(), maxY);
 
@@ -238,18 +349,211 @@
 					}
 				}
 			}
+
+			double startY = from.getY();
+			{
+				Icon i = JMTImageLoader.loadImage(source.getIcon());
+				Dimension d = source.getSize(mediator.getGraph());
+				// Handle multiple outgoing edges from the same JmtCell
+				Dimension sourceSize = (Dimension) source.getAttributes().get("size");
+
+				List<OutputPort> outPorts = new ArrayList<>();
+				Enumeration ports = source.children();
+
+				while (ports.hasMoreElements()) {
+					Object port = ports.nextElement();
+					if (port instanceof OutputPort) {
+						outPorts.add((OutputPort) port);
+					}
+				}
+
+				double division = sourceSize.getHeight() / (source.numOutEdges() + 1.0);
+				double divisionOffset = source.getOutPortoffset(i, d).getY() * 2 / (source.numOutEdges() + 1.0);
+
+				Collections.sort(outPorts, new Comparator<OutputPort>() {
+					@Override
+					public int compare(OutputPort o1, OutputPort o2) {
+						JmtEdge e1 = (JmtEdge) (o1.getEdges().iterator().next());
+						JmtEdge e2 = (JmtEdge) (o2.getEdges().iterator().next());
+
+						JmtCell c1 = (JmtCell) ((InputPort) e1.getTarget()).getParent();
+						JmtCell c2 = (JmtCell) ((InputPort) e2.getTarget()).getParent();
+
+						return (int) Math.ceil(((Rectangle2D) c1.getAttributes().get("bounds")).getMaxY() - ((Rectangle2D) c2.getAttributes().get("bounds")).getMaxY());
+					}
+				});
+
+				// modify X coordinate of points aligned to matching output port in order to avoid overlap of edges going in the same vertical direction
+				double sOutOffsY = -1;
+				for (int index = 0; index < outPorts.size(); index++) {
+					OutputPort outPort = outPorts.get(index);
+					JmtEdge outEdge = (JmtEdge) (outPort.getEdges().iterator().next());
+					JmtCell targetO = (JmtCell) ((InputPort) outEdge.getTarget()).getParent();
+					if (targetO == target) {
+						startY = sourceBounds.getMinY() + (division * (index + 1));
+						routed[0].setLocation(routed[0].getX(), startY);
+						sOutOffsY = divisionOffset * (index + 1);
+					}
+
+					Point2D portOffset = source.isLeftInputCell() ? source.getOutPortoffset(i, d) : source.getInPortOffset(i, d);
+					if (outPort.getAttributes().get("offset") != null) {
+						((Point2D.Double) outPort.getAttributes().get("offset")).setLocation(portOffset.getX(), divisionOffset * (index + 1));
+					} else {
+						outPort.getAttributes().put("offset", new Point2D.Double(portOffset.getX(), divisionOffset * (index + 1)));
+					}
+				}
+
+				if (outPorts.size() > 1) {
+					final double sourceOutOffsetY = sOutOffsY; // resolve stupid constraint on final variables in Java pre-8 "closures"
+					if (routed[1].getY() < routed[0].getY()) {
+						// edge is going up
+						Map<Boolean, Collection<OutputPort>> parts = partition(new Predicate<OutputPort>() {
+							@Override
+							public boolean evaluate(OutputPort v) {
+								return ((Point2D.Double) v.getAttributes().get("offset")).getY() <= sourceOutOffsetY;
+							}
+						}, outPorts);
+						routed[0].setLocation(routed[0].getX() + offset * (parts.get(true).size() - 1), routed[0].getY());
+						routed[1].setLocation(routed[0].getX(), routed[1].getY());
+					} else if (routed[1].getY() > routed[0].getY()) {
+						// edge is going down
+						Map<Boolean, Collection<OutputPort>> parts = partition(new Predicate<OutputPort>() {
+							@Override
+							public boolean evaluate(OutputPort v) {
+								return ((Point2D.Double) v.getAttributes().get("offset")).getY() >= sourceOutOffsetY;
+							}
+						}, outPorts);
+						routed[0].setLocation(routed[0].getX() + offset * (parts.get(true).size() - 1), routed[0].getY());
+						routed[1].setLocation(routed[0].getX(), routed[1].getY());
+					}
+				}
+ 			}
+
+			double finalY = to.getY();
+			{
+				Icon i = JMTImageLoader.loadImage(target.getIcon());
+				Dimension d = target.getSize(mediator.getGraph());
+				// Handle multiple incoming edges to the same JmtCell
+				Dimension targetSize = (Dimension) target.getAttributes().get("size");
+
+				List<InputPort> inPorts = new ArrayList<>();
+				Enumeration ports = target.children();
+
+				while (ports.hasMoreElements()) {
+					Object port = ports.nextElement();
+					if (port instanceof InputPort) {
+						inPorts.add((InputPort) port);
+					}
+				}
+
+				double division = targetSize.getHeight() / (target.numInEdges() + 1.0);
+				double divisionOffset = target.getInPortOffset(i, d).getY() * 2 / (target.numInEdges() + 1.0);
+
+				Collections.sort(inPorts, new Comparator<InputPort>() {
+					@Override
+					public int compare(InputPort o1, InputPort o2) {
+						JmtEdge e1 = (JmtEdge) (o1.getEdges().iterator().next());
+						JmtEdge e2 = (JmtEdge) (o2.getEdges().iterator().next());
+
+						JmtCell c1 = (JmtCell) ((OutputPort) e1.getSource()).getParent();
+						JmtCell c2 = (JmtCell) ((OutputPort) e2.getSource()).getParent();
+
+						return (int) Math.ceil(((Rectangle2D) c1.getAttributes().get("bounds")).getMaxY() - ((Rectangle2D) c2.getAttributes().get("bounds")).getMaxY());
+					}
+				});
+
+				double sInOffsY = -1;
+				for (int index = 0; index < inPorts.size(); index++) {
+					InputPort inPort = inPorts.get(index);
+					JmtEdge inEdge = (JmtEdge) (inPort.getEdges().iterator().next());
+					JmtCell sourceI = (JmtCell) ((OutputPort) inEdge.getSource()).getParent();
+					if (sourceI == source) {
+						finalY = targetBounds.getMinY() + (division * (index + 1));
+						routed[routed.length - 1] = new Point2D.Double(routed[routed.length - 1].getX(), finalY);
+						sInOffsY = divisionOffset * (index + 1);
+					}
+
+					Point2D portOffset = target.isLeftInputCell() ? target.getInPortOffset(i, d) : target.getOutPortoffset(i, d);
+					if (inPort.getAttributes().get("offset") != null) {
+						((Point2D.Double) inPort.getAttributes().get("offset")).setLocation(portOffset.getX(), divisionOffset * (index + 1));
+					} else {
+						inPort.getAttributes().put("offset", new Point2D.Double(portOffset.getX(), divisionOffset * (index + 1)));
+					}
+				}
+
+				if (inPorts.size() > 1) {
+					double factor = 1;
+					final double targetInOffsetY = sInOffsY; // resolve stupid constraint on final variables in Java pre-8 "closures"
+					if (routed[routed.length - 1].getY() < routed[routed.length - 2].getY()) {
+						// edge is going up
+						Map<Boolean, Collection<InputPort>> parts = partition(new Predicate<InputPort>() {
+							@Override
+							public boolean evaluate(InputPort v) {
+								return ((Point2D.Double) v.getAttributes().get("offset")).getY() >= targetInOffsetY;
+							}
+						}, inPorts);
+
+						// if edge is coming from the left invert sign of offset
+						if (routed.length > 2 && routed[routed.length - 1].getX() < routed[routed.length - 3].getX()) {
+							factor = -1;
+						}
+
+						routed[routed.length - 1].setLocation(routed[routed.length - 1].getX() + factor * offset * (parts.get(false).size()), routed[routed.length - 1].getY());
+						routed[routed.length - 2].setLocation(routed[routed.length - 1].getX(), routed[routed.length - 2].getY());
+
+					} else if (routed[routed.length - 1].getY() > routed[routed.length - 2].getY()) {
+						// edge is going down
+						Map<Boolean, Collection<InputPort>> parts = partition(new Predicate<InputPort>() {
+							@Override
+							public boolean evaluate(InputPort v) {
+								return ((Point2D.Double) v.getAttributes().get("offset")).getY() <= targetInOffsetY;
+							}
+						}, inPorts);
+
+						if (routed.length > 2 && routed[routed.length - 1].getX() < routed[routed.length - 3].getX()) {
+							factor = -1;
+						}
+
+						routed[routed.length - 1].setLocation(routed[routed.length - 1].getX() + factor * offset * (parts.get(false).size()), routed[routed.length - 1].getY());
+						routed[routed.length - 2].setLocation(routed[routed.length - 1].getX(), routed[routed.length - 2].getY());
+					}
+				}
+			}
+
+			if (target.isLeftInputCell() && (routed[routed.length - 1].getX() > (targetBounds.getMinX() - offset)) && routed.length > 1 && routed[routed.length - 1] != null && routed[routed.length - 2] != null) {
+				routed[routed.length - 1].setLocation(routed[routed.length - 1].getX() - 2 * Math.max(offset, routed[routed.length - 1].getX() - targetBounds.getMinX()), routed[routed.length - 1].getY());
+
+				Point2D newRouted[] = new Point2D[routed.length + 2];
+				System.arraycopy(routed, 0, newRouted, 0, routed.length - 1);
+				double diffY = Math.abs(routed[routed.length - 2].getY() - routed[routed.length - 1].getY()) * 0.5;
+				if (routed[routed.length - 1].getY() > routed[routed.length - 2].getY()) {
+					// edge is going down
+					newRouted[routed.length - 1] = new Point2D.Double(routed[routed.length - 2].getX(), routed[routed.length - 2].getY() + diffY);
+					newRouted[routed.length] = new Point2D.Double(routed[routed.length - 1].getX(), routed[routed.length - 2].getY() + diffY);
+				} else {
+					newRouted[routed.length - 1] = new Point2D.Double(routed[routed.length - 2].getX(), routed[routed.length - 2].getY() - diffY);
+					newRouted[routed.length] = new Point2D.Double(routed[routed.length - 1].getX(), routed[routed.length - 2].getY() - diffY);
+				}
+
+				newRouted[routed.length + 1] = routed[routed.length - 1];
+
+				routed = newRouted;
+
+			}
+
 			//Sets add points
-			list.add(from);
-			for (Point2D element : routed) {
-				list.add(element);
-			}
-			list.add(to);
+			list.add(new Point2D.Double(from.getX(), startY));
+			Collections.addAll(list, routed);
+			list.add(new Point2D.Double(to.getX(), finalY));
 		}
 		return list;
 	}
 
+	public void setMediator(Mediator m) {
+		mediator = m;
+	}
+
 	public int getPreferredLineStyle(EdgeView edgeView) {
-
 		return GraphConstants.STYLE_ORTHOGONAL;
 	}
 
Index: src/main/java/jmt/gui/jsimgraph/JGraphMod/JoinCell.java
===================================================================
--- src/main/java/jmt/gui/jsimgraph/JGraphMod/JoinCell.java	(revision 978)
+++ src/main/java/jmt/gui/jsimgraph/JGraphMod/JoinCell.java	(working copy)
@@ -22,6 +22,9 @@
 
 import org.jgraph.graph.Port;
 
+import java.util.LinkedList;
+import java.util.List;
+
 /**
  * Generates new jobs in open systems, it generates jobs of 1 JobClass only
  *
@@ -59,10 +62,14 @@
 	 * @return array of ports
 	 */
 	@Override
-	public Port[] createPorts() {
-		Port[] ports = new Port[2];
+	public List<Port> createPorts() {
+		/*Port[] ports = new Port[2];
 		ports[0] = new InputPort(this);
 		ports[1] = new OutputPort(this);
+		return ports;*/
+		List<Port> ports = new LinkedList<>();
+		ports.add(new InputPort(this));
+		ports.add(new OutputPort(this));
 		return ports;
 	}
 
Index: src/main/java/jmt/gui/jsimgraph/JGraphMod/LoggerCell.java
===================================================================
--- src/main/java/jmt/gui/jsimgraph/JGraphMod/LoggerCell.java	(revision 978)
+++ src/main/java/jmt/gui/jsimgraph/JGraphMod/LoggerCell.java	(working copy)
@@ -21,6 +21,9 @@
 
 import org.jgraph.graph.Port;
 
+import java.util.LinkedList;
+import java.util.List;
+
 /**
  * <p>Title: Logger Cell</p>
  * <p>Description: </p>
@@ -51,10 +54,14 @@
 	 * @return array of ports
 	 */
 	@Override
-	public Port[] createPorts() {
-		Port[] ports = new Port[2];
+	public List<Port> createPorts() {
+		/*Port[] ports = new Port[2];
 		ports[0] = new InputPort(this);
 		ports[1] = new OutputPort(this);
+		return ports;*/
+		List<Port> ports = new LinkedList<>();
+		ports.add(new InputPort(this));
+		ports.add(new OutputPort(this));
 		return ports;
 	}
 
Index: src/main/java/jmt/gui/jsimgraph/JGraphMod/PlaceCell.java
===================================================================
--- src/main/java/jmt/gui/jsimgraph/JGraphMod/PlaceCell.java	(revision 978)
+++ src/main/java/jmt/gui/jsimgraph/JGraphMod/PlaceCell.java	(working copy)
@@ -22,6 +22,9 @@
 
 import org.jgraph.graph.Port;
 
+import java.util.LinkedList;
+import java.util.List;
+
 /**
  * Place Cell, represents the place of SPN models.
  *
@@ -59,10 +62,14 @@
 	 * @return array of ports
 	 */
 	@Override
-	public Port[] createPorts() {
-		Port[] ports = new Port[2];
+	public List<Port> createPorts() {
+		/*Port[] ports = new Port[2];
 		ports[0] = new InputPort(this);
 		ports[1] = new OutputPort(this);
+		return ports;*/
+		List<Port> ports = new LinkedList<>();
+		ports.add(new InputPort(this));
+		ports.add(new OutputPort(this));
 		return ports;
 	}
 
Index: src/main/java/jmt/gui/jsimgraph/JGraphMod/RoutingStationCell.java
===================================================================
--- src/main/java/jmt/gui/jsimgraph/JGraphMod/RoutingStationCell.java	(revision 978)
+++ src/main/java/jmt/gui/jsimgraph/JGraphMod/RoutingStationCell.java	(working copy)
@@ -21,6 +21,9 @@
 
 import org.jgraph.graph.Port;
 
+import java.util.LinkedList;
+import java.util.List;
+
 /**
  * <p>Title: Router Cell</p>
  * <p>Description: Routes jobs without servicing capability. This special class was introduced
@@ -60,10 +63,14 @@
 	 * @return array of ports
 	 */
 	@Override
-	public Port[] createPorts() {
-		Port[] ports = new Port[2];
+	public List<Port> createPorts() {
+		/*Port[] ports = new Port[2];
 		ports[0] = new InputPort(this);
 		ports[1] = new OutputPort(this);
+		return ports;*/
+		List<Port> ports = new LinkedList<>();
+		ports.add(new InputPort(this));
+		ports.add(new OutputPort(this));
 		return ports;
 	}
 
Index: src/main/java/jmt/gui/jsimgraph/JGraphMod/ScalerCell.java
===================================================================
--- src/main/java/jmt/gui/jsimgraph/JGraphMod/ScalerCell.java	(revision 978)
+++ src/main/java/jmt/gui/jsimgraph/JGraphMod/ScalerCell.java	(working copy)
@@ -22,6 +22,9 @@
 
 import org.jgraph.graph.Port;
 
+import java.util.LinkedList;
+import java.util.List;
+
 /**
  * @author Vitor S. Lopes
  * Date: 25-jul-2016
@@ -57,10 +60,14 @@
 	 * @return array of ports
 	 */
 	@Override
-	public Port[] createPorts() {
-		Port[] ports = new Port[2];
+	public List<Port> createPorts() {
+		/*Port[] ports = new Port[2];
 		ports[0] = new InputPort(this);
 		ports[1] = new OutputPort(this);
+		return ports;*/
+		List<Port> ports = new LinkedList<>();
+		ports.add(new InputPort(this));
+		ports.add(new OutputPort(this));
 		return ports;
 	}
 
Index: src/main/java/jmt/gui/jsimgraph/JGraphMod/SemaphoreCell.java
===================================================================
--- src/main/java/jmt/gui/jsimgraph/JGraphMod/SemaphoreCell.java	(revision 978)
+++ src/main/java/jmt/gui/jsimgraph/JGraphMod/SemaphoreCell.java	(working copy)
@@ -22,6 +22,9 @@
 
 import org.jgraph.graph.Port;
 
+import java.util.LinkedList;
+import java.util.List;
+
 /**
  * @author Vitor S. Lopes
  * Date: 25-jul-2016
@@ -57,11 +60,16 @@
 	 * @return array of ports
 	 */
 	@Override
-	public Port[] createPorts() {
-		Port[] ports = new Port[2];
+	public List<Port> createPorts() {
+		/*Port[] ports = new Port[2];
 		ports[0] = new InputPort(this);
 		ports[1] = new OutputPort(this);
+		return ports;*/
+		List<Port> ports = new LinkedList<>();
+		ports.add(new InputPort(this));
+		ports.add(new OutputPort(this));
 		return ports;
+
 	}
 
 	/**
Index: src/main/java/jmt/gui/jsimgraph/JGraphMod/ServerCell.java
===================================================================
--- src/main/java/jmt/gui/jsimgraph/JGraphMod/ServerCell.java	(revision 978)
+++ src/main/java/jmt/gui/jsimgraph/JGraphMod/ServerCell.java	(working copy)
@@ -22,6 +22,9 @@
 
 import org.jgraph.graph.Port;
 
+import java.util.LinkedList;
+import java.util.List;
+
 /**
  * Queue Cell, represents the default service center of the model.
  *
@@ -59,10 +62,14 @@
 	 * @return array of ports
 	 */
 	@Override
-	public Port[] createPorts() {
-		Port[] ports = new Port[2];
+	public List<Port> createPorts() {
+		/*Port[] ports = new Port[2];
 		ports[0] = new InputPort(this);
 		ports[1] = new OutputPort(this);
+		return ports;*/
+		List<Port> ports = new LinkedList<>();
+		ports.add(new InputPort(this));
+		ports.add(new OutputPort(this));
 		return ports;
 	}
 
Index: src/main/java/jmt/gui/jsimgraph/JGraphMod/SinkCell.java
===================================================================
--- src/main/java/jmt/gui/jsimgraph/JGraphMod/SinkCell.java	(revision 978)
+++ src/main/java/jmt/gui/jsimgraph/JGraphMod/SinkCell.java	(working copy)
@@ -22,6 +22,9 @@
 
 import org.jgraph.graph.Port;
 
+import java.util.LinkedList;
+import java.util.List;
+
 /**
  * Represents a Sink service center, it used to destroy jobs in open systems
  *
@@ -59,9 +62,12 @@
 	 * @return array of ports
 	 */
 	@Override
-	public Port[] createPorts() {
-		Port[] ports = new Port[1];
+	public List<Port> createPorts() {
+		/*Port[] ports = new Port[1];
 		ports[0] = new InputPort(this);
+		return ports;*/
+		List<Port> ports = new LinkedList<>();
+		ports.add(new InputPort(this));
 		return ports;
 	}
 
Index: src/main/java/jmt/gui/jsimgraph/JGraphMod/SourceCell.java
===================================================================
--- src/main/java/jmt/gui/jsimgraph/JGraphMod/SourceCell.java	(revision 978)
+++ src/main/java/jmt/gui/jsimgraph/JGraphMod/SourceCell.java	(working copy)
@@ -22,6 +22,9 @@
 
 import org.jgraph.graph.Port;
 
+import java.util.LinkedList;
+import java.util.List;
+
 /**
  * Generates new jobs in open systems, it generates jobs of 1 JobClass only
  *
@@ -59,9 +62,12 @@
 	 * @return array of ports
 	 */
 	@Override
-	public Port[] createPorts() {
-		Port[] ports = new Port[1];
+	public List<Port> createPorts() {
+		/*Port[] ports = new Port[1];
 		ports[0] = new OutputPort(this);
+		return ports;*/
+		List<Port> ports = new LinkedList<>();
+		ports.add(new OutputPort(this));
 		return ports;
 	}
 
Index: src/main/java/jmt/gui/jsimgraph/JGraphMod/TerminalCell.java
===================================================================
--- src/main/java/jmt/gui/jsimgraph/JGraphMod/TerminalCell.java	(revision 978)
+++ src/main/java/jmt/gui/jsimgraph/JGraphMod/TerminalCell.java	(working copy)
@@ -22,6 +22,9 @@
 
 import org.jgraph.graph.Port;
 
+import java.util.LinkedList;
+import java.util.List;
+
 /**
  * Generates new jobs in open systems, it generates jobs of 1 JobClass only
  *
@@ -58,10 +61,14 @@
 	 * @return array of ports
 	 */
 	@Override
-	public Port[] createPorts() {
-		Port[] ports = new Port[2];
+	public List<Port> createPorts() {
+	/*	Port[] ports = new Port[2];
 		ports[0] = new InputPort(this);
 		ports[1] = new OutputPort(this);
+		return ports;*/
+		List<Port> ports = new LinkedList<>();
+		ports.add(new InputPort(this));
+		ports.add(new OutputPort(this));
 		return ports;
 	}
 
Index: src/main/java/jmt/gui/jsimgraph/JGraphMod/TransitionCell.java
===================================================================
--- src/main/java/jmt/gui/jsimgraph/JGraphMod/TransitionCell.java	(revision 978)
+++ src/main/java/jmt/gui/jsimgraph/JGraphMod/TransitionCell.java	(working copy)
@@ -22,6 +22,9 @@
 
 import org.jgraph.graph.Port;
 
+import java.util.LinkedList;
+import java.util.List;
+
 /**
  * Transition Cell, represents the transition of SPN models.
  *
@@ -59,10 +62,14 @@
 	 * @return array of ports
 	 */
 	@Override
-	public Port[] createPorts() {
-		Port[] ports = new Port[2];
+	public List<Port> createPorts() {
+		/*Port[] ports = new Port[2];
 		ports[0] = new InputPort(this);
 		ports[1] = new OutputPort(this);
+		return ports;*/
+		List<Port> ports = new LinkedList<>();
+		ports.add(new InputPort(this));
+		ports.add(new OutputPort(this));
 		return ports;
 	}
 
Index: src/main/java/jmt/gui/jsimgraph/controller/ConnectState.java
===================================================================
--- src/main/java/jmt/gui/jsimgraph/controller/ConnectState.java	(revision 978)
+++ src/main/java/jmt/gui/jsimgraph/controller/ConnectState.java	(working copy)
@@ -64,7 +64,7 @@
 	public void handlePress(MouseEvent e) {
 		if (!e.isConsumed()) {
 			start = mediator.snap(e.getPoint());
-			firstPort = port = getOutPortViewAt(e.getX(), e.getY());
+			firstPort = port = getFreeOutPortViewAt(e.getX(), e.getY());
 			if (firstPort != null) {
 				start = mediator.toScreen(firstPort.getLocation(null));
 			}
@@ -113,7 +113,7 @@
 	@Override
 	public void handleRelease(MouseEvent e) {
 		if (e != null && !e.isConsumed()) {
-			PortView end = getInPortViewAt(e.getX(), e.getY());
+			PortView end = getFreeInPortViewAt(e.getX(), e.getY());
 			if (end != null) {
 				mediator.connect(start, current, end, firstPort);
 				if ((firstPort != null) && ((VertexView) (firstPort.getParentView()) != null)) {
@@ -133,6 +133,10 @@
 		current = null;
 	}
 
+	private PortView getFreeInPortViewAt(int x, int y) {
+		return mediator.getFreeInPortViewAt(x, y);
+	}
+
 	/** gets the first portView of the input port of the cell at position
 	 *
 	 * @param x
@@ -153,6 +157,10 @@
 		return mediator.getOutPortViewAt(x, y);
 	}
 
+	protected PortView getFreeOutPortViewAt(int x, int y) {
+		return mediator.getFreeOutPortViewAt(x, y);
+	}
+
 	public void overlay(Graphics2D g) {
 		if (start != null && current != null) {
 			g.draw(new Line2D.Double(start.getX(), start.getY(), current.getX(), current.getY()));
Index: src/main/java/jmt/gui/jsimgraph/controller/JmtGraphUI.java
===================================================================
--- src/main/java/jmt/gui/jsimgraph/controller/JmtGraphUI.java	(revision 978)
+++ src/main/java/jmt/gui/jsimgraph/controller/JmtGraphUI.java	(working copy)
@@ -142,6 +142,7 @@
 				mediator.enableAddBlockingRegion(!cannotAddBlockingRegion);
 				mediator.enableRotateAction(true);
 				mediator.enableSetRight(true);
+				mediator.enableSnapToGrid(true);
 			} else if (foundBlockingRegion) {
 				mediator.enableCopyAction(true);
 				mediator.enableCutAction(true);
Index: src/main/java/jmt/gui/jsimgraph/controller/Mediator.java
===================================================================
--- src/main/java/jmt/gui/jsimgraph/controller/Mediator.java	(revision 978)
+++ src/main/java/jmt/gui/jsimgraph/controller/Mediator.java	(working copy)
@@ -32,21 +32,14 @@
 import java.awt.geom.Point2D;
 import java.awt.geom.Rectangle2D;
 import java.io.File;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.Hashtable;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-import java.util.Vector;
+import java.io.ObjectInput;
+import java.util.*;
 
-import javax.swing.ImageIcon;
-import javax.swing.JFrame;
-import javax.swing.JOptionPane;
+import javax.swing.*;
 
+import javafx.scene.control.Cell;
+import jdk.internal.util.xml.impl.Input;
+import jmt.commandline.Jmt;
 import jmt.framework.gui.components.JMTMenuBar;
 import jmt.framework.gui.components.JMTToolBar;
 import jmt.framework.gui.image.ImageLoader;
@@ -54,6 +47,7 @@
 import jmt.gui.common.CommonConstants;
 import jmt.gui.common.Defaults;
 import jmt.gui.common.JMTImageLoader;
+import jmt.gui.common.MergedIcon;
 import jmt.gui.common.controller.DispatcherThread;
 import jmt.gui.common.controller.ModelChecker;
 import jmt.gui.common.controller.PADispatcherThread;
@@ -78,56 +72,8 @@
 import jmt.gui.common.xml.ModelLoader;
 import jmt.gui.common.xml.XMLWriter;
 import jmt.gui.jsimgraph.DialogFactory;
-import jmt.gui.jsimgraph.JGraphMod.BlockingRegion;
-import jmt.gui.jsimgraph.JGraphMod.CellComponent;
-import jmt.gui.jsimgraph.JGraphMod.CellFactory;
-import jmt.gui.jsimgraph.JGraphMod.InputPort;
-import jmt.gui.jsimgraph.JGraphMod.JmtCell;
-import jmt.gui.jsimgraph.JGraphMod.JmtDefaultCellViewFactory;
-import jmt.gui.jsimgraph.JGraphMod.JmtEdge;
-import jmt.gui.jsimgraph.JGraphMod.JmtEdgeView;
-import jmt.gui.jsimgraph.JGraphMod.JmtGraphConstants;
-import jmt.gui.jsimgraph.JGraphMod.JmtJGraph;
-import jmt.gui.jsimgraph.JGraphMod.JmtOverlapping;
-import jmt.gui.jsimgraph.JGraphMod.OutputPort;
-import jmt.gui.jsimgraph.JGraphMod.SinkCell;
-import jmt.gui.jsimgraph.JGraphMod.SourceCell;
-import jmt.gui.jsimgraph.controller.actions.About;
-import jmt.gui.jsimgraph.controller.actions.AbstractJmodelAction;
-import jmt.gui.jsimgraph.controller.actions.ActionCopy;
-import jmt.gui.jsimgraph.controller.actions.ActionCut;
-import jmt.gui.jsimgraph.controller.actions.ActionDelete;
-import jmt.gui.jsimgraph.controller.actions.ActionPaste;
-import jmt.gui.jsimgraph.controller.actions.ActionRedo;
-import jmt.gui.jsimgraph.controller.actions.ActionRotate;
-import jmt.gui.jsimgraph.controller.actions.ActionSetRight;
-import jmt.gui.jsimgraph.controller.actions.ActionUndo;
-import jmt.gui.jsimgraph.controller.actions.AddBlockingRegion;
-import jmt.gui.jsimgraph.controller.actions.CloseModel;
-import jmt.gui.jsimgraph.controller.actions.DownloadDefaultTemplates;
-import jmt.gui.jsimgraph.controller.actions.EditDefaults;
-import jmt.gui.jsimgraph.controller.actions.EditMeasures;
-import jmt.gui.jsimgraph.controller.actions.EditPAParams;
-import jmt.gui.jsimgraph.controller.actions.EditSimParams;
-import jmt.gui.jsimgraph.controller.actions.EditUserClasses;
-import jmt.gui.jsimgraph.controller.actions.Exit;
-import jmt.gui.jsimgraph.controller.actions.NewModel;
-import jmt.gui.jsimgraph.controller.actions.OpenHelp;
-import jmt.gui.jsimgraph.controller.actions.OpenModel;
-import jmt.gui.jsimgraph.controller.actions.PauseSimulation;
-import jmt.gui.jsimgraph.controller.actions.SaveModel;
-import jmt.gui.jsimgraph.controller.actions.SaveModelAs;
-import jmt.gui.jsimgraph.controller.actions.SetConnectState;
-import jmt.gui.jsimgraph.controller.actions.SetOptions;
-import jmt.gui.jsimgraph.controller.actions.SetSelectState;
-import jmt.gui.jsimgraph.controller.actions.ShowResults;
-import jmt.gui.jsimgraph.controller.actions.Simulate;
-import jmt.gui.jsimgraph.controller.actions.SolveAnalytic;
-import jmt.gui.jsimgraph.controller.actions.SolveApprox;
-import jmt.gui.jsimgraph.controller.actions.StopSimulation;
-import jmt.gui.jsimgraph.controller.actions.SwitchToExactSolver;
-import jmt.gui.jsimgraph.controller.actions.TakeScreenShot;
-import jmt.gui.jsimgraph.controller.actions.UseTemplate;
+import jmt.gui.jsimgraph.JGraphMod.*;
+import jmt.gui.jsimgraph.controller.actions.*;
 import jmt.gui.jsimgraph.definitions.JMTPoint;
 import jmt.gui.jsimgraph.definitions.JSimGraphModel;
 import jmt.gui.jsimgraph.definitions.JmodelClassDefinition;
@@ -233,6 +179,7 @@
 	private AbstractJmodelAction takeScreenShot;
 	private AbstractJmodelAction actionRotate;
 	private AbstractJmodelAction actionSetRight;
+	private AbstractJmodelAction actionSnapToGrid;
 	private AbstractJmodelAction editUndo;
 	private AbstractJmodelAction editRedo;
 
@@ -320,6 +267,7 @@
 		addBlockingRegion = new AddBlockingRegion(this);
 
 		actionSetRight = new ActionSetRight(this);
+		actionSnapToGrid = new SnapToGrid(this);
 		takeScreenShot = new TakeScreenShot(this);
 
 		actionRotate = new ActionRotate(this);
@@ -330,6 +278,8 @@
 		switchToExactSolver = new SwitchToExactSolver(this);
 		// Initialize new Component bar
 		componentBar = new ComponentBar(this);
+
+		((JmtRouting)JmtGraphConstants.ROUTING_JMT).setMediator(this);
 	}
 
 	/**
@@ -415,6 +365,10 @@
 		addBlockingRegion.setEnabled(state);
 	}
 
+	public void enableSnapToGrid(boolean state) {
+		actionSnapToGrid.setEnabled(state);
+	}
+
 	public void enableSetRight(boolean state) {
 		actionSetRight.setEnabled(state);
 	}
@@ -423,6 +377,10 @@
 		return actionSetRight;
 	}
 
+	public AbstractJmodelAction getSnapToGrid() {
+		return actionSnapToGrid;
+	}
+
 	public AbstractJmodelAction getEditDefaults() {
 		return editDefaults;
 	}
@@ -689,6 +647,7 @@
 		setSelect.setEnabled(false);
 		actionRotate.setEnabled(false);
 		actionSetRight.setEnabled(false);
+		actionSnapToGrid.setEnabled(false);
 
 		// Enable the action to perform editing user classes
 		editUserClasses.setEnabled(true);
@@ -781,6 +740,7 @@
 		actionDelete.setEnabled(false);
 		actionRotate.setEnabled(false);
 		actionSetRight.setEnabled(false);
+		actionSnapToGrid.setEnabled(false);
 
 		setSelect.setEnabled(false);
 		simulate.setEnabled(false);
@@ -1017,6 +977,20 @@
 			// Visualizes connection only if it can be created into data structure
 			if (model.setConnected(sourceKey, targetKey, true)) {
 				graph.getModel().insert(insert, viewMap, cs, null, null);
+			} else { // duplicate connection
+				InputPort inputPort = (InputPort) inPort.getCell();
+				JmtCell target = (JmtCell) inputPort.getParent();
+				if (target != null && target.numInEdges() > 1) {
+					target.SubIn();
+					target.remove(inputPort);
+				}
+
+				OutputPort outputPort = (OutputPort) outPort.getCell();
+				JmtCell source = (JmtCell) outputPort.getParent();
+				if (source != null && source.numOutEdges() > 1) {
+					source.SubOut();
+					source.remove(outputPort);
+				}
 			}
 		}
 	}
@@ -1062,7 +1036,7 @@
 		viewMap.put(connection, map);
 		Object[] insert = new Object[] { connection };
 		ConnectionSet cs = new ConnectionSet();
-		// Finds sourcePort
+		// Finds free sourcePort
 		Iterator it;
 		it = source.getChildren().iterator();
 		DefaultPort tmpPort, sourcePort, targetPort;
@@ -1069,27 +1043,53 @@
 		sourcePort = null;
 		while (it.hasNext()) {
 			tmpPort = (DefaultPort) it.next();
-			if (tmpPort instanceof OutputPort) {
+			if (tmpPort instanceof OutputPort && tmpPort.getEdges().size() == 0) {
 				sourcePort = tmpPort;
 			}
 		}
-		// Finds targetPort
+
+		// Otherwise create a new one
+		if (sourcePort == null) {
+			sourcePort = new OutputPort(source);
+			source.insert(sourcePort, source.getChildCount() - 1);
+			source.AddOut();
+			graph.getGraphLayoutCache().putMapping(sourcePort, new PortView(sourcePort));
+		}
+
+		// Finds free targetPort
 		it = target.getChildren().iterator();
 		targetPort = null;
 		while (it.hasNext()) {
 			tmpPort = (DefaultPort) it.next();
-			if (tmpPort instanceof InputPort) {
+			if (tmpPort instanceof InputPort && tmpPort.getEdges().size() == 0) {
 				targetPort = tmpPort;
 			}
 		}
-		if (sourcePort != null && targetPort != null) {
-			cs.connect(connection, sourcePort, true);
-			cs.connect(connection, targetPort, false);
-			// Adds connection to the graph only if it can be created into data structure
-			if (model.setConnected(sourceKey, targetKey, true) || forced) {
-				graph.getModel().insert(insert, viewMap, cs, null, null);
-				return connection;
+
+		// Otherwise create a new one
+		if (targetPort == null) {
+			targetPort = new InputPort(target);
+			target.insert(targetPort, target.getChildCount() - 1);
+			target.AddIn();
+			graph.getGraphLayoutCache().putMapping(targetPort, new PortView(targetPort));
+		}
+
+		cs.connect(connection, sourcePort, true);
+		cs.connect(connection, targetPort, false);
+		// Adds connection to the graph only if it can be created into data structure
+		if (model.setConnected(sourceKey, targetKey, true) || forced) {
+			graph.getModel().insert(insert, viewMap, cs, null, null);
+			return connection;
+		} else { // Add failed, remove ports if necessary
+			if (source.numOutEdges() > 1) {
+				source.SubOut();
+				source.remove(sourcePort);
 			}
+
+			if (target.numInEdges() > 1) {
+				target.SubIn();
+				target.remove(targetPort);
+			}
 		}
 		return null;
 	}
@@ -1122,8 +1122,15 @@
 	 */
 	public PortView getInPortViewAt(int x, int y) {
 		return (PortView) graph.getGraphLayoutCache().getMapping(graph.getInPortAt(x, y), false);
+
 	}
 
+	public PortView getFreeInPortViewAt(int x, int y) {
+		InputPort p = graph.getFreeInPortAt(x, y);
+		return (PortView) graph.getGraphLayoutCache().getMapping(p, false);
+
+	}
+
 	/** gets the first portView of the output port of the cell at position
 	 *
 	 * @param x
@@ -1166,6 +1173,7 @@
 					((CellComponent) jcell.getUserObject()).getKey());
 			// Adds on the top a panel to change station name
 			stationPanel.add(new StationNamePanel(model, ((CellComponent) jcell.getUserObject()).getKey()), BorderLayout.NORTH);
+			boolean oldPinState = jcell.isPinned();
 			dialogFactory.getDialog(stationPanel, "Editing " + jcell.getUserObject().toString() + " Properties...");
 
 			// Updates cell dimensions if name was changed too much...
@@ -1179,7 +1187,20 @@
 				jcell.updatePortPositions(nest, GraphConstants.getIcon(attr), cellDimension);
 				graph.getGraphLayoutCache().edit(nest);
 			}
-		}
+
+			if (oldPinState != jcell.isPinned()) {
+				ImageIcon lockIcon = JMTImageLoader.loadImage("lock", new Dimension(16, 16));
+				Icon newIcon;
+				if (jcell.isPinned()) {
+					newIcon = new MergedIcon(JMTImageLoader.loadImage(jcell.getIcon()), lockIcon);
+				} else {
+					newIcon = JMTImageLoader.loadImage(jcell.getIcon());
+				}
+				GraphConstants.setIcon(jcell.getAttributes(), newIcon);
+				graph.getGraphLayoutCache().reload();
+				graphRepaint();
+			}
+ 		}
 		// Blocking region editing
 		else if ((cell != null) && (cell instanceof BlockingRegion)) {
 			Object regionKey = ((BlockingRegion) cell).getKey();
@@ -1290,11 +1311,27 @@
 
 		if (!edges.isEmpty()) {
 			// Removes edges from graph
+			List<Object> cellsList = java.util.Arrays.asList(cells);
+			for (Object e: edges) {
+				if (cellsList.indexOf(e) < 0) { // delete only unselected edges
+					JmtEdge link = (JmtEdge) e;
+					InputPort targetPort = (InputPort) link.getTarget();
+					JmtCell target = (JmtCell) targetPort.getParent();
+					if (target.numInEdges() > 1) { // avoids situation in which there are no InputPorts for target
+						target.SubIn();
+						target.remove(targetPort);
+					}
+
+					OutputPort sourcePort = (OutputPort) link.getSource();
+					JmtCell source = (JmtCell) sourcePort.getParent();
+					if (source.numOutEdges() > 1) { // avoids situation in which there are no OutputPorts for source
+						source.SubOut();
+						source.remove(sourcePort);
+					}
+				}
+			}
 			graphmodel.remove(edges.toArray());
 		}
-		// Removes cells from graph
-		graphmodel.remove(cells);
-
 		// Checks if all children of a blocking region have been removed
 		Iterator<Object> it = regions.iterator();
 		while (it.hasNext()) {
@@ -1333,10 +1370,30 @@
 				model.deleteStation(((CellComponent) ((JmtCell) cell).getUserObject()).getKey());
 			} else if (cell instanceof JmtEdge) {
 				JmtEdge link = (JmtEdge) cell;
+				InputPort targetPort = (InputPort) link.getTarget();
+				if (targetPort != null) {
+					JmtCell target = (JmtCell) targetPort.getParent();
+					if (target.numInEdges() > 1) { // avoids situation in which there are no InputPorts for target
+						target.SubIn();
+						target.remove(targetPort);
+					}
+				}
+
+				OutputPort sourcePort = (OutputPort) link.getSource();
+				if (sourcePort != null) {
+					JmtCell source = (JmtCell) sourcePort.getParent();
+					if (source.numOutEdges() > 1) { // avoids situation in which there are no OutputPorts for source
+						source.SubOut();
+						source.remove(sourcePort);
+					}
+				}
 				model.setConnected(link.getSourceKey(), link.getTargetKey(), false);
 			}
 		}
 
+		// Removes cells from graph
+		graphmodel.remove(cells);
+
 		// If no stations remains gray select and link buttons
 		if (graphmodel.getRootCount() == 0) {
 			componentBar.clearButtonGroupSelection(0);
@@ -1343,6 +1400,7 @@
 			setConnect.setEnabled(false);
 			setSelect.setEnabled(false);
 			actionSetRight.setEnabled(false);
+			actionSnapToGrid.setEnabled(false);
 		}
 
 		// Selects components from removed blocking regions
@@ -2884,14 +2942,21 @@
 			JmtCell current = (JmtCell) cell;
 			Map<Object, Map> nested = new Hashtable<Object, Map>();
 			Map attributeMap = new Hashtable();
-			ImageIcon icon;
+			Icon icon;
 			if (current.isLeftInputCell()) {
 				icon = JMTImageLoader.loadImage(current.getIcon(), ImageLoader.MODIFIER_MIRROR);
 			} else {
 				icon = JMTImageLoader.loadImage(current.getIcon());
 			}
-			GraphConstants.setIcon(attributeMap, icon);
 
+			if (current.isPinned()) {
+				Rectangle2D bounds = GraphConstants.getBounds(current.getAttributes());
+				ImageIcon lockIcon = JMTImageLoader.loadImage("lock", new Dimension(16, 16));
+				GraphConstants.setIcon(attributeMap, new MergedIcon(icon, lockIcon, current.isLeftInputCell() ? (int) bounds.getWidth() - 16 : 0, 0));
+			} else {
+				GraphConstants.setIcon(attributeMap, icon);
+			}
+
 			nested.put(cell, attributeMap);
 			current.setLeftInputCell(!current.isLeftInputCell());
 			current.updatePortPositions(nested, icon, current.getSize(graph));
@@ -3089,7 +3154,9 @@
 						- (int) (boundspadre.getHeight() / 2) + 30);
 			}
 
-			GraphConstants.setBounds(prev.getAttributes(), boundspadre);
+			if (!prev.isPinned()) {
+				GraphConstants.setBounds(prev.getAttributes(), boundspadre);
+			}
 			x = (int) boundspadre.getCenterX() + widthMax + 50;
 			prev.seen = true;
 			flag2 = true;
@@ -3121,7 +3188,8 @@
 			Rectangle bounds = GraphConstants.getBounds(((JmtCell) next.get(0)).getAttributes()).getBounds();
 			bounds.setLocation((int) (boundspadre.getCenterX()) + widthMax + 50 - (int) (bounds.getWidth() / 2),
 					(int) boundspadre.getCenterY() - (int) (bounds.getHeight() / 2));
-			GraphConstants.setBounds(((JmtCell) next.get(0)).getAttributes(), bounds);
+			if (!(((JmtCell) next.get(0)).isPinned()))
+				GraphConstants.setBounds(((JmtCell) next.get(0)).getAttributes(), bounds);
 
 			((JmtCell) next.get(0)).seen = true;
 			j = searchNext((JmtCell) next.get(0));
@@ -3160,8 +3228,10 @@
 				Rectangle bounds = GraphConstants.getBounds(((JmtCell) sons.get(i)).getAttributes()).getBounds();
 				bounds.setLocation((int) (boundspadre.getCenterX()) + widthMax + 50 - (int) (bounds.getWidth() / 2),
 						w - (int) (bounds.getHeight() / 2) + 80);
-				GraphConstants.setBounds(((JmtCell) sons.get(i)).getAttributes(), bounds);
 
+				if (!(((JmtCell) sons.get(i)).isPinned()))
+					GraphConstants.setBounds(((JmtCell) sons.get(i)).getAttributes(), bounds);
+
 				((JmtCell) sons.get(i)).seen = true;
 				listEdges = DefaultGraphModel.getOutgoingEdges(graphmodel, sons.get(i));
 
@@ -3324,6 +3394,7 @@
 			setConnect.setEnabled(false);
 			setSelect.setEnabled(false);
 			actionSetRight.setEnabled(false);
+			actionSnapToGrid.setEnabled(false);
 		}
 
 		// Selects components from removed blocking regions
@@ -3349,4 +3420,119 @@
 		}
 	}
 
+	public PortView getFreeOutPortViewAt(int x, int y) {
+		return (PortView) graph.getGraphLayoutCache().getMapping(graph.getFreeOutPortAt(x, y), false);
+	}
+
+	public void tryAdjustGraph() {
+		boolean atLeastOnePinned = false;
+		Object[] cells = graph.getDescendants(graph.getRoots());
+		Rectangle2D[] cellsBounds = new Rectangle2D[cells.length];
+		boolean[] cellsRotateState = new boolean[cells.length];
+		for (int i = 0; i < cells.length; i++) {
+			if (cells[i] instanceof JmtCell) {
+				JmtCell cell = (JmtCell) cells[i];
+				cellsBounds[i] = GraphConstants.getBounds(cell.getAttributes()).getBounds();
+				cellsRotateState[i] = cell.isLeftInputCell();
+				if (cell.isPinned()) {
+					atLeastOnePinned = true;
+				}
+			}
+
+		}
+
+		adjustGraph();
+
+		if (atLeastOnePinned) {
+			double direction;
+			double minDistance = Double.POSITIVE_INFINITY;
+			double slope = 0;
+			int minIndex = -1;
+
+			for (int i = 0; i < cells.length; i++) {
+				if (cells[i] instanceof JmtCell) {
+					JmtCell cell = (JmtCell) cells[i];
+					if (!cell.isPinned()) {
+						Rectangle2D repositionedBounds = GraphConstants.getBounds(cell.getAttributes()).getBounds();
+						double euclideanDist = Math.sqrt(Math.pow((cellsBounds[i].getX() - repositionedBounds.getX()), 2) + Math.pow((cellsBounds[i].getY() - repositionedBounds.getY()), 2));
+						if (euclideanDist < minDistance) {
+							minDistance = euclideanDist;
+							slope = (repositionedBounds.getY() - cellsBounds[i].getY()) / (repositionedBounds.getX() - cellsBounds[i].getX());
+							//slope = (cellsBounds[i].getY() - repositionedBounds.getY()) / (cellsBounds[i].getX() - repositionedBounds.getX());
+							minIndex = i;
+						}
+					}
+				}
+			}
+
+			for (int i = 0; i < cells.length; i++) {
+				if (cells[i] instanceof JmtCell) {
+					JmtCell cell = (JmtCell) cells[i];
+					if (!cell.isPinned()) {
+						if (i == minIndex) {
+							GraphConstants.setBounds(cell.getAttributes(), cellsBounds[i]);
+						} else {
+							Rectangle2D repositionedBounds = GraphConstants.getBounds(cell.getAttributes()).getBounds();
+							if (cellsBounds[i].getX() > repositionedBounds.getX()) {
+								direction = 1;
+							} else {
+								direction = -1;
+							}
+							double xfinal = direction * Math.sqrt(minDistance * minDistance / (1 + slope * slope)) + repositionedBounds.getX();
+							double yfinal = slope * (xfinal - repositionedBounds.getX()) + repositionedBounds.getY();
+							repositionedBounds.setRect(xfinal, yfinal, repositionedBounds.getWidth(), repositionedBounds.getHeight());
+							GraphConstants.setBounds(cell.getAttributes(), repositionedBounds);
+						}
+					}
+				}
+			}
+
+			graphRepaint();
+			graph.getGraphLayoutCache().reload();
+			avoidOverlappingCell(cells);
+		}
+
+		int result = JOptionPane.showConfirmDialog(mainWindow, "Keep the result of autoarrange?", "Autoarrange", JOptionPane.YES_NO_OPTION);
+		if (result == JOptionPane.NO_OPTION) {
+			for (int i = 0; i < cells.length; i++) {
+				if(cells[i] instanceof JmtCell) {
+					JmtCell cell = (JmtCell) cells[i];
+					GraphConstants.setBounds(cell.getAttributes(), cellsBounds[i]);
+					if (cell.isLeftInputCell() != cellsRotateState[i]) { // adjustGraph has rotated this cell, restore its previous state
+						rotateComponent(new Object[] { cell });
+					}
+				}
+			}
+			graphRepaint();
+			graph.getGraphLayoutCache().reload();
+			avoidOverlappingCell(cells);
+		}
+	}
+
+	public void snapToGrid() {
+
+		int cellSize;
+		String size = JOptionPane.showInputDialog(mainWindow, "Please specify the cell size in pixels");
+		try {
+			cellSize = Integer.parseInt(size);
+		} catch (NumberFormatException e) {
+			cellSize = 50;
+		}
+		Object[] cells = graph.getDescendants(graph.getRoots());
+
+		for (int i = 0; i < cells.length; i++) {
+			if (cells[i] instanceof JmtCell) {
+				JmtCell cell = (JmtCell) cells[i];
+				if (!cell.isPinned()) {
+					Rectangle2D bounds = GraphConstants.getBounds(cell.getAttributes()).getBounds();
+					bounds.setRect(Math.ceil(bounds.getX() / cellSize) * cellSize, Math.ceil(bounds.getY() / cellSize) * cellSize, bounds.getWidth(), bounds.getHeight());
+					GraphConstants.setBounds(cell.getAttributes(), bounds);
+				}
+			}
+		}
+
+		graphRepaint();
+		graph.getGraphLayoutCache().reload();
+		avoidOverlappingCell(cells);
+	}
 }
Index: src/main/java/jmt/gui/jsimgraph/controller/actions/ActionSetRight.java
===================================================================
--- src/main/java/jmt/gui/jsimgraph/controller/actions/ActionSetRight.java	(revision 978)
+++ src/main/java/jmt/gui/jsimgraph/controller/actions/ActionSetRight.java	(working copy)
@@ -5,6 +5,8 @@
 
 import jmt.gui.jsimgraph.controller.Mediator;
 
+import javax.swing.*;
+
 /**
  * A class representing a "redo" action.
  * @author Giuseppe De Cicco & Fabio Granara
@@ -35,6 +37,6 @@
 	boolean repeat = false;
 
 	public void actionPerformed(ActionEvent e) {
-		mediator.adjustGraph();
+		mediator.tryAdjustGraph();
 	}
 }
Index: src/main/java/jmt/gui/jsimgraph/mainGui/ComponentBar.java
===================================================================
--- src/main/java/jmt/gui/jsimgraph/mainGui/ComponentBar.java	(revision 978)
+++ src/main/java/jmt/gui/jsimgraph/mainGui/ComponentBar.java	(working copy)
@@ -63,6 +63,8 @@
 		addGenericButton(m.getRotate());
 		// Set right button
 		addGenericButton(m.getSetRight());
+		// Snap to grid button
+		addGenericButton(m.getSnapToGrid());
 
 		// Disables all components button
 		enableButtons(false);
Index: src/main/java/jmt/gui/jsimgraph/panels/StationNamePanel.java
===================================================================
--- src/main/java/jmt/gui/jsimgraph/panels/StationNamePanel.java	(revision 978)
+++ src/main/java/jmt/gui/jsimgraph/panels/StationNamePanel.java	(working copy)
@@ -24,10 +24,7 @@
 import java.awt.event.KeyEvent;
 import java.awt.event.KeyListener;
 
-import javax.swing.Box;
-import javax.swing.JLabel;
-import javax.swing.JPanel;
-import javax.swing.JTextField;
+import javax.swing.*;
 import javax.swing.border.EtchedBorder;
 import javax.swing.border.TitledBorder;
 
@@ -49,6 +46,7 @@
 	private JmodelStationDefinition sd;
 	private Object key;
 	private JTextField name = new JTextField();
+	private JCheckBox pinned = new JCheckBox();
 
 	/**
 	 * Creates a new Station Name Panel
@@ -65,13 +63,22 @@
 	 * Inits this panel's components and their action listeners
 	 */
 	private void init() {
+		BorderLayout pinLayout = new BorderLayout(5, 0);
+		JPanel pinPanel = new JPanel();
+		pinPanel.setLayout(pinLayout);
 		setLayout(new BorderLayout(5, 5));
 		setBorder(new TitledBorder(new EtchedBorder(), "Station Name"));
 		add(new JLabel("Station Name: "), BorderLayout.WEST);
 		name.setText(sd.getStationName(key));
+		pinned.setSelected(sd.isPinned(key));
 		add(name, BorderLayout.CENTER);
+		pinPanel.add(new JLabel("Pin:"), BorderLayout.WEST);
+		pinPanel.add(pinned, BorderLayout.CENTER);
+		add(pinPanel, BorderLayout.EAST);
 		add(Box.createVerticalStrut(5), BorderLayout.SOUTH);
 		inputListener listener = new inputListener();
+		pinned.addFocusListener(listener);
+		pinned.addKeyListener(listener);
 		name.addKeyListener(listener);
 		name.addFocusListener(listener);
 	}
@@ -86,7 +93,9 @@
 		 */
 		protected void updateValues() {
 			sd.setStationName(key, name.getText());
+			sd.setIsPinned(key, pinned.isSelected());
 			name.setText(sd.getStationName(key));
+			pinned.setSelected(sd.isPinned(key));
 		}
 
 		public void focusLost(FocusEvent e) {
Index: src/main/resources/jmt/common/xml/JModelGUI.xsd
===================================================================
--- src/main/resources/jmt/common/xml/JModelGUI.xsd	(revision 978)
+++ src/main/resources/jmt/common/xml/JModelGUI.xsd	(working copy)
@@ -31,6 +31,7 @@
 									<xs:attribute name="x" type="jdouble" use="required"/>
 									<xs:attribute name="y" type="jdouble" use="required"/>
 									<xs:attribute name="rotate" type="xs:boolean" use="optional"/>
+									<xs:attribute name="pin" type="xs:boolean" use="optional"/>
 								</xs:complexType>
 							</xs:element>
 						</xs:sequence>
